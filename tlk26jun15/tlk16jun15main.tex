% !TeX root = tlk16jun15h.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US


\input{../HEADER/HEADER}
% ********************************

\author{Alexander Maringele}
\title{flea\\
}
%\subtitle{of an instantiation-based first order theorem prover with equality}
\subtitle{bit(e)s and pieces}
%\subtitle{in easy examples}
\date{June 15th, 2016}
%======

%\includeonly{DiscriminationTree}
\begin{document}

\selectlanguage{english}

\input{../TitleFrame} 

\input{hofstadter}

\frame{
	\setcounter{tocdepth}{1}
	\tableofcontents}

%\include{Title}
\include{References}
%\include{Overview}

%====================================================================
% BEGIN: CONTENT ----------------------------------------------------
%====================================================================




%\input{../trmidx/MOTIVATION/forwardSubsumption.tex}

\section{Previously}

\begin{frame}
	% We transform a first formula in to a equisatisfiable set of clauses,
	% i.e. the conjunction of universally quantified disjunction of variable distinct first order literals
	% then we check if the set is satisfiable, if not then the formula is a theorem.
	\frametitle{Goal}

\input{../tikz/refutation}

\end{frame}

\include{Reminder}

\section{Implementation}

\frame{
\input{IMPL/loop}
}

\subsection{Tools}

%\begin{frame}
%	\begin{enumerate}
%		\item Flex, Bison for parsing
%		\item Swift, C
%		\item Xcode IDE
%		\item yices 2
%	\end{enumerate}}
%\end{frame}

\subsection{Structure}

\begin{frame}
	\lstinline|Hello, World!|
	\end{frame}

\subsection{Indexing}

\begin{frame}
	\begin{enumerate}
		\item Path indices of selected literals for clauses to find clashing literals
		\item Discrimination trees of literals for clauses to find variants of clauses
	\end{enumerate}
	\end{frame}


%\include{Motivation}
%
%\include{Position}
%
%\include{PathIndexing}
%
%\include{DiscriminationTree}
%
%\include{SubstitutionTrees}
%
%\include{Experiences}

\section{Equality}
%\include{Equality}


%\frame{
%	$x = \ma \lor x\neq \ma$\hfill  $\bot = \bot \lor \bot \neq \bot$
%	
%	$\mf(\ma) \neq \mf(\mb)$\hfill  $\mf(\bot) \neq \mf(\ma)$
%	
%	$R = \{ x = \ma \}$ is ground complete
%	
%	$\sigma= \{x\mapsto\mb\}$ $(x=\ma) \sigma = \ma \to \mb$ with $\ma > \mb$ $\mf(a) \neq \mb$
%	
%	
%	
%	
%	}
%	
%	\frame {
%		% see PUZ063-1.p 
%		
%		$\mP(\ma), \lnot\mP(\mf(\ma,\mb)), \mf(x,\mb)=x$
%		
%		$\mP(\ma), \lnot\mP(\mf(\ma,\mb)), \mf(\bot,\mb)=\bot$
%		
%		$\{\mf(x,\mb)=x\}$ is ground complete and with $\{ x\mapsto \ma \}$ we get $\lnot\mP(\ma)$
%		}
\section{work to do}

\frame{
	\begin{itemize}
		\item migrate to Linux / Swift 3
		\item integrate unit superposition
		\item integrate ordered maximal completion 
		\item experiments
		\item optimizations
	\end{itemize}
	}
\subsection{optimization}

\frame{
	\begin{center}
	\includegraphics[scale=0.5]{../xkcd/optimization}
	\end{center}
	}
 
\end{document}