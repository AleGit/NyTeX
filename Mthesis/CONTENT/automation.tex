% !TeX root = ../mythesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automated Theorem Proving}\label{chapter:automation}

\input{epigraphs/syllogism}

In this chapter we will discuss complete refutation proving procedures.
It seems natural to expect decision procedures
for decidable fragments of first order logic
(Section~\ref{sec:decidable:fol:fragments})
or decidable first order theories (Section~\ref{sec:decidable:fol:theories}).
But we will demonstrate with basic examples
that decision procedures do not automatically
fall out from complete refutation procedures.


%An we judge the procedures by there theoretical performance on decidable fragments.
%
% If we fail to prove a theorem directly we can show that its negation leads to an contradiction, in the case of a first order theorem, that its negation (which can be transformed into a equisatisfiable set of clauses) is not satisfiable.
We know by Herbrand`s theorem
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Herbrand model.
And we know by compactness
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of a set of ground instances is decidable
as we have already implicitly stated in Table~\vref{tab:decidedable:FiniteModelProperty}
with decidable class \( {[ \, \exists^{∗}, all, all \, ]}_{=} \).
So a natural idea of first order theorem proving
is to derive an unsatisfiable and finite set of ground instances for a given set of clauses.
In general a failure in this search does not show satisfiability of the given set of clauses.
In practice we make many detours in the search and we experience very finite resources of space and time,
while in general there is no bound on the size of a smallest set of unsatisfiable ground instances.

%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.


To actually prove a theorem automatically \cite{books/el/RobinsonV01}
we first can make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we can efficiently transform a negated sentence into an
\coloremph{equisatisfiable} set of clauses,
e.g.~efficiently with Skolemization~\cite{books/el/RV01/Hahnle01} 
and Tseitin transformation~\cite{tseitin70},
i.e.~the negated sentence is satisfiable if and only if the constructed 
set of clauses is satisfiable.

%This can be done efficiently with Skolemization \cite{books/el/RV01/Hahnle01} and Tseitin transformation \cite{tseitin70, PLAISTED1986293} as shown in \cite{Nonnengart01computingsmall}.

It would be sufficient to just luckily guess an unsatisfiable set of ground instances.
Usually instantiation based automated provers generate
a sequence of growing sets of ground instances
such that an unsatisfiable one will be found
for an arbitrary unsatisfiable set of clauses
eventually.

First we translate axioms and lemmata into clausal normal form in Sections~\ref{sec:clausal:normal:form},
then we look at Gilmore's Prover from 1960 in Section~\ref{sec:gilmore:prover}.
After that we look at more modern calculi for first order refutation theorem proving
without equality in Section~\ref{sec:proving:without:equaltiy} and with equality in Section~\ref{sec:proving:with:equality}.


%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula \( F \) is satisfiable if and only if a set of clauses \( S \) is satisfiable
%%	then we call \( F \) and \( S \) are equisatisfiable.
%\end{definition}
%

%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.

\section{Theory Axioms in Clausal Normal Form}\label{sec:clausal:normal:form}

In the previous chapter we expressed axioms and lemmas of first order theories in \FOF{} syntax.
As many provers can only check satisfiability of sets of clauses, 
we first have to transform
those axioms into (at least) equisatisfiable representations in \CNF{} syntax
as summarized for equivalence, congruence, natural numbers, and induction in Table~\vref{tab:natural:numbers},
for addition and multiplication in Table~\vref{tab:addition:multiplication}.
Bur first let us demonstrate Skolemization for the induction schema from Definition~\vref{def:natural:numbers:axioms}.

\begin{example} Let \( G \) a first order formula with free variable \( x \).
	We lazily write \( G(x') \) for \( G\{x\mapsto x'\} \).
	We have to introduce a fresh constant skolem function \( \mc_{_G} \)---briefly introduced 
	in Section \ref{sec:equisatisfiability}---
	for every formula \( G \) we want to apply the induction schema.
	\begin{align*}
		{		
			G(0) \land \, \forall x'\,
		(\underline{G(x') \limp G(\msucc(x'))})
		\, \limp \, 
		\forall x \, G(x)
		} 
		\tag*{   \( A \limp B \equiv \lnot A \lor B \ (2\times)\)}
\\
\underline{\lnot(
G(0) \land \, \forall x'\,
(\lnot G(x') \lor G(\msucc(x')))
)} \lor 
\forall x \, G(x) 
\tag*{\( \lnot(A\land \forall x' B) \equiv \lnot A\lor \exists x' \lnot B \)}
\\
\lnot G(0) \lor \exists x'\, 
\underline{\lnot(\lnot G(x') \lor G(\msucc(x')))}
\lor 
\forall x \, G(x)
\tag*{\( \lnot(\lnot A \lor B) \equiv (A \land \lnot B) \)}
\\
\lnot G(0) \lor 
\exists x'\,(G(x') \land \lnot G(\msucc(x')))
\lor 
\forall x \, G(x)
\tag*{\( (\exists x' A) \lor C \equiv \exists x' (A \lor C) \)}
\\
\exists x'\,(
\lnot G(0) \lor 
(G(x') \land \lnot G(\msucc(x')))
\lor 
\forall x \, G(x)
)
\tag*{\( \exists x' B(x') \equisat B(\mc_{_B}) \)}
\\
\lnot G(0) \lor 
(G(\mc_{_G}) \land \lnot G(\msucc(\mc_{_G}))) 
\lor 
\forall x \, G(x)
% \tag*{\( (A\land B) \lor C \equiv (A\lor C) \land (B\lor C) \)}
\tag*{distribute \(\lor\) over \(\land\)}
\\
{\lnot G(0) \lor 
G(\mc_{_G})
\lor 
\forall x \, G(x)}
\land
{\lnot G(0) \lor 
\lnot G(\msucc(\mc_{_G}))
\lor 
\forall x \, G(x)}
% \tag*{ \( A \lor \forall x B \equisat A \lor B(x) \)}
\tag*{easily clausifiable}
\end{align*}
\end{example}

\begin{table}[hbt]
	\begin{align*}
	x\mEQ x,\
	x\mNE y\lor y\mEQ x,\
	x\mNE y\lor y\mNE z\lor x\mEQ z
	\tag*{equivalence}
	\\
	x\mNE y\lor \msucc(x)\mEQ\msucc(y)
	\tag*{congruence of \( \msucc \)}
	\\
	\msucc(x) \mNE 0,\
	\msucc(x) \mNE \msucc(y) \lor x \mEQ y
	\tag*{natural numbers}
	\\
	\lnot G(0) \lor {G(\mc_{_G})} \lor G(x),\
	\lnot G(0) \lor {\lnot G(\msucc(\mc_{_G}))} \lor G(x)
	\tag*{induction schema}
	\end{align*}
	\caption{The theory of natural numbers in \CNF}\label{tab:natural:numbers}
\end{table}

% \begin{proof}
% We use first order equivalence and satisfiability transformations---briefly introduced 
% in Section \ref{sec:equisatisfiability}---on the induction schema 
% applied to an arbitrary formula \( G(x) \).
% \begin{align*}
% 	G(0) \land  \, \forall x'\, \left(G(x') \limp G(\msucc(x'))\right)
% \, \limp \, \forall x \, G(x)
% &\equiv\\
% \lnot\left(
% 	G(0) \land  \, \forall x'\, \left(G(x') \limp G(\msucc(x'))\right)
% \right)
% \lor \forall x \, G(x)
% &\equiv\\
% \left(
% 	\lnot G(0) \lor  \, \lnot\forall x'\, \left(\lnot G(x') \lor G(\msucc(x'))\right)
% \right)
% \lor \forall x \, G(x)
% &\equiv\\
% \left(
% 	\lnot G(0) \lor  \, \exists x'\, \left(G(x') \land \lnot G(\msucc(x'))\right)
% \right)
% \lor \forall x \, G(x)
% &\equiv\\
% \exists x' \forall x
% \left(
% 	\lnot G(0) \lor \left(G(x') \land \lnot G(\msucc(x'))\right)
% \right)
% \lor G(x)
% &\equiv\\
% \exists x' \forall x
% \left(
% 	(\lnot G(0) \lor G(x') \lor G(x))
% 	\land
% 	(\lnot G(0) \lor \lnot G(\msucc(x')) \lor G(x))
% \right)
% &\equisat\\
% \forall x
% \left(
% 	(\lnot G(0) \lor G(\mc_G) \lor G(x))
% 	\land
% 	(\lnot G(0) \lor \lnot G(\msucc(\mc_G)) \lor G(x))
% \right)
% &\equisat\tag*{Skolemization}\\
% \lnot G(0) \lor G(\mc_G) \lor G(x),\,
% 	\lnot G(0) \lor \lnot G(\msucc(\mc_G)) \lor G(x)
% 	\tag*{Clausification}
% \end{align*}
% The remaining axioms can be transformed by the same approach without the need for the introduction of fresh skolem constants.
% \end{proof}


\begin{remark}
	For brevity, we have used and will use the same variable symbols in different clauses.
	Even so, we always can assume that different clauses are variable distinct.
	If necessary we just apply a suitable renaming, i.e.~a variable substitution (see Definition \vref{def:substitution}), per clause.
\end{remark}

\begin{table}[hbt]
	\begin{align*}
		x_1\mNE y_1\lor x_2\mNE y_2\lor x_1+y_1 \mEQ x_2+y_2
		\tag*{congruence of \( + \)}
		\\
		x + 0 \mEQ x,\
		x+\msucc(x) \mEQ \msucc(x+y)
		\tag*{addition}
		\\
		x_1\mNE y_1\lor x_2\mNE y_2\lor x_1\times y_1 \mEQ x_2\times y_2
		\tag*{congruence of \( \times \)}
		\\
		x \times 0 \mEQ 0,\
		x \times\msucc(y) \mEQ (x\times y) + x
		\tag*{multiplication}
%		\\[0.5em]
%		\\
%		\overbrace{x+ (y+ z) \mEQ (x+ y) + z}^{A}, \,
%		\overbrace{x+ y \mEQ y+ x}^{C}, \,
%		\overbrace{x+ 0 \mEQ x, \, 0+ x\mEQ x}^N
%		\tag*{ACN of \( + \)}
%		\\
%		\underbrace{x\times (y\times z) \mEQ (x\times y) \times z}_A, \,
%		\underbrace{x\times y \mEQ y\times x}_C, \,
%		\underbrace{x\times \msucc(0) \mEQ x, \, \msucc(0)\times x\mEQ x}_N
%		\tag*{ACN of \( \times \)}
	\end{align*}
	\caption{The axioms for addition and multiplication in \CNF}\label{tab:addition:multiplication}
\end{table}

\begin{example} For the formula \( G(x)=\msucc(x)\mNE x \) we state the induction axioms in \CNF{} in the theory of natural numbers.
	We introduced the fresh constant \( \mc_{\msucc} \) in this satisfiability transformation process.
	\begin{gather*}
	\msucc(0)\mEQ 0 \lor \boxed{\msucc(\mc_{\msucc})\mNE \mc_{\msucc}} \lor \msucc(x)\mNE x \\
	\msucc(0)\mEQ 0 \lor \boxed{\msucc(\msucc(\mc_{\msucc}))\mEQ \msucc(\mc_{\msucc})} \lor \msucc(x)\mNE x
	\end{gather*}
\end{example}

%\begin{table}[hbt]
%	\begin{gather*}
%	0\circ e_\circ\mNE 0
%	\lor\boxed{
%		c_\circ \circ e_\circ \mEQ c_\circ
%	}
%	\lor z\circ e_\circ \mEQ z
%	\\
%	0\circ e_\circ\mNE 0
%	\lor\boxed{
%		\msucc(c_\circ) \circ e_\circ \mNE \msucc(c_\circ)
%	}
%	\lor z\circ e_\circ \mEQ z
%	\end{gather*}
%	\caption{Induction axioms for neutral element}
%	\label{tab:presburger:induction:clauses}
%\end{table}

%\begin{table}[hbt]
%	\begin{gather*}
%	{0+y\mNE y+0}
%	\lor\boxed{\mc_2+y\mEQ y+\mc_2}
%	\lor{z+y\mEQ y+z}
%	\\
%	0+y\mNE y+0 \lor
%	\boxed{\msucc(\mc_2)+y\mNE y+\msucc(\mc_2)}
%	\lor z+y\mEQ y+z
%	\end{gather*}
%	\caption{Induction axioms for commutativity}
%	\label{tab:presburger:induction:commutativity}
%\end{table}

\section{Gilmore's Prover}\label{sec:gilmore:prover}

In 1960 Paul Gilmore presented a first \coloremph{implementation} of an automated
theorem prover~\cite{5392528} for first order logic (without equality),
which happened to use an instantiation-based approach.
The procedure is complete, i.e.~for every valid formula
a refutation proof can be found eventually.

In practice this prover ran into memory issues or time outs more often than not.
We will discuss reasons for this inefficiency after we have described and demonstrated the procedure.

% First the negation of a sentence \( F \) has to be transformed into an equisatisfiable set of clauses.
% Then the prover`s procedure
% creates a sequence of finite sets of ground instances \( S_k \)
% for the set of clauses \( S\equisat\lnot F \) to prove the validity of a formula \( F \)
% by showing the unsatisfiability of \( S \).
% Each set \( S_k \) contains all possible round instances of \( S \)
% where all variables are substituted by elements of \( H_k \)
% from definition~\ref{def:hk} of the Herbrand universe.
% Each \( S_k \) is then transformed into a disjunctive normal form where satisfiability is obvious.
% The procedure is aborted when an unsatisfiable \( S_k \) is encountered.

\begin{procedure}[Gilmore's Prover]\label{proc:gilmore's:prover}
	We translate the negation of our formula \( F \) into an equisatisfiable set of clauses
	\( \lnot F \equisat S = \bigcup_{i=1}^{n} \mcC_i \) with an efficient algorithm~\cite{tseitin70, PLAISTED1986293}.
	Then we start our first iteration with \( k=0 \).
	\begin{enumerate}

		\item We create the set of all ground terms up to term depth \( k \),
		i.e.~the partial Herbrand universe \( H_k \) according to Definition~\ref{def:hk}.
		We use \( H_k \) to create the set of clause instances \( S_k \)
		by substituting all variables
		in each clause by terms from \( H_k \) in any possible permutation.
		\[ S_k = \bigcup_{i=1}^{n}
		 \{ \,
		\mcC_i\sigma \mid \mcC_i \in S, \, \sigma: \mcV\to H_k
		 \, \}
		\]

		\item We translate \( S_k \) into an equivalent disjunctive normal form
		(i.e.~a disjunction of conjunctions of literals)
		where satisfiability is easily checked.



		\item When every conjunction contains a pair of complementary literals
		then we exit the procedure and report unsatisfiability of \( S \),
		hence validity of \( F \).

		Otherwise we increase \( k \) by one and continue with step 1.
	\end{enumerate}
\end{procedure}

Gilmore's procedure will eventually terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses.
However the number of iterations has no general upper bound.
Otherwise it would be a decision procedure for satisfiability in first order logic
which does not exist because of undecidability of satisfiability in first order logic.

\begin{lemma}
	Gilmore's procedure is a decision procedure for monadic first order logic
	(Examples~\ref{ex:monadic} and~\ref{ex:fosca:is:mortal})
	and the Schönfinkel-Bernays fragment
	(see Table~\ref{tab:decidedable:FiniteModelProperty})
	of First Order Logic.
\end{lemma}

\begin{proof}
	In the absence of non-constant function symbols the set \( H'_{i+1} = \emptyset \) is empty.
	The procedure can stop after the first iteration because
	\( H_i = H_0 \) and \( S_i = S_0 \) for all \( i\geq0 \),
	i.e.~after the first iteration
	no new terms are added to the Herbrand model
	and no new ground instances can be generated.
\end{proof}

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:fosca:is:mortal}
	First we translate the syllogism into a formula \( F \) in first order logic.
	\begin{align*}
	F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C
	\tag*{formula}
	\\[0.5em]
	A &= \forall x \, ( \human(x) \limp \mortal(x)
	\tag*{theory}
	\\
	B &= \human(\fosca)
	\tag*{fact}
	\\
	C &= \mortal(\fosca)
	\tag*{conjecture}
	\end{align*}

	%We easily find a satisfying interpretation \( \mcI \) with domain \( \{ \fosca \} \) with
	%\( \fosca^\mcI = \fosca \),
	%\( \human^\mcI = \{ (\fosca) \} \),
	%\( \mortal^\mcI = \{ (\fosca) \} \).


	Then we easily translate the negated formula \( \lnot F = A\land B \land\lnot C \) 
	into an equisatisfiable clausal normal form 
	\( S = \{
		\lnot \human(x) \lor \mortal(x),\,
		\human(\fosca), \mortal(\fosca)
	\} \).
	
	Since there is exactly one constant we get
	\( H_0 = \{ \fosca \} \) and
	\( S_0 =
	 \{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\} \) in our first iteration.
	As last step we transform the single formula in
	the set of ground instances \( S_0 \) into a disjunctive normal form
	for easy satisfiability checking.
	%
	\begin{gather*}
	%S^{\ref{ex:fosca:is:mortal},0} \equiv \begin{array}{c}
	(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
	\\
	\lor
	\\
	(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
	%\end{array}
	\end{gather*}
	Both conjunctions contain complementary literals and hence we conclude 
	that the negated formula \( \lnot F \) is unsatisfiable, 
	the formula \( F \) is valid,
	and the given syllogism holds.
\end{example}

%
%On the other hand the procedure will never terminate
%even for very simple satisfiable sets where the Herbrand universe is infinite,
%i.e.~there is at least one non-constant function symbol.

\begin{example}\label{ex:unsat:nexsx}
	Let \( k\in\mathbb{N} \) be an arbitrary but fixed number.
	Consider the unsatisfiable set of clauses
	\(
		S = \{ \, \lnot\mcL_1, \, \mcL_2 \, \} =
		 \{ \,
		{ \lnot\mE(x, \msucc(x)) }, \,
		{ \mE(\msucc^{k}(y), \msucc(\msucc^{k}(y)))}
		 \, \}
	 \).
	The sets of instances \( S_{i} \) are satisfiable for all \( i<k \).
	The set of instances \( S_{k} \) is clearly unsatisfiable.
	%
	\begin{align*}
	H'_{0} =&{\ } \{ \, \mzero{} \, \}
	&
	S_{0} =&{\ } \{ \,
	{\colG \lnot\mE(\mzero,\msucc(\mzero))}, \,
	{\colHi \mE(\msucc^k(\mzero), \, \msucc(\msucc^k(\mzero)))}
	 \, \}
	\subsetneq S_k
	\\
	H'_{i+1} =&{\ } \{ \, \msucc(\msucc^{i}(\mzero)) \, \}
	&
	S_{i+1} \supsetneq&\
	 \{ \,
	{\colG \lnot\mE(\msucc^{i+1}(\mzero),\msucc(\msucc^{i+1}(\mzero))), \,
		\mE(\msucc^k(\msucc^{i+1}(\mzero)), \msucc(\msucc^k(\msucc^{i+1}(\mzero))))}
	 \, \}
	\\
	H'_{k} =&{\ } \{ \, \msucc^{k}(\mzero) \, \}
	&
	S_{k} \supsetneq&\
	 \{ \,
	{\colLo \lnot\mE(\msucc^{k}(\mzero),\msucc(\msucc^{k}(\mzero)))}, \,
	{\colG\mE(\msucc^k(\msucc^{k}(\mzero)), \msucc(\msucc^k(\msucc^{k}(\mzero))))}
	%	{\ldots}
	 \, \}
	\end{align*}
	We've produced \( 2\cdot k \)
	{ \coloremph{}{}irrelevant} instances,
	i.e.~these clauses did not cause any conflict in
	propositional satisfiability.
	In this example the guess for a finite unsatisfiable set of ground instances appears feasible and yields a smaller unsatisfiable set of ground instances.
	\[
	 \{ \,
	\lnot\mcL_1\sigma, \, \mcL_2\sigma
	 \, \} \qquad \sigma= \{ x\mapsto \msucc^k(\mzero), \, y\mapsto \mzero \}
	\]
\end{example}

\begin{example}\label{ex:sat:exy}
	Consider the satisfiable set of clauses
	\( S = \{ \lnot\mE(\mzero,\msucc(x)\} \).
	This set is clearly in the decidable Ackermann fragment of first order logic.
	But the procedure yields an infinite sequence of distinct and satisfiable sets \( S_{k\geq0} \):
	\begin{align*}
	H'_{0} :=&{\ } \{ \mzero \}
	&
	S_{0} :=&{\ } \{ \lnot\mE(\mzero,\msucc(\mzero))
	\}
	\tag*{satisfiable}
	\\
	H'_{i+1} :=&{\ } \{ \msucc(\msucc^{i}(\mzero)) \}
	&
	S_{i+1} :=&{\ }S_i \disjointunion
	 \{
	\lnot\mE(\mzero,\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
	Gilmore's prover does not terminate on this simple and decidable problem.
\end{example}



So far we have observed three main disadvantages in Gilmore's procedure.
\begin{enumerate}
	\item\label{enum:gilmore:generation}
	The generation of instances is unguided.
	With each iteration 
	(depending on the number and the arities of used symbols) exponentially many (mostly useless)
	instances are created.
	%	\begin{align*}
	%		H'_0 &= \{ \, \mc \, \}
	%		&H_0 = H'_0
	%		\\
	%		H'_1 &= \{ \, \mf(\mc), \mg(\mc,\mc) \, \}
	%		&H_1 = H_0 \cup H'_1
	%		\\
	%		H'_2 &=
	%		 \{ \,
	%			\mf(\mf(\mc)), \mf(\mg(\mc,\mc)),
	%			\mg(\mc, \mf(\mc)), \mg(\mc, \mg(\mc,\mc)), \\
	%			&\qquad \mg(\mf(\mc), \mc), \mg(\mf(\mc), \mf(\mc)), \mg(\mf(\mc), \mg(\mc,\mc)), \\
	%			&\qquad \mg(\mg(\mc,\mc),\mc), \mg(\mg(\mc,\mc),\mf(\mc)), \mg(\mg(\mc,\mc), \mg(\mc,\mc))
	%		 \, \}
	%		&H_2 = H_1 \cup H'_2
	%		\\
	%		H'_{i+1} &=
	%			 \{ \, \mf(a), \mg(a,b), \mg(b,a) \mid a\in H'_i, b\in H_i \,
	%			\}
	%			&H_i = \bigcup_{j=1}^{i} H'_j
	%		\end{align*}\\[-1.0em]
	\begin{align*}
	\lvert S_{i} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)
	&
	\lvert H_0 \rvert &\geq 1
	\\
	\lvert S_{i+1} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i+1}\rvert^n \right)
	%	\geq \lvert S_i \rvert^n
	&
	\lvert H_{i+1}\rvert &\geq
	\sum_{n>0}\left(
	\lvert\mcFfn\rvert\cdot\lvert H_i \rvert^n
	\right)
	%	\\
	%	&\geq \sum_n \left( \lvert \mcFPn \rvert\cdot
	%	\left(
	%	\sum_{n>0}\left(\lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)\right)^n{\ }\right) \geq \lvert S_i \rvert^n
	\end{align*}
	\item\label{enum:gilmore:transformation}
	The check for unsatisfiability is far from efficient.
	The transformation from a set of clauses
	to a formula in disjunctive normal form\footnote{
		In contrast the \emph{linear} Tseitin transformation yields an equisatisfiable conjunctive normal form.
	}
	usually introduces an exponential\footnote{
		The existence of a polynomial algorithm
		for the transformation of
		an arbitrary propositional formula into
		an equisatisfiable formula in \emph{disjunctive normal
			form} (where satisfiability is a linear check)
		would show that \( \mathsf{SAT} \) in \( \mcP \)
		%		\( \mathsf{SAT}\in\mcP \)
		and would prove \( \mcP = \mcN\mcP \), which remains unknown.
	}
	blow up in the size of the formula.
	Depending on the number of clauses \( n \) in the set
	and the number of literals \( c_i \) per clause \( \mcC_i \)
	we get the disjunction of
	\( \prod_{1}^{n} c_i \)
	conjunctions of \( n \) literals.
	\begin{align*}
	\bigwedge_{i=1}^{n}
	\left(
	\bigvee_{j_i=1}^{c_i} p_{(i,j_i)}
	\right)
	{\ }&\equiv
	\bigvee_{(j_1,\ldots,j_n)}
	\left(
	\bigwedge_{i=1}^{n} p_{(i,j_i)}
	\right)
	&\text{with }(j_1,\ldots,j_n)\in\prod_{i=1}^{n} \{ 1,\ldots,c_i \}
	\end{align*}
	In total the number of literals in the set of clauses is
	\( n\cdot \bar{c}_{arith} \),
	while the equivalent disjunctive normal form contains
	\( {(\bar{c}_{geom})}^n\cdot n \) literals\footnote{
		%		\( \prod_{1}^{n} c_i = (\bar{c}_{geom})^n \)
		%		with the geometric mean
		Geometric mean \( \bar{c}_{geom} := {\left(\prod_{1}^{n}c_i\right)}^{\frac{1}{n}} \),
		arithmetic mean \( \bar{c}_{arith} := \left(\sum_{1}^{n}c_i\right)\cdot\frac{1}{n} \), and
		%		where
		\( \bar{c}_{geom}
		\leq
		\bar{c}_{arith} \).
	}.
	\begin{gather*}
	%	a∧(b∨c)∧(d∨e∨f)
	%	\\
	%	\equiv
	%	\\
	%	(a∧b∧d)∨(a∧b∧e)∨(a∧b∧f)∨(a∧c∧d)∨(a∧c∧e)∨(a∧c∧f)
	%\\
	 \{ 1 \} \times \{ 1, 2 \} \times \{ 1, 2, 3 \} =
	 \{
	(1,1,1),(1,1,2),(1,1,3),
	(1,2,1),(1,2,2),(1,2,3)
	\}
	\end{gather*}
	Since we have to check for unsatisfiability after each iteration and
	considering the exponential growth of the number of instances 
	we have to handle a double exponential growth in the size of the disjunctive normal form.

	\item\label{enum:gilmore:termination}
	The procedure will not terminate for satisfiable sets
	when at least one non-constant predicate symbol is used in the set of clauses and
	one non-constant function symbol is available, e.g.~for
	\( S = \{ \, \mP(\mf(x)) \, \} \)
	we get
	\begin{align*}
	H_0 &= \{ \, \mc \, \} & S_0 &= \{ \, \mP(\mf(\mc)) \, \}
	\\
	H_{i+1} &= \bigcup_{k=0}^{i+1} \{ \, \mf^{k}(\mc)) \, \}
	&
	S_{i+1} &= \{ \, \mP(\mf(t)) \mid t\in H_{i+1} \, \}
	\\
	\mf^{i+1}(\mc) &\in H_{i+1}\setminus H_i
	&
	\mP(\mf(\mf^{i+1}(\mc))) &\in S_{i+1} \setminus S_i
	\end{align*}
\end{enumerate}

Issue~\ref{enum:gilmore:transformation} was already implicitly
addressed in 1960~\cite{Davis:1960:CPQ:321033.321034}
(which also incorporated the basic idea of resolution on ground instances of terms)
and refined in 1962~\cite{Davis:1962:MPT:368273.368557}
by Davis, Putnam, Longeman, and Loveland,
which was the starting point for the development of efficient propositionally satisfiability checkers, i.e.~efficient modern SAT solvers.


\section{ATP without Equality}\label{sec:proving:without:equaltiy}

In this section we will incorporate the equality symbol \( \mEQ \) into our formulae,
but we will treat it not differently from an arbitrary binary predicate symbol with infix notation.
% 
Without further notice we will always assume 
that different clauses do not share variable symbols,
as we have already justified in Section \vref{sec:clausal:normal:form}.
Further we assume that any set of clauses is variant free, 
i.e.~does not contain multiple variants of a clause.

\subsection{Resolution}\label{sec:resolution}

\begin{definition}[Resolution calculus]\label{def:resolution}
	Let \( A, B \) be atoms and 
	\( \mcC, \mcD \) be clauses.
	\begin{gather*}
	\infer
	[\text{Resolution}]
	{(\mcC\lor\mcD)\sigma}
	{A\lor\mcC&\lnot B\lor\mcD}
	\qquad\qquad
	\infer
	[\text{Factoring}]
	{(A'\lor\mcC')\sigma}
	{A'\lor B'\lor\mcC'}
	\end{gather*}
	\begin{center}
		where
		\( \sigma=\mgu(A,B) \)
		%		, \( \sigma \) is proper
	\end{center}
\end{definition}

\begin{example}Modus tollens is a special case of resolution (\( F\limp G\equiv \lnot F\lor G \)).
	\begin{gather*}
	\infer[\text{modus}\atop\text{tollens}]{\lnot F}{F\limp G & \lnot G}
	\qquad
	\infer[]{\lnot F}{\lnot F\lor G & \lnot G}
	\end{gather*}
\end{example}

%\begin{example}
%	We conclude unsatisfiability of
%	$ \{ \,
%	{ \lnot\mE(x, \msucc(x)))}, \,
%	{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
%	 \, \}$
%	because we can infer the empty clause in one resolution step.
%	\begin{gather*}
%	\infer[ \{ x\mapsto\msucc^k(y)\}]{
%		\square
%	}{
%		{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))} &
%		{ \lnot\mE(x, \msucc(x)))} &
%	}
%	\end{gather*}
%\end{example}

\begin{example}\label{ex:xsx:skyssky}
	We easily infer the empty clause and
	conclude unsatisfiability of the set of clauses
	\( S = \{ \,
	{ \msucc(x)\mNE x}, \,
	{ \msucc(\msucc^k(y))\mEQ\msucc^k(y) }
	 \, \} \).
	\begin{gather*}
	\infer[ \{ x\mapsto\msucc^k(y) \}]
	{
		\square
	}
	{
		\msucc(x)\mNE x & \msucc(\msucc^k(y))\mEQ\msucc^k(y)
	}
	\end{gather*}
\end{example}

\begin{example}\label{ex:sat:msxx:mymzyz}
	We easily generate an infinite sequence of resolution steps from the satisfiable set of clauses
	\(
		S =
		 \{ \,
		\msucc(x)\mNE x, \, \msucc(y)\mNE\msucc(z) \lor y\mEQ z
		 \, \}
	 \).

	\begin{gather*}
%	\infer
%	[ \{ x'\mapsto\msucc(x), y'\mapsto x\}]
%	{
%		\msucc^{2}(x) \mNE\msucc^{1}(x)
%	}{
%		\msucc(x)\mNE x & \msucc(x')\mNE\msucc(y')\lor x'\mEQ y'
%		&
%	}
%	\tag{\( i = 0 \)}
%	\\
	\infer
	[ \{ x'\mapsto\msucc^{i+1}(x), y'\mapsto\msucc^{i}(x)\}]
	{
		\msucc^{i+2}(x) \mNE\msucc^{i+1}(x)
	}{
		\msucc^{i+1}(x)\mNE \msucc^i(x) & \msucc(x')\mNE\msucc(y')\lor x'\mEQ y'
		&
	}
	\tag{\( i\geq 0 \)}
	\end{gather*}
\end{example}

We may notice some disadvantages in resolution.

\begin{enumerate}
	\item\label{enum:resolution:clauses:longer}
	If clauses contain more than two literals the resolution inference rule
	yields clauses with more literals than the sources.

	\item\label{enum:resolution:clauses:multiple}
	For two clauses \( \mcC \) with \( c \) literals
	and \( \mcD \) with \( d \) literals
	we have to check all pairings
	of positive literals in \( \mcC \)
	with negative literals in \( \mcD \)
	and all pairings of negative literals in \( \mcC \)
	with positive literals in \( \mcD \) for clashing,
	i.e.~in the worst case we have \( c\times d \) pairs to check,
	which makes disadvantage \ref{enum:resolution:clauses:longer} even worse
	(see Example~\ref{ex:resolution:9a4}).
	This workload can be reduced with ordered resolution as presented
	in Section~\ref{sec:ordered:resolution}.

	\item In the presence of equality, resolution is still sound, but not complete.
	E.g.~we expect the set of clauses
	\( \{ \mf(\ma) \mEQ \mc, \mP(\mc), \lnot\mP(\mf(\ma)) \} \)
	or even simpler the set with one clause
	\( \{ \ma\mNE\ma \} \)
	to be unsatisfiable, but neither resolution nor factoring
	are applicable. This can be addressed with equality axioms or equality inference rules
	as presented in Section~\ref{sec:proving:with:equality}.
\end{enumerate}

\begin{example}\label{ex:resolution:9a4}
	One of { \coloremph{}{}nine} derivable clauses à 4 literals from two clauses à 3 literals.
	\begin{gather*}
	\infer[]{\mP(\ma,z)\lor\mP(z,\mb)\lor\lnot\mP(\ma,z')\lor\lnot\mP(z',b)}
	{{\colN\mP(x,y)}\lor\mP(\ma,z)\lor\mP(z,\mb) & {\colN\lnot\mP(x',y')}\lor\lnot\mP(\ma,z')\lor\lnot\mP(z',\mb)}
	\end{gather*}
\end{example}

\subsection{Ordered resolution}\label{sec:ordered:resolution}

With an order on literal and clause instances the number of possible derivations can be noticeably reduced.

\begin{definition}[Ordered Resolution]\label{def:ordered:resolution}
	Let \( A, B \) be atoms and \( \mcC,\mcD \) be clauses.
	\begin{gather*}
	\infer
	[\text{Ordered}\atop\text{Resolution	}]
	{(\mcC\lor\mcD)\sigma}
	{A\lor\mcC&\lnot B\lor\mcD}
	\qquad\qquad
	\infer
	[\text{Ordered}\atop\text{Factoring}]
	{(A\lor\mcC)\sigma}
	{A\lor B\lor\mcC}
	\end{gather*}
	\begin{center}
		where \( \sigma=\mgu(A,B) \),
		\( A\sigma \) strictly maximal in \( (A\lor\mcC)\sigma \),
		\( \lnot B\sigma \) maximal in \( (\lnot B\lor\mcD)\sigma \).
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference.
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier \( \sigma \) is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses the maximal size of clauses, i.e.~the number of literals in a clause,
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of \( S \) does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier \( \sigma \) is used to derive two new clauses.}
\end{definition}

\begin{example}\label{ex:resolution:1a4}
	One clause à 4 literals is derivable from the two clauses
	in Example~\vref{ex:resolution:9a4} with
	\( \mP(x,y)\succ\mP(\ma,z)\succ\mP(z,\mb) \)
	for \( \{ x\mapsto\ma, y\mapsto\ma,z\mapsto\mb \} \).
	\begin{gather*}
	\infer[]{\mP(\ma,z)\lor\mP(z,\mb)\lor\lnot\mP(\ma,z')\lor\lnot\mP(z',b)}
	{{\colN\mP(x,y)}\lor\mP(\ma,z)\lor\mP(z,\mb) & {\colN\lnot\mP(x',y')}\lor\lnot\mP(\ma,z')\lor\lnot\mP(z',\mb)}
	\end{gather*}

\end{example}

\begin{example}
	With an ordering such that \( \msucc(y)\mEQ\msucc(z)) \succ y\mEQ z \) on atoms and \( {\lnot A} \succ A \)
	the satisfiable set \( S \) in Example \vref{ex:sat:msxx:mymzyz} saturates with ordered resolution,
	because the strictly maximal literals
	\( \msucc(x)\mNE x \) and
	\( \msucc(y)\mNE\msucc(z) \)
	do not clash and the ordered resolution rule is not applicable.
\end{example}


\begin{procedure}[Ordered Resolution] We start with a set of clauses. We either apply ordered resolution or ordered factoring to derive a clause. If this clause is not a variant of a clause already in the set, we add it to the set. We continue until we derive the empty clause or we can only derive variants of clauses in the set.
\end{procedure}

\begin{lemma}
	The ordered resolution procedure is a complete refutation process for a set of clauses, 
	i.e.~this set is unsatisfiable if and only if the empty clause can be derived.
\end{lemma}

% \begin{proof}
% 	If no new resolvant can be derived and the empty clause is not in the set of clauses we have a model.

% 	The resolvant \( (\mcC\lor\mcD)\sigma \) is smaller than \( (A\lor\mcC)\sigma \) and \( (\lnot B\lor\mcD)\sigma \)

% 	\( \lnot B \succ_\mL A \) because \( A\sigma=B\sigma=C \) and \( \lnot X\succ_\mL X \).
% \end{proof}

\subsection{Inst-Gen}\label{sec:inst:gen}

Gilmore's prover systematically constructs all ground instances eventually---starting with the smallest. So it can take many (unnecessary) steps to discover a simple contradiction. 
\InstGen searches actively for contradicting instances of literals to shorten this discovery process.

\begin{definition}[\InstGen{}~\cite{KK2008}] Let \( A, B \) be atoms and \( \mcC,\mcD \) be clauses.
	\begin{gather*}
	\infer
	[{\InstGen}]
	{(A\lor\mathcal C)\sigma\qquad (\lnot B\lor\mathcal D)\sigma}
	{A\lor\mathcal C\quad&\quad \lnot B\lor\mathcal D}
	\end{gather*}
	\begin{center}where \( \sigma=\mgu(A,B) \)
%		, \( \sigma \) is proper
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference.
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier \( \sigma \) is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses the maximal size of clauses, i.e.~the number of literals in a clause,
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of \( S \) does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier \( \sigma \) is used to derive two new clauses.}
\end{definition}

\begin{example}
	With \InstGen{} we can immediately derive a helpful clause from set
\(
	S =
 \{ \,
{ \lnot\mE(x, \msucc(x)) }, \,
{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
 \, \}
 \)
 introduced in Example~\ref{ex:unsat:nexsx}.
\begin{gather*}
\infer[ \{ x\mapsto\msucc^k(y)\}]{
	{ \lnot\mE(\msucc^k(y), \msucc(\msucc^k(y)))} \qquad
	{\colG \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
}{
	{ \lnot\mE(x, \msucc(x)) } &
	{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
}
\end{gather*}
and we conclude unsatisfiability because of propositional unsatisfiability of
\begin{gather*}
 \{ \,
	\mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot))), \lnot\mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot)))
 \, \}
\end{gather*}

\end{example}

\begin{lemma}
	The set of clauses
	\(
		S_0 = S \cup
	 \{
		 A\lor\mathcal C, \lnot B\lor\mathcal D
	\}
	 \)
	is satisfiable if and only if
	the derived set of clauses
	\( S_1 = S_0 \cup \{ (A\lor\mathcal C)\sigma, (\lnot B\lor\mathcal D)\sigma \} \)
	with \( \sigma = \mgu(A,B) \) is satisfiable.
\end{lemma}

\begin{proof}
	If \( S_1 \) is satisfiable then there exists an interpretation that satisfies all clauses in \( S_1 \).
	The same interpretation models all clauses in \( S_0 \) because \( S_0\subseteq S_1 \).
	In reverse \( S_1 \) cannot be satisfiable if \( S_0 \) is not.


\end{proof}

\begin{procedure}[Inst-Gen-Loop]\label{proc:inst:gen:loop}
	As in Gilmore's prover (Procedure~\ref{proc:gilmore's:prover})
	we translate the negation of our formula \( F \) into an equisatisfiable set of clauses
	\( S = S_0 \). Then we introduce a distinct constant symbol
	\( \consbot\not\in\mcF(S_0) \), even when there are constant symbols in the signature.
	We start our first iteration with \( k=0 \).

	\begin{enumerate}
		\item\label{step:igl:skbot}
		We construct a set \( S_{k}\subsbot \) of ground instances from \( S_k \)
		with proper instantiator \( \subsbot = \{ x\mapsto \consbot \mid x\in\var(S_k) \} \)
		that substitutes all occurring variables with constant symbol \( \consbot \).
%
		\item\label{step:igl:sksat} 
		We check the decidable propositional satisfiability of
		\( S_k\subsbot \) with a \SAT{} or \SMT{}-solver
		(see Section \vref{sec:encodings} for details).
		If \( S_k \, \subsbot \) is unsatisfiable
		we exit the procedure 
		and report
		{ \coloremph{}{}unsatisfiability} of \( S \), i.e~the original formula \( F \) is valid.

		\item\label{step:igl:model} The set \( S_k \, \subsbot \) is satisfiable, hence we can retrieve a model \( \mcM_k \models S_k\subsbot \).
		We select one literal \( L_i = \sel(\mcC_i) \) per clause \( \mcC_i \in S_k \)
		such that each ground selected literal holds in model
		\( \mcM_k\models L_i\subsbot \) for all \( i \leq | S_k | \).

		\item\label{step:igl:clashes} We search for pairs of selected literals
		\( (A, \lnot B) = (L_i, L_j) \)
		such that the most general unifier \( \tau = \mgu(A,B) \) exists.

		\item We start with \( S_{k+1} = S_k \). For each pair of clashing literals
		\( (L_i, L_j) \)
		we apply \InstGen{} to the originating clauses
		\( \{ \, \mcC_{i}, \mcC_{j} \, \} = \{ \, L_i\lor\mcC, L_j\lor\mcD \, \} \subseteq S_k \)
%		where \( \sel(\mcC_{i_1}) = L_i \) and \( \sel(\mcC_{i_2})=\lnot L_j \)
		and add all new (not necessarily ground) instances to \( S_{k+1} \).
		A clause is new to a set if no variant of the clause is already is in this set.

		If no new clauses were added, i.e.~\( S_{k+1} = S_k \) after all pairs were processed we exit the procedure and report { \coloremph{}satisfiability} of \( S \), i.e.~the original formula \( F \) is not valid.

		\item We increase \( k \) by \( 1 \) and continue with step~\ref{step:igl:skbot}.

	\end{enumerate}
\end{procedure}

\begin{example} The selected literals of the first and the second clause change between iterations.
%	1. p(a) | q(a)
%	2. p(a) | ~q(X)
%	3. ~p(X)
\begin{align*}
S_0 &= \{ \,
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x)
 \, \}
\\
S_0\subsbot &= \{ \,
	{\colHi\mP(\ma)}\lor\mQ(\ma),
	{\colHi\mP(\ma)}\lor\lnot\mQ(\consbot),
	{\colHi\lnot\mP(\consbot)}
 \, \}
\tag{satisfiable}
\\
&\qquad\infer[
	\sigma_1
	]{
		{\colG \mP(\ma)\lor\mQ(\ma)}\quad\lnot\mP(\ma)
	}{
		\mP(\ma)\lor\mQ(\ma) & \lnot\mP(x)
	}
	\qquad\infer[
	\sigma_1
	]{
		{\colG \mP(\ma)\lor\lnot\mQ(y)}\quad\lnot\mP(\ma)
	}{
		\mP(\ma)\lor \lnot\mQ(y) & \lnot\mP(x)
	}
	\tag*{\( \sigma_1 = \{ x\mapsto\ma \} \)}
\\
S_1 &= \{ \,
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x),
	\lnot\mP(\ma)
 \, \}
\\
S_1\subsbot &= \{ \,
	{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
	{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
	{\colHi\lnot\mP(\consbot)},
	{\colHi\lnot\mP(\ma)}
 \, \}
\tag{satisfiable}
\\
&\qquad\infer[
\sigma_2
]{
	{\colG \mP(\ma)\lor\mQ(\ma)}\quad\mP(\ma)\lor\lnot\mQ(\ma)
}{
	\mP(\ma)\lor\mQ(\ma) & \mP(\ma)\lor\lnot\mQ(y)
}
\tag*{\( \sigma_2 = \{ y\mapsto\ma \} \)}
\\
S_2 &= \{ \,
\mP(\ma)\lor\mQ(\ma),
\mP(\ma)\lor\lnot\mQ(y),
\lnot\mP(x),
\lnot\mP(\ma),
\mP(\ma)\lor\lnot\mQ(\ma)
 \, \}
\\
S_2\subsbot &= \{ \,
{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
{\colHi\lnot\mP(\consbot)},
{\colHi\lnot\mP(\ma)},
{\colLo\mP(\ma)}\lor{\colLo\lnot\mQ(\ma)}
 \, \}
\tag{unsatisfiable}
\end{align*}
\end{example}

\begin{lemma}
	The unifier \( \tau = \mgu(A,B) \) in Procedure~\ref{proc:inst:gen:loop},
	step~\ref{step:igl:clashes} is a proper instantiator,
	i.e.~it is not a variable renaming.
\end{lemma}
\begin{proof}
	Assume \( \tau \) in Procedure~\ref{proc:inst:gen:loop}
	is a variable renaming, then we have
	\( A\tau\subsbot = A\subsbot \),
	\( B\tau\subsbot = B\subsbot \),
	and by definition of the most general unifier \( A\tau = B\tau \).
	Hence \( A\subsbot = B\subsbot \) which contradicts that
	\( M_k\models A\subsbot, \lnot B\subsbot \)
	by definition of step~\ref{step:igl:model}.
	Hence the assumption is false and \( \tau \) must be a proper instantiator.
\end{proof}





\begin{example}\label{ex:unsat2}
Let \( S_0 \) be the set of unsatisfiable clauses
from Example~\ref{ex:unsat:nexsx}.
Then the initial set of ground instances
\( S_0\subsbot =\
 \{ \,
{ \lnot\mE(\consbot, \msucc(\consbot)) },
{ \mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot)))}
 \, \} \)
is satisfiable with domain
\( A = \{ \consbot, \msucc(\consbot), \msucc^k(\consbot), \msucc(\msucc^k(\consbot)) \} \)
and predicate interpretation
\( \mE^\mcI = \{ (\msucc^k(\consbot), \msucc(\msucc^k(\consbot)) \} \subseteq A^2 \).
%
 With just two unit clauses we easily find the only pair of clashing literals and compute the unifier
 \( \tau = \{ x\mapsto \msucc(s^k(y)) \} \).
 By application of \InstGen{} we construct our next set of clauses
\( S_1 =\
S_0 \disjointunion
 \{ \,
% { \lnot\mE(x, \ms(x)))},\
% { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\msucc^k(y), \msucc(\msucc^k(y)))}
 \, \}
 \)
 and get an unsatisfiable set of ground instances \( S_1\subsbot \).
\end{example}


\begin{lemma}
	Inst-Gen-Loop is a complete refutation procedure.
\end{lemma}

\begin{example}
	Obviously we cannot derive any new clause from set
	\( S = \{ \, \mE(\mzero,\msucc(x)) \, \} \)
	(see Example~\ref{ex:sat:exy}) with \InstGen.
	We then conclude satisfiability
	of \InstGen-saturated set \( S \)
	because of refutation completeness of \InstGen 
	and satisfiability of \( S\bot \).
\end{example}


\section{ATP with Equality}\label{sec:proving:with:equality}

So far we have treated the equality symbol like any other binary predicate symbol,
which can yield models where \( \ma\mNE\ma \) holds.
Understandably, we are only interested in normal models or
at least in models that implies the existence of a normal model.
We have already seen that a normal Herbrand model might not exist,
but we can ensure that we find only desired models.

\subsection{Adding equality axioms}\label{sec:equality:axioms}

\begin{theorem}\cite{Harrison:2009:HPL:1540610}
	Any set of clauses (a formula) has a \emph{normal} model
	if and only if it has a model that satisfies the
	{ \coloremph{}equality axioms}, 
	i.e.~reflexivity \axiom{R}, 
	symmetry \axiom{S}, 
	transitivity \axiom{T},
	and congruence \axiom{C} for all function symbols \( \mf\in\mcFf \)
	and all predicate symbols \( \mP\in\mcFP \).
\end{theorem}

%\begin{remark}
%	The only decidable fragment of first order logic where we can state the equality axioms is the Schönfinkel-Bernays-Ramsey class.
%\end{remark}

\begin{example}[Ordered resolution with equality axioms]\label{ex:nat:ordres}
	We combine the small set 
	\( S = \{ \msucc(x)\mNE 0,{\ }\msucc(x)\mNE\msucc(y)\lor x\mEQ y \} \) 
	with the equality axioms to set \( S' \) and mark maximal literals.
	\begin{align*}
	{\colN x \mEQ x},\
	x \mEQ y \lor \underline{\colN y \mNE x},\
	x \mEQ z \lor {\colN x \mNE y} \lor {\colN y\mNE z}
\tag*{\(\axiom{R}_\mEQ,\,\axiom{R}_\mEQ,\,\axiom{T}_\mEQ \) }
\\
	{\colN \msucc(x) \mEQ \msucc(y)} \lor x\mNE y
	\tag*{\(\axiom{C}_\msucc \)}
\\
	{\colN \msucc(x)\mNE 0},\
	{\colN \msucc(x) \mNE \msucc(y)} \lor x \mEQ y
\tag*{\( S = \{ \axiom{0}_\msucc, \axiom{I}_\msucc \} \)}
	\end{align*}
	With ordered resolution we cannot infer new clauses from clauses in \( S \).
	But we can apply rules of ordered resolution to pairs of equality axioms and clauses,
	most derivations are ignorable and the process will saturate.
	\begin{align*}
\infer[ \{ x'\mapsto x, y'\mapsto x\}]
{x \mEQ x}
{{\colN x \mEQ x} & x' \mEQ y' \lor {\colN y' \mNE x'}}
\tag*{\( \axiom{R}_\mEQ,\axiom{S}_\mEQ\proves \axiom{R}_\mEQ\)}
\\
\infer[ \{ x'\mapsto x,y'\mapsto x \}]
{x\mEQ z'\lor x\mNE z' }
{{\colN x \mEQ x} & x' \mEQ z' \lor {\colN x' \mNE y'} \lor {y'\mNE z'}}
\tag*{\( \axiom{R}_\mEQ,\axiom{T}_\mEQ\proves\true \)}
\\
\infer[ \{ y'\mapsto x, z'\mapsto x \}]
{x'\mEQ x\lor x'\mNE x }
{{\colN x \mEQ x} & x' \mEQ z' \lor {x' \mNE y'} \lor {\colN y'\mNE z'}}
\tag*{\( \axiom{R}_\mEQ, \axiom{T}_\mEQ\proves\true \)}
\\
\infer[ \{ y\mapsto \msucc(x'), x\mapsto\msucc(y')\}]
{\msucc(y')\mEQ\msucc(x')\lor x'\mNE y'}
{x \mEQ y \lor {\colN y \mNE x} & {\colN \msucc(x') \mEQ \msucc(y')} \lor x'\mNE y'}
\tag*{\( \axiom{S}_\mEQ,\axiom{C}_\msucc\proves \axiom{C}_\msucc \)}
\\
\infer[ \{ x\mapsto\msucc(x'),y\mapsto\msucc(y')\}]
{\msucc(x')\mEQ z\lor \msucc(y')\mNE z \lor x'\mNE y'}
{x \mEQ z \lor {\colN x \mNE y} \lor {y\mNE z} & {\colN \msucc(x') \mEQ \msucc(y')} \lor x'\mNE y'}
\tag*{\( \axiom{T}_\mEQ,\axiom{C}_\msucc\proves ? \)}
\\
\infer[ \{ y\mapsto\msucc(x'),z\mapsto\msucc(y')\}]
{x\mEQ\msucc(y')\lor x\mNE\msucc(x')\lor x'\mNE y'}
{x \mEQ z \lor {x \mNE y} \lor {\colN y\mNE z} & {\colN \msucc(x') \mEQ \msucc(y')} \lor x'\mNE y'}
\tag*{\( \axiom{T}_\mEQ,\axiom{C}_\msucc\proves ? \)}
\\
\infer[ \{ x'\mapsto x, y'\mapsto y\}]
{x\mNE y\lor x\mEQ y}
{{\colN \msucc(x) \mEQ \msucc(y)} \lor x\mNE y & x' \mEQ y' \lor {\colN \msucc(x') \mNE \msucc(y')}}
\tag*{\( \axiom{C}_\msucc,\axiom{I}_\msucc\proves\true \)}
\\
	\end{align*}
\end{example}

\begin{example} 
	We prove that \( S' \cup \{ \msucc(\msucc(x))\mEQ\msucc(0) \} \) is unsatisfiable.
	\begin{gather*}
	\infer[ \{ \, x'\mapsto x \, \}]
	{\square}
	{s(x')\mNE 0 &
		\infer[
		 \{ \, x'\mapsto \msucc(x), y'\mapsto 0 \, \}
		]{
			\msucc(x)\mEQ 0
		}{
			x' \mEQ y' \lor {\colN \msucc(x') \mNE \msucc(y')}
			& {\msucc(\msucc(x))\mEQ\msucc(0)}
		}
	}
	\end{gather*}
\end{example}

\begin{example}[\InstGen{} with equality axioms]\label{ex:nat:instgen}
	Let \( S' = \{
		\axiom{R}_\mEQ, \axiom{S}_\mEQ, \axiom{T}_\mEQ,
		\axiom{C}_\msucc, \axiom{I}_\msucc, \axiom{0}_\msucc
		\}\) 
		be the satisfiable set from Example \vref{ex:nat:ordres}.
	The default ground substitution of \InstGen{} substitutes \emph{every} 
	variable in \emph{every} clause and literal with one fixed constant function symbol \( \consbot \). 
	We notice that the selection function defined 
	by any suitable model \(
		\mcM \entails \{
			\axiom{R}_\mEQ, \axiom{S}_\mEQ, \axiom{T}_\mEQ,
			\axiom{C}_\msucc, \axiom{I}_\msucc, \axiom{0}_\msucc
			\}\consbot
	\) for the ground instances of the axioms is unique and unfavorable.
	\begin{align*}
	{ \colHi \consbot \mEQ \consbot },\,
	{ \consbot \mEQ \consbot} \lor { \colLo \consbot \mNE \consbot }
	,\,
	{ \consbot \mEQ \consbot}
	\lor {\colLo \consbot \mNE \consbot}
	\lor {\colLo \consbot\mNE \consbot}
	\tag*{\( \{\axiom{R}_\mEQ, \axiom{S}_\mEQ, \axiom{T}_\mEQ\}\consbot \) }\\
	{\colHi \msucc(\consbot) \mEQ \msucc(\consbot)} \lor {\colLo \consbot \mNE \consbot}
	,\,
	{ \consbot \mEQ \consbot} \lor {\colLo \msucc(\consbot) \mNE \msucc(\consbot)}
	,\,
	{\colHi \msucc(\consbot) \mNE 0}
	\tag*{ \( \{\axiom{C}_\msucc, \axiom{I}_\msucc, \axiom{0}_\msucc \}\consbot \)}
	\end{align*}
	The selected literals of 
	\(\axiom{R}_\mEQ\), \(\axiom{S}_\mEQ\), \(\axiom{T}_\mEQ\), and \(\axiom{I}_\mEQ\) 
	(with variables) will clash with
	\(\axiom{0}_\msucc\), e.g.

	\begin{align*}
		\infer[\{ x\mapsto \msucc(x'), y\mapsto 0 \}]{
			\msucc(x') \mEQ 0 \lor 0 \mNE \msucc(x')
		}{
			\msucc(x')\mNE 0 & x \mEQ y  \lor y \mNE x
		}
		\tag*{ \( \axiom{0}_\msucc, \axiom{S}_\mEQ \proves \true \)}
		% \\
		% \infer[
		% 	\{ x\mapsto\msucc(x'), y\mapsto 0 \} 
		% ]{
		% 	\msucc(x')\mEQ 0 \lor \msucc(\msucc(x') \mNE \msucc(0)	
		% }{
		% 	\msucc(x')\mNE 0 & x \mEQ y  \lor \msucc(x) \mNE \msucc(y)
		% }
		% \tag*{\( 
		% 	\axiom{0}_\msucc, \axiom{I}_\msucc \proves 
		% 	\lnot\axiom{0}_\msucc \lor \axiom{0}_\msucc(\msucc(x)) 
		% \)}
		\end{align*}

This would not hurt the saturation process.
But additionally we get an infinite sequence of new instances starting with \( \axiom{I}_\msucc \) and \( \axiom{0}_\msucc \).
	\begin{gather*}
	\infer[ \sigma_0 ]{
		\boxed{\msucc (\msucc (x)) \mNE \msucc (x)} \lor\colLo \msucc (x)\mEQ x
	}{
		\axiom{I}'_\msucc & \colHi\msucc (x) \mNE x
	}
	\\[0.5em]
	\infer[ \sigma_{i+1}]{ \cdots }{\axiom{I}'_\msucc&
	\infer[ \sigma_i]{
		\msucc (\msucc^{i+2} (x)) \mNE \msucc (\msucc^{i+1} (x)) \lor \msucc^{i+2} (x)\mEQ\msucc^{i+1} (x)
	}{
		\axiom{I}'_\msucc & \boxed{\msucc^{i+2} (x) \mNE \msucc^{i+1} (x)}\colG \lor \msucc^{i+1} (x)\mEQ\msucc^{i}(x)
	}
	}
	\end{gather*}
	where \( \axiom{I}'_\msucc = \msucc (x') \mNE \msucc (y') \lor x'\mEQ y' \) and 
	\( \sigma_i = \{ x'\mapsto \msucc^{i+2} (x), y'\mapsto \msucc^{i+1} (x)\} \) for all \( i\geq 0 \).
	Hence every satisfiable superset of set \( S' \) will not saturate.
\end{example}
% 
To overcome this we may substitute different variables in clauses 
with distinct fresh constants where clauses do no share these introduced constants.
\begin{example} Let \( S' \) 
	be the satisfiable set from Example \vref{ex:nat:ordres}.
	\begin{align*}
{\colHi \mc_{x_0} \mEQ \mc_{x_0}}
,\,
{\mc_{x_1} \mEQ \mc_{y_1}} \lor {\colHi \mc_{y_1} \mNE \mc_{x_1}}
,\,
{\mc_{x_2} \mEQ \mc_{z_2}} \lor {\colHi \mc_{x_2} \mNE \mc_{y_2}} \lor {\colN \mc_{y_2}\mNE \mc_{z_2}}
\tag*{\( \{\axiom{R}_\mEQ,\axiom{S}_\mEQ,\axiom{T}_\mEQ\}{\mc_*} \)}
\\
{ \msucc(\mc_{x_3}) \mEQ \msucc(\mc_{y_3})} \lor {\colHi \mc_{x_3}\mNE \mc_{y_3}}
,\,
{\colHi \msucc(\mc_{x_4})\mNE 0}
,\,
\underline{\colHi \msucc(\mc_{x_5}) \mNE \msucc(\mc_{y_5})} \lor \mc_{x_5 }\mEQ \mc_{y_5}
\tag*{\(\{\axiom{C}_\msucc,\axiom{0}_\msucc,\axiom{I}_\msucc\}{\mc_*} \)}
% \\
% \msucc(\msucc(\mc_{x_6})) \mEQ\msucc(\mc_{y_6}) \lor \mc_{x_6} \mNE \mc_{y_6}
\end{align*}
After literal selection, \( \axiom{R}_\msucc \) clashes with selected negative literals
of \( \axiom{S}_\mEQ \), \( \axiom{T}_\mEQ \), and \( \axiom{C}_\msucc \).
\begin{gather*}
\infer[\sigma_1]{
	x_0 \mEQ x_0 \lor x_0 \mNE x_0
}{
	x_0 \mEQ x_0 & x_1 \mEQ y_1 \lor y_1 \mNE x_1 
}
\qquad
\infer[\sigma_2]{
	x_0 \mEQ z_2 \lor x_0 \mNE x_0 \lor x_0 \mNE z_2
}{
	x_0 \mEQ x_0 & x_2 \mEQ z_2 \lor x_2 \mNE y_2 \lor y_2 \mNE z_2
}
\\
\infer[\sigma_3]{
	\msucc(x_0) \mNE \msucc(x_0) \lor x_0 \mEQ x_0
}{
	x_0 \mEQ x_0 & \msucc(x_3) \mNE \msucc(y_3) \lor x_3 \mNE y_3
}
\end{gather*}
with \( \sigma_1 = \{ x_1\mapsto x_0, y_1 \mapsto x_0 \}\),
\( \sigma_2 = \{ x_2\mapsto x_0, y_2 \mapsto x_0 \}  \),
\( \sigma_3 = \{ x_3\mapsto x_0, y_3 \mapsto x_0 \} \).
\end{example}

The derived instances are weakened variants (see Lemma \vref{lem:weakend:variants}) of clauses already in \( S ' \) and can be ignored. Hence the process saturates for \( S' \). This approach is sound, but at this point it is unclear if it is complete.

%	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity,
%	function congruence for every function symbol \( f\in\mcFf \),
%	and predicate congruence for every predicate symbol \( P\in\mcFP \).
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

%\begin{example}
%	Consider the set of clauses \( \{ \mc \mEQ \mb \} \).
%	Here we don't find a Herbrand model where the equality symbol is interpreted as equality on its domain.
%\end{example}

%\begin{align*}
%	 x \mEQ x & \tag*{reflexivity} \\
%	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
%	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
%	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
%	\tag*{f-congruence}
%	\\
%	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
%	\tag*{P-congruence}
%	\\[0.7em]
%	x_1\mNE y_1\lor x_2\mNE y_2
%	\lor x_1\mNE x_2
%	\lor y_1\mEQ y_2
%	\tag*{\( \mEQ \)-congruence}
%\end{align*}

%\begin{align*}
%	x \mEQ x & \tag*{reflexivity}
%	\\
%	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
%	\\
%	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity}
%	\\
%	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
%	\tag*{f-congruence}
%	\\
%	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
%	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
%	\tag*{P-congruence}
%	\\[0.7em]
%	(x_1\mEQ y_1
%	\land x_2\mEQ y_2
%	\land x_1\mEQ x_2)
%	\limp y_1\mEQ y_2
%	& \quad P\in\mcFPn[2]
%		\tag*{\( \mEQ \)-congruence}
%\end{align*}

\subsection{Equality inference rules}

Instead of adding equality axioms for an equality predicate symbol,
we add specific equality inference rules for completeness.


\subsubsection{Superposition}\label{sec:superposition}

As in ordered resolution the unsatisfiability of a set of clauses is shown
if and only if the empty clause can be derived.


\input{appendix/superposition}

\begin{example} With the superposition calculus no derivation rule is applicable
	to clauses of the set \( S = \{ \msucc(x)\mNE 0, \msucc{x}\mNE\msucc{y} \lor x\mEQ y \} \)
	because the maximal literals are both negations.
	\begin{align*}
	{\colN \msucc(x_1) \mNE 0}\qquad{\colN \msucc(x_2) \mNE \msucc(y_2)} \lor x_2\mEQ y_2
	\end{align*}
	The saturated set does not contain the empty clause, hence we conclude its satisfiability because of completeness of the superposition calculus.
\end{example}

\subsubsection{Inst-Gen-Eq}\label{sec:inst:gen:eq}

In the presence of equality the general approach
for proving unsatisfiability of a set of clauses
is the same as with \InstGen{}.
We approximate the satisfiability of the set of clauses with a \SAT{}- or \SMT{}-solver.
In case of satisfiability we select one literal per clause based on the propositional model.
From occuring conflicts we construct new instances.

\input{appendix/unitsuperposition}

%\subsection{Examples}
%
%\begin{example}
%	\begin{align*}
%	\ack(\mzero,y) &\mEQ \msucc(y) \\
%	\ack(\msucc(x),\mzero) &\mEQ \ack(x, \msucc(\mzero)) \\
%	\ack(\msucc(x),\msucc(y)) &\mEQ \ack(x, \ack(\msucc(x),y)) \\
%	\\
%%	x &\mNE \msucc(x)\\
%	x &\mNE y \lor \msucc(x) \mEQ \msucc(y)\\
%	\mzero &\mNE \msucc(x)\\
%	\end{align*}
%\end{example}

A naive approach would just consider pairs of selected literals to generate new instances. But this would yield an incomplete procedure 
as demonstrated in the next example, even with the additional rules.

\newcommand{\myset}[1]{\{ \, #1 \, \}}
\newcommand{\mysub}[1]{\{ #1 \}}

\begin{example}\label{ex:naive:inst:gen:eq}
	We consider the unsatisfiable set \( S \).
	\begin{align*}
		S &= \myset{
			\mf(\mh(x)) \mEQ \mc, \mh(y)\mEQ y, \mf(\ma) \mNE \mc
		}
		\\
		S\bot &= \myset{
			\mf(\mh(\consbot)) \mEQ \mc, \mh(\consbot)\mEQ \consbot, \mf(\ma) \mNE \mc
		}\tag{satisfiable}
		\\
		\mcM &= \myset{
			[\mf(\mh(\consbot),c)], [\mh(\consbot),\consbot], [\mf(a)]
		}\tag{term model}
	\end{align*}
	The only applicable rule is paramodulation of the first two selected literals,
	but the instantiator is not proper and just get variants of clauses in the set.
\end{example}

\begin{procedure}[Inst-Gen-Eq-Loop]\label{proc:inst:gen:eq:loop}
	As in Procedure \vref{proc:inst:gen:loop} we translate the 
	negation of our formula \( F \) 
	into an equisatisfiable set of clauses
	\( S = S_0 \) and introduce a distinct constant symbol
	\( \consbot\not\in\mcF(S_0) \).
	We start our first iteration with \( k=0 \).

	\begin{enumerate}
		\item\label{step:igl:eq:skbot}
		We construct a set \( S_{k}\subsbot \) of ground instances from \( S_k \)
		with proper instantiator \( \subsbot = \{ x\mapsto \consbot \mid x\in\var(S_k) \} \)
		that substitutes all occurring variables with constant symbol \( \consbot \).
%
		\item\label{step:igl:eq:sksat} 
		We check the decidable propositional satisfiability of
		\( S_k\subsbot \) with a \SAT{} or \SMT{}-solver
		(see Section \vref{sec:encodings} for details).
		If \( S_k \, \subsbot \) is unsatisfiable
		we exit the procedure 
		and report
		{ \coloremph{}{}unsatisfiability} of \( S \), i.e~the original formula \( F \) is valid.

		\item\label{step:igl:eq:model} The set \( S_k \, \subsbot \) is satisfiable, hence we can retrieve a model \( \mcM_k \models S_k\subsbot \).
		We select one literal \( L_i = \sel(\mcC_i) \) per clause \( \mcC_i \in S_k \)
		such that each ground selected literal holds in model
		\( \mcM_k\models L_i\subsbot \) for all \( i \leq | S_k | \).

		\item\label{step:igl:eq:false} We search for subsets 
		\( \{ L_{i'}, \ldots, L_{n'} \} \) of the selected literals
		such that we can derive a contradiction with unit superposition.

		\item We start with \( S_{k+1} = S_k \). For each set of contradicting literals
		\( \{ L_{i'}, \ldots L_{n'} \} \)
		we generate new instances from \( \mcC_{i'}, \ldots \mcC_{n'} \)
		by applying the same substitutions as were applied 
		to \( L_{i'}, \ldots L_{j'} \) 
%		where \( \sel(\mcC_{i_1}) = L_i \) and \( \sel(\mcC_{i_2})=\lnot L_j \)
		and add all new (not necessarily ground) instances to \( S_{k+1} \).
		A clause is new to a set if no variant of the clause is already is in this set.

		If no new clauses were added, i.e.~\( S_{k+1} = S_k \) after all subsets were processed we exit the procedure and report \coloremph{satisfiability} of \( S \), i.e.~the original formula \( F \) is not valid.

		\item We increase \( k \) by \( 1 \) and continue with step~\ref{step:igl:skbot}.

	\end{enumerate}
\end{procedure}

So now step 4 and 5 are more work than in \InstGen.

\begin{example}
	We continue Example \vref{ex:naive:inst:gen:eq} but follow Procedure \vref{proc:inst:gen:eq:loop}.
	\begin{gather*}
		\infer[\mysub{y\mapsto \ma}]{
			\infer[\{\}]{\emptyclause}{c\mNE c}
			}{
		\infer[\mysub{x\mapsto y}]
		{\mf(y)\mEQ\mc}
		{\mh(y)\mEQ y & \mf(\mh(x))\mEQ \mc}
		& \mf(\ma)\mNE\mc
		}
	\end{gather*}
	Now we follow the path from each branch, i.e.~literal, to the root, i.e.~the empty clause
	and apply the sequence of occuring substitutions to the clauses the literals are originating from.
	\begin{align*}
		 \mh(\ma)\mEQ \ma &=
		 (\mh(y)\mEQ y)\mysub{x\mapsto y}\mysub{y\mapsto \ma}
		 \\
		 \mf(\mh(\ma))\mEQ\mc &=
		 (\mf(\mh(x))\mEQ \mc)\mysub{x\mapsto y}\mysub{y\mapsto \ma}
		 \\
		 \mf(\ma)\mNE \mc &=
		 (\mf(\ma)\mNE \mc)\mysub{y\mapsto \ma}
		 \\
		S_1 &\supseteq \myset{
			\mf(\ma) \mNE \mc,
			\mf(\mh(\ma))\mEQ \mc, \mh(\ma)\mEQ \ma
		}
	\end{align*}

	% \begin{align*}
	% 	S_1 &\supseteq \myset{
	% 		\mf(\ma) \mNE c,
	% 		\mf(\mh(\ma))\mEQ \mc, \mh(\ma)\mEQ \ma
	% 	}
	% 	\\

	% \end{align*}
\end{example}



At a first glance the \InstGenEQ{} procedure is expected to behave similar to the application of the superposition calculus.
But actually it shares a disadvantage with \InstGen{} (see Example~\ref{ex:nat:instgen}) as we can see in the following example.


\begin{example}\label{ex:nat:instgeneq}
	Let \( S = \{ \, \msucc(x_1) \mNE \msucc (y_1) \lor x_1 \mEQ y_1, \, \msucc(x_2)\mNE x_2 \, \} \).
	We start with \( S_0 = S \), construct the \SMT-encoding for \( S_0\subsbot \)
	and select one literal per clause from \( S_0 \) into \( L_1 \).
	Because of congruence the selection is unambiguous by any model,
	i.e.~\(\msucc(\consbot) \mNE \msucc (\consbot)\) must not hold in the ground model.
	We easily derive the empty clause from the set of selected literals \( L_0 \)
	by first applying unit superposition and unit equality resolution afterwards.
\begin{align*}
	S_0 &= \{ \, {\msucc(x_1) \mNE \msucc (y_1) \lor x_1 \mEQ y_1}, \, \msucc(x_2)\mNE x_2 \, \}
	\\
	S_0\subsbot &= \{ \, \msucc(\consbot) \mNE \msucc (\consbot) \lor{\colHi\consbot \mEQ \consbot}, \,
	{\colHi \msucc(\consbot)\mNE \consbot} \, \}
	\\
	L_0 &= \{ x_1\mEQ y_1, \msucc(x_2)\mNE x_2 \}
	\\[0.7em]
	&\infer[\sigma_1 = \{ x_1\mapsto \msucc(x_2)\}
	]{
		\infer[ \{ y_1\mapsto x_2\}]{\emptyclause}{ {y_1}\mNE x_2 }
	}
	{x_1 \mEQ y_1 & [{\msucc(x_2)}]\mNE x_2}
	\\[0.7em]
\end{align*}

Following the procedure
we instantiate \( \mcC'_3 = \mcC_1\cdot\sigma_1 \).
For convenience we rename the variables \( \mcC_3 = \mcC_3'\cdot\rho \).
We ignore \( \mcC_2 \) which would just yield a variant of itself.
\begin{align*}
	\mcC_3 &= \msucc(\msucc(x_3)) \mNE \msucc(y_3) \lor \msucc(x_3) \mEQ y_3
	\\
	\mcC_{i+3} &= \msucc^{i+2}(x_{i+3})\mEQ \msucc(y_{i+3}) \lor \msucc^{i+1}(x_{i+3})\mEQ y_{i+3}
	\tag*{\( i=0 \) (base case)}
	\end{align*}
	We now show by induction that \InstGenEQ{} yields an infinite sequence of distinct clauses \( \mcC_{i+3} \) for \( i\in\mathbb{N} \).
	The base case \( i=0 \) is already covered. We assume for simplicity and without loss of generality that the literal \( \msucc^{i+1}(x_{i+3})\mEQ y_{i+3} \) will never be selected.\footnote{
		Otherwise we quickly derive the unit clause \( \msucc^{i+1}(x_{i+3})\mNE x_2 \) that prohibits the selection.}
	We then can derive the contradiction from the selected literals of the first and the newest clause
	and instantiate the first clause with the new unifier \( \sigma_{i+2} \).
	\begin{align*}
	S_{i+1} &= S_i\disjointunion \, \{ \,
	\msucc^{i+2}(x_{i+3}) \mNE \msucc(y_{i+3}) \lor \msucc^{i+1}(x_{i+3}) \mEQ y_{i+3} \,
	\}
	\tag*{\( i\geq 0 \) (IH)}
	\\
	S_{(i+1)\!_\bot} &= S_{0\!_\bot}\disjointunion \, \{ \,
	{\colHi\msucc^{i+2}(\consbot) \mNE \msucc(\consbot)} \lor {\msucc^{i+1}(\consbot) \mEQ \consbot} \,
	\}
	\\
	L_{i+1} &= L_i \disjointunion \, \{ \,
		\msucc^{i+2}(x_{i+3})) \mNE \msucc(y_{i+3})
	 \, \}
	\\[0.7em]
	&\infer[\sigma_{i+2} = \{ x_1\mapsto \msucc^{i+2}(x_{i+3})\}
	]{
		\infer[ \{ y_1\mapsto \msucc(y_{i+3})\}]{\emptyclause}{ y_1\mNE \msucc(y_{i+3}) }
	}
	{x_1 \mEQ y_1 & [\msucc^{i+2}(x_{i+3})]\mNE \msucc(y_{i+3})}
	\\
	\mcC'_{(i+1)+3} &= \mcC_1\cdot\sigma_{i+2} =
	\msucc(\msucc^{i+2}(x_{i+3})) \mNE \msucc(y_{i+3}) \lor \msucc^{i+2}(x_{i+4}) \mEQ y_{i+3}
	\\
	\mcC_{(i+1)+3} &=
	\msucc^{(i+1)+2}(x_{i+4}) \mNE \msucc(y_{i+4}) \lor \msucc^{(i+1)+1}(x_{i+4}) \mEQ y_{i+4}
	\tag{step case}
\end{align*}

%\begin{align*}
%	S_1 &= S_0\disjointunion \{ \,
%	\boxed{\msucc(\msucc(x)) \mNE \msucc(x) \lor \msucc(x) \mEQ x} \,
%	\}
%	\\
%	S_{i+1} &= S_i\disjointunion \{ \,
%		\msucc^{i+2}(x)) \mNE \msucc^{i+1} (x) \lor \msucc^{i+1}(x) \mEQ \msucc^i(x) \,
%	\}
%	\\
%	S_{(i+1)\!_\bot} &= S_i\disjointunion \{ \,
%	{\colHi \msucc^{i+2}(\consbot)) \mNE \msucc^{i+1} (\consbot)} \lor {\colG\msucc^{i+1}(\consbot) \mEQ \msucc^i(\consbot)} \,
%	\}
%	\\
%	&\infer[x'\mapsto \msucc^{i+2}(x)
%	]{
%		\infer[y'\mapsto \msucc^{i+1}(x)]{\emptyclause}{ y'\mNE \msucc^{i+1}(x) }
%	}
%	{x' \mEQ y' & \msucc^{i+2}(x)\mNE \msucc^{i+1}(x)}
%	\\
%	S_{i+2} &= S_{i+1}\disjointunion \{ \,
%	\boxed{\msucc^{i+3}(x) \mNE \msucc^{i+2}(x) \lor \msucc^{i+2}(x) \mEQ \msucc^{i+1}(x)} \,
%	\}
%\end{align*}
\end{example}

%\begin{definition}\label{def:unit:superposition}
%	\begin{align*}
%	\infer[\sigma]{(s[r]\mEQ t)\sigma}{\ell\mEQ r & s[\ell'] \mEQ t} & &
%	\infer[\sigma]{(s[r]\mNE t)\sigma}{\ell\mEQ r & s[\ell'] \mNE t}\tag*{unit superposition}\\
%	& \infer[\sigma]{\emptyclause}{\ell \mNE r}\tag*{equality resolution} \\
%	\end{align*}
%	where \( \sigma = \mgu(\ell,\ell') \),
%	\( \ell' \) is not a variable,
%	\( \ell\sigma\tau >_{gr} r\sigma\tau \),
%	\( s[\ell']\sigma\tau >_{gr} t\sigma\tau \),
%	\( \var({\ell, r}) \cup \var( \{ s[l'],t \}) ) = \emptyset \)
%\end{definition}


\begin{align*}
S_0 &= \{ \, \boxed{\msucc(x') \mNE \msucc (y') \lor x' \mEQ y'}, \, \msucc(x)\mNE 0 \, \}
\\
S_{0\!_\bot} &= \{ \, \msucc(\consbot) \mNE \msucc (\consbot) \lor{\colHi\consbot \mEQ \consbot}, \, {\colHi \msucc(\consbot)\mNE 0} \, \}
\\
&\infer[x'\mapsto \msucc(x)
]{
	\infer[y'\mapsto 0]{\emptyclause}{ y'\mNE x }
}
{x' \mEQ y' & \msucc(x)\mNE x}
\\
S_1 &= S_0\disjointunion \{ \,
\boxed{\msucc(\msucc(x)) \mNE \msucc(0) \lor \msucc(x) \mEQ 0} \,
\}
\\
S_{i+1} &= S_i\disjointunion \{ \,
\msucc^{i+2}(x) \mNE \msucc^{i+1} (0) \lor \msucc^{i+1}(x) \mEQ \msucc^i(0) \,
\}
\\
S_{(i+1)\!_\bot} &= S_i\disjointunion \{ \,
{\colHi \msucc^{i+2}(\consbot) \mNE \msucc^{i+1} (0)} \lor {\colG\msucc^{i+1}(\consbot) \mEQ \msucc^i(0)} \,
\}
\\
&\infer[x'\mapsto \msucc^{i+2}(x)
]{
	\infer[y'\mapsto \msucc^{i+1}(0)]{\emptyclause}{ y'\mNE \msucc^{i+1}(0) }
}
{x' \mEQ y' & \left[\msucc^{i+2}(x)\right]\mNE \msucc^{i+1}(0)}
\\
S_{i+2} &= S_{i+1}\disjointunion \{ \,
\boxed{\msucc^{i+3}(x) \mNE \msucc^{i+2}(0) \lor \msucc^{i+2}(x) \mEQ \msucc^{i+1}(0)} \,
\}
\end{align*}

\newpage
\section{Roundup of Calculi}

In Table \vref{tab:calculi:and:provers} we give a small list of first order theorem provers,
e.g. 
Vampire\footnote{\url{http://vprover.org}}, 
E\footnote{\url{https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html}},
iProver\footnote{\url{http://www.cs.man.ac.uk/~korovink/iprover/}},
and iProverEq \cite{KS2010ijcar},
that take advantage of the discussed calculi.

\begin{table}[hb]
\begin{tabular}{lllllll}
	\toprule
	Calculus & Equality & Exit condition & Implementations
	\\ \midrule
	Gilmore & axioms & \( S_i \equiv \bigvee\emptyclause \) & Gilmore
	\\
	Resolution & axioms & \( \emptyclause\in S_i \) & Vampire, iProver, \ldots
	\\
	\InstGen{} & axioms & \( \lnot\SAT(S_i\bot) \) 
	& iProver
	\\
	Superposition & derivation rules & \( \emptyclause\in S_i \) 
	& Vampire, E, \ldots
	\\
	\InstGenEQ{} & derivation rules & \( \lnot\SMT(S_i\bot \)) 
	& iProverEq
	\\ \bottomrule
\end{tabular}
\label{tab:calculi:and:provers}
\end{table}





