% !TeX root = ../mythesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Data Structures and Algorithms}



\section{Sets of Clauses}

% \subsection{Terms, Atoms, and Literals}

The recursive definition of the syntax of terms, atoms and literal suggests a tree data structure.

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2cm/#1,
	level distance = 0.8cm}]

\node { \( \lnot \) }
	child {
		node { \( \mP \) }
		child { node {\( x \)} }
		child { node {\( \mf \)}
			child { node {\( x \)} }
		}
	}
;
\end{tikzpicture}

% \begin{tikzpicture}
% \draw (0,0) rectangle (1,1);
% \draw (0.1,0.1) rectangle (1cm,1cm);

% \draw (0,0) to (1,1);
% \end{tikzpicture}

% \subsection{Sets}

Clauses are defined as multisets of literals.


\section{Saturation Basics}\label{sec:saturation:basics}

In examples in Chapter~\ref{chapter:automation},
we just applied derivation rules
to haphazardly chosen pairs of clauses
to infer new clauses
until we could conclude unsatisfiability.
%
In practice, such an approach may fail for an unsatisfiable set of clauses
simply because an important clause pairing is overlooked
and an infinite number of inferences can be drawn
from a satisfiable subset of clauses.
%
In Chapter~\ref{chapter:completeness}, on the other hand,
we relied on a fair ---
i.e.\ every non-redundant clause will be processed eventually ---
saturation process to prove completeness of \InstGenEQ{}.

For now we will ignore possible simplifications of the set of clauses.
In Section~\ref{sec:given:clause:algorithm}
we will combine the given clause algorithm
and a basic selection strategy to a a simple and fair saturation process
that eventually determines all possible derivate clauses
with respect to ordered resolution.
Surprisingly the same approach will fail easily for \InstGen{}.
We consider a better suited bookkeeping of processed clauses and literals
in Section~\ref{sec:selected:literals:bookkeeping}.


% Both algorithms are just only building blocks for fair saturation strategies as we outline in Section~\ref{sec:fair:saturation:strategies:basics}


\subsection{Given Clause Algorithm}\label{sec:given:clause:algorithm}

\begin{procedure}[Given Clause Algorithm]\label{proc:given:clause:algorithm}
	We start with a set \( S = P \disjointunion U \)
	of initially empty \coloremph{processed} clauses \( P \)
	and set of \coloremph{unprocessed} clauses \( U \).
	\begin{enumerate}
		\item[\jek] Whenever we can conclude unsatisfiability of \( S \)
		we exit the procedure with \( \lnot\SAT \).
		\setcounter{enumi}{0}
		\item If there are no unprocessed clauses,
		we exit and return \SAT{}.
		\item We select the \coloremph{best} unprocessed clause --- the now given clause \( G  \) --- and remove it from the unprocessed clauses. \hfill\jek{}
		\item We iterate over the processed clauses and check for applicable inference rules
		for each pair \( (C, G) \subseteq P \times \{ G \} \) of a processed and the given clause
		to derive additional clauses which we add to the set of unprocessed clauses. \hfill\jek{}
		\item We add the given clause to the set of processed clauses.
		Then continue with step 1.
	\end{enumerate}
\end{procedure}

The crucial part is the selection of the best unprocessed clause as the given clause.
We have to ensure that any (non-redundant) clause is selected eventually.
Otherwise we may stay in a satisfiable subset of the set of clauses
as we can see in the following silly example with respect to resolution.

\begin{example}
	We process the clearly unsatisfiable set of clauses
	\( S = \{
		\msucc(x)\mNE \msucc(y)\lor {x\mEQ y},
		\msucc(x_0)\mNE x_0, \msucc(x')\mEQ x'
		\} \)
	and always select the newest clause as the “best” clause
	after we have moved the first clause to the processed clauses.

	\begin{align*}
		(1)\quad
		&\boxed{\msucc(x)\mNE \msucc(y)\lor {x\mEQ y}} &
		&&
		&{ \msucc^1(x_0)\mNE \msucc^0(x_0) },\ { \msucc(x')\mEQ x' }
		\\
		(2)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&&
		&\boxed{ \msucc^1(x_0)\mNE \msucc^0(x_0) }\ \ldots
		\\
		(3+0)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&{\left(\msucc^{i+1}(x_i)\mNE \msucc^{i}(x_i)\right)}_{i=0}^0 &
		&\boxed{ \msucc^2(x_1)\mNE \msucc^1(x_1) }\ \ldots
		\\
		(3+k)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&{\left(\msucc^{i+1}(x_i)\mNE \msucc^{i}(x_i)\right)}_{i=0}^k &
		&\boxed{ \msucc^{k+2}(x_{k+1})\mNE \msucc^{k+1}(x_{k+1}) }
		\end{align*}
		The first clause always clashes with the newest clause.
		\begin{gather*}
			\infer[
				\{x\mapsto\msucc^{k+2}(x_{k+1}),
				y\mapsto\msucc^{k+1}(x_{k+1})\}
				]{
					\begin{array}{c}
					\msucc(\msucc^{k+2}(x_{k+1}))\mNE \msucc(\msucc^{k+1}(x_{k+1}))
					\\ \equiv \\
					\msucc^{k+3}(x_{k+2})\mNE \msucc^{k+2}(x_{k+2})
					\end{array}
				}{
				\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
				\msucc^{k+2}(x_{k+1})\mNE \msucc^{k+1}(x_{k+1})
			}
		\end{gather*}





\end{example}

\begin{definition}[First-in/First-Out clause selection]~\cite{DBLP:conf/cade/SchulzM16, DBLP:conf/cade/2016}
	Instead of two sets of clauses we maintain
	the set of processed clauses and a queue of unprocessed clauses.
	At start the collection of processed clauses is empty
	and the queue of unprocessed clauses is enqueued with
	the clauses of the problem, i.e.\ the set of clauses
	that has to be shown unsatisfiable. We restrict selection and adding of clauses
	in Procedure~\ref{proc:given:clause:algorithm}:
	\begin{enumerate}
		\item[2.]
		We select the “best” clause
		by dequeuing it from the unprocessed clauses.
		\item[3.]
		We enqueue newly derived clauses into the unprocessed clauses.
	\end{enumerate}
Clearly we will not miss any clause (pairing).
\end{definition}



In the following examples the given clause is boxed,
the processed clauses are on the left of the given clause,
and the unprocessed clauses are on the right.
Each line represents one iteration of our
Procedure~\ref{proc:given:clause:algorithm}.
%
In both examples we start with the unsatisfiable set of clauses
\( S=\{ \, \mP(\ma)\lor\mQ(a), \mP(\ma)\lor\lnot\mQ(y), \lnot\mP(x) \, \} \).

\subsubsection{Ordered Resolution}

\jek{} \( \ \Leftarrow\emptyclause\in S_i \). We conclude unsatisfiability of \( S \) whenever the empty clause is found (already present or derived).
New clauses are disjunctions of instances of an active and the given clause where conflicting literals were removed,
in other words the union of the two instances without the contradicting literals.
\begin{gather*}
\infer[\sigma=\{ x'\mapsto\mf(x), y\mapsto\mg(y') \}]{
	(\mcC \lor \mcD)\sigma
}{
	\mP(\mf(x), y) \lor \mcC & \lnot\mP(x',\mg(y')) \lor \mcD
}
\end{gather*}

\begin{example}[Ordered Resolution] We assume \( \mP(\ma)\succ\mQ(\ma) \),
	we underline the maximal literal in the given clauses,
	we tint conflicts red,
	 and we derive the empty clause in the fifth iteration.

	\begin{align*}
	^{1:}&\boxed{\underline{\mP(\ma)}\lor\mQ(a)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(y) & ^{3:}&\lnot\mP(x)
	\\
	^{1:}&\mP(\ma)\lor\mQ(a)
	& ^{2:}&\boxed{\underline{\mP(\ma)}\lor\lnot\mQ(y)} & ^{3:}&\lnot\mP(x)
	\\
	^{1:}&{\colLo\mP(\ma)}\lor\mQ(a)
	& ^{2:}&{\colLo\mP(\ma)}\lor\lnot\mQ(y)
	& ^{3:}&\boxed{\underline{\lnot\mP(x)}}
	& ^{1,3:}&\mQ(\ma)
	& ^{2,3:}&\lnot\mQ(y)
	\\
	^{1:}&\mP(\ma)\lor\mQ(a)
	& ^{2:}&\mP(\ma)\lor{\colLo\lnot\mQ(y)}
	& ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\boxed{\underline{\mQ(\ma)}}
	& ^{2,3:}&\lnot\mQ(y)
	& ^{2,(1,3):}&\mP(\ma)
	\\
	^{1:}&\mP(\ma)\lor{\colLo\mQ(a)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(y)
	& ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\colLo\mQ(\ma)
	& ^{2,3:}&\boxed{\underline{\lnot\mQ(y)}}
	& ^{2,(1,3):}_{1,(2,3):}&\mP(\ma)
	& ^{(1,3),(2,3):}&\emptyclause
	\\
	\end{align*}
\end{example}

\subsubsection{InstGen}

\jek{} \( \ \Leftarrow \lnot\SAT(S_i\bot) \). We conclude unsatisfiability of \( S \) whenever (a subset of) \( S_i\bot \) --- a set of ground instances --- is unsatisfiable.
We consider only proper instances of an processed or given clause
as probable new clauses to extend the set of clauses.
\begin{gather*}
	\infer[\sigma=\{ x'\mapsto\mf(x), y\mapsto\mg(y') \}]{
		\mP(\mf(x),\mg(y')) \lor\mcC\sigma
		\qquad
		\lnot\mP(\mf(x),\mg(y'))\lor\mcD\sigma
	}{
		\mP(\mf(x), y) \lor \mcC & \lnot\mP(x',\mg(y')) \lor \mcD
	}
\end{gather*}


\begin{example}[InstGen]The processed and given clauses are already encoded and given to a \SAT{} solver.
	The basic given clause algorithm would stop and fail after \( (4) \)
	since \( S_4\bot \) is still satisfiable and there is no conflict between the underlined selected literal of the given clause
	and any selected literals of any of the processed clauses.

	\begin{align*}
	(1)\quad^{1:}&\boxed{\underline{\mP(\ma)}\lor\mQ(\ma)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(\consbot/y)
	& ^{3:}&\lnot\mP(\consbot/x)
	\\
	(2)\quad^{1:}&{\colHi\underline{\mP(\ma)}}\lor\mQ(\ma)
	& ^{2:}&\boxed{\underline{\mP(\ma)}\lor\lnot\mQ(\consbot/y)}
	& ^{3:}&\lnot\mP(\consbot/x)
	\\
	(3)\quad^{1:}&{\colHi\underline{\mP(\ma)}}\lor\mQ(\ma)
	& ^{2:}&{\colHi\underline{\mP(\ma)}}\lor\lnot\mQ(\consbot/y)
	& ^{3:}&\boxed{\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\lnot\mP(\ma)
	\\
	(4)\quad
	^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(\ma)
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	& ^{3:}&{\colHi\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\boxed{\underline{\lnot\mP(\ma)}}
	\end{align*}
	But the model did change in (4) and the selected literals of two of the processed clauses had to be changed too.
	Processed clauses with changed selected literals have to be moved back to the unprocessed clauses.
	Then we hit a contradiction of ground instances in (7').
	\begin{align*}
	(4')\quad^{3:}&{\underline{\colHi\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\boxed{\underline{\lnot\mP(\ma)}}
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(\ma)
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	\\
	(5')\quad^{3:}&{\underline{\colHi\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\colHi\underline{\lnot\mP(\ma)}
	& ^{1:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\underline{\mQ(\ma)}}
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	\\
	(6')\quad^{3:}&{\colHi\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\colHi\underline{\lnot\mP(\ma)}
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\underline{\mQ(\ma)}
	& ^{2:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\underline{\lnot\mQ(\consbot/y)}}
	& ^{2,1:}&\mP(\ma)\lor\lnot\mQ(\ma)
	\\
	(7')\quad^{3:}&{\lnot\mP(\consbot/x)}
	& ^{1,3:}_{2,3:}&\colHi\lnot\mP(\tikzmark{NP}\ma)
	& ^{1:}&{\colLo\mP(\tikzmark{PP}\ma)}\lor\colN\mQ(\tikzmark{PQ}\ma)
	& ^{2:}&{\mP(\ma)\lor\lnot\mQ(\consbot/y)}
	& ^{2,1:}&\boxed{{\colLo\mP(\tikzmark{PA}\ma)}\lor\colN\lnot\mQ(\tikzmark{NQ}\ma)}
	\end{align*}

	\begin{tikzpicture}[overlay,remember picture, out=340, in=200 ]
	\draw[->, thick, dotted] (NP.south) to (PP.south);
	\draw[->, thick, dotted] (NP.south) to (PA.south);
	\draw[<->,red, thick] (PQ.south) to (NQ.south);
	\end{tikzpicture}
\end{example}


\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {unprocessed\\clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) { \SAT};

		\node (un) [mycircle] at (-15em,8em) {
			% cspell:disable
			un\-satis\-fiable
			% cspell:enable
			};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given\\clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {processed\\clauses};

		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick,
		%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) { \InstGen};
		\node (sa) [mycircle] at (16em,8em) {
			% cspell:disable
			satis\-fiable
			% cspell:enable
			};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};

		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);

		\draw[myarrow,dotted] (ac.east) to [bend left=25](pc);

		\end{tikzpicture}
		\caption{Proving loop with \SAT{} and \InstGen{}}\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}

\subsection{Double-entry bookkeeping}\label{sec:selected:literals:bookkeeping}

% \subsection{An insufficient strategy}







\section{Term Indexing}





%“Implementations of theorem provers that use generative procedures like resolution (Robinson, 1965b; Chang and Lee, 1973) or Knuth-Bendix completion (Knuth and Bendix, 1970) face the problem of program degradation: The theorem prover`s rate of drawing conclusions falls off sharply with time due to an increasing amount of retained information (Wos, 1992). \cite{Graf1998}



In refutation theorem proving (a lot of) clauses are produced.
For each generated clause we may have to find
existing variants, generalizations, or instances of it.
In a more general view we want to find existing clauses
that subsume our clause or are subsumed by a our clause
to avoid logical redundancies in our set\footnote{
	At least we might expect that by adding clauses
	that are syntactical identical to clauses already in the set
	we do not increase the cardinality of the set.
} of clauses.
Further we search for existing clauses that contain clashing literals to a literal in our clause.
This search may be restricted by a given order (e.g.~Superposition) or a propositional model (e.g.~\InstGenEQ).
Last but not least we may search for subterms in literals of existing clauses that matches a term in an equation.

Naively we can just scan through all existing clauses and check each clause for the desired qualities.
	The workload for processing a generated clause is proportional to the number of existing clauses and
	the workload for checking a pair of clauses.
	The latter includes unification, which is at least linear to the size of clauses~\cite{ALBERT19933},
	while Robinson's unification algorithm~\cite{Robinson:1965:MLB:321250.321253} is exponential in the worst case.
	The complexity for this direct approach of processing \( n \) clauses of fixed size (i.e.~constant unification costs per pair) is \( \mcO(n^2) \).

\input{samples/termindexing}







\subsection{Clashing literals}

\subsection{Variants}

\subsection{Instances}

\subsection{Subsumption}



