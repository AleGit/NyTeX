% !TeX root = ../mythesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Data Structures and Algorithms}



% \section{Data structures}

% \begin{enumerate}
% 	\item Trees as first order literals, i.e.\ the root symbol is either a (negated) predicate symbol or the (negated) equality symbol.
% 	\item Multisets of literals for first order clauses
% 	\item Sets for Problems, i.e.~sets of clauses
% \end{enumerate}

% \subsection{Terms, Atoms, and Literals}

% The recursive definition of the syntax of terms, atoms and literal suggests a tree data structure.


% \begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2cm/#1,
% 	level distance = 0.8cm}]

% \node { \( \lnot \) }
% 	child {
% 		node { \( \mP \) }
% 		child { node {\( x \)} }
% 		child { node {\( \mf \)}
% 			child { node {\( x \)} }
% 		}
% 	}
% ;
% \end{tikzpicture}

% \begin{tikzpicture}
% \draw (0,0) rectangle (1,1);
% \draw (0.1,0.1) rectangle (1cm,1cm);

% \draw (0,0) to (1,1);
% \end{tikzpicture}

% \subsection{Sets}

% Clauses are defined as multisets of literals.


\section{Saturation Basics}\label{sec:saturation:basics}

In the examples of Chapter~\ref{chapter:automation},
we just applied derivation rules
to haphazardly chosen pairs of clauses
to infer new clauses
until we could conclude unsatisfiability.
%
In practice, such an approach may fail for an unsatisfiable set of clauses
simply because an important clause pairing is overlooked
and an infinite number of inferences can be drawn
from a satisfiable subset of clauses.
%
In Chapter~\ref{chapter:completeness}, on the other hand,
we relied on a fair ---
i.e.\ every non-redundant clause will be processed eventually ---
saturation process to show completeness of \InstGenEQ{}.

For now we will ignore possible simplifications of the set of clauses.
In Section~\ref{sec:given:clause:algorithm}
we will combine the given clause algorithm
and a basic selection strategy to a a simple and fair saturation process
that eventually determines all possible derivate clauses
with respect to ordered resolution.
Surprisingly the same approach will fail easily for \InstGen{}.
We consider a better suited bookkeeping of processed clauses and literals
in Section~\ref{sec:selected:literals:bookkeeping}.


% Both algorithms are just only building blocks for fair saturation strategies as we outline in Section~\ref{sec:fair:saturation:strategies:basics}

\subsection{Given Clause Algorithm}\label{sec:given:clause:algorithm}

The given clause algorithm is originated in the set of support strategy~\cite{Wos:1965:ECS:321296.321302}. (todo: Otter and discount loops~\cite{DBLP:conf/cade/SchulzM16})
%\cite{10.1007/978-3-319-40229-1_23, DBLP:conf/cade/SchulzM16})

\begin{procedure}[Given Clause Algorithm]\label{proc:given:clause:algorithm}
	We start with an empty set \( P \) of \coloremph{processed} clauses \( P \)
	and the original set of \coloremph{unprocessed} clauses \( U = S \),
	e.g.\ a set of axioms and a negated conjecture.
	\begin{enumerate}
		\item[\jek] Whenever we can conclude unsatisfiability of the original set of clauses \( S \),
		we exit the procedure with \( \lnot\SAT \).
		\setcounter{enumi}{0}
		\item If there are no unprocessed clauses,
		we exit and return \SAT{}.
		\item We select the \coloremph{best} unprocessed clause --- the now given clause \( G  \) --- and remove it from the unprocessed clauses. \hfill\jek{}
		\item We iterate over the processed clauses and check for applicable inference rules
		for each pair \( (C, G) \subseteq P \times \{ G \} \) of a processed and the given clause
		to derive additional clauses which we add to the set of unprocessed clauses. \hfill\jek{}
		\item We add the given clause to the set of processed clauses.
		We continue with step 1.
	\end{enumerate}
\end{procedure}

(In the following examples the given clause is boxed,
the processed clauses are left of the given clause,
and the unprocessed clauses are right of the given clause.
Each line represents one iteration of the procedure.)

A crucial part is the selection of the “best” unprocessed clause.
At least we have to ensure that any (non-redundant) clause is selected eventually.
Otherwise we may stay in a satisfiable subset of the set of clauses
as we demonstrate in the following silly example with respect to resolution.
\begin{example}[Insufficient clause selection]
	We process the clearly unsatisfiable set of clauses
	\( S = \{
		\msucc(x)\mNE \msucc(y)\lor {x\mEQ y},
		\msucc(x_2)\mNE x_2, \msucc(x')\mEQ x'
		\} \)
	and always select the \coloremph{newest} unprocessed clause as the “best” clause
	after we have moved the first clause to the processed clauses.

	\begin{align*}
		(k=1)\quad
		&\boxed{\msucc(x)\mNE \msucc(y)\lor {x\mEQ y}} &
		&&
		&{ \msucc^1(x_2)\mNE \msucc^0(x_2) },\ { \msucc(x')\mEQ x' }
		\\
		(k=2)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&&
		&\boxed{ \msucc^1(x_2)\mNE \msucc^0(x_2) }\ \ldots
		\\
		(k=3)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&{\left(\msucc^{i-1}(x_{i})\mNE \msucc^{i-2}(x_{i})\right)}_{i=2}^{2} &
		&\boxed{ \msucc^2(x_3)\mNE \msucc^1(x_3) }\ \ldots
		\\
		(k=4)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&{\left(\msucc^{i-1}(x_{i})\mNE \msucc^{i-2}(x_{i})\right)}_{i=2}^{3} &
		&\boxed{ \msucc^3(x_4)\mNE \msucc^2(x_4) }\ \ldots
		\\
		\cdots\quad & \cdots && \cdots && \cdots
		\\
		(k>3)\quad
		&\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
		&{\left(\msucc^{i-1}(x_{i})\mNE \msucc^{i-2}(x_{i})\right)}_{i=2}^{k-1} &
		&\boxed{ \msucc^{k-1}(x_{k})\mNE \msucc^{k-2}(x_{k}) }
		\end{align*}
		In each iteration the newest clause
		(an instance of the second clause)
		clashes with the first clause but no other of the so far processed clauses.
		\begin{gather*}
			\infer[
				\{x\mapsto\msucc^{k-1}(x_{k}),
				y\mapsto\msucc^{k-2}(x_{k})\}
				]{
					\begin{array}{c}
					\msucc(\msucc^{k-1}(x_{k}))\mNE \msucc(\msucc^{k-2}(x_{k}))
					\\ \equiv \\
					\msucc^{k}(x_{k+1})\mNE \msucc^{k-1}(x_{k+1})
					\end{array}
				}{
				\msucc(x)\mNE \msucc(y)\lor \underline{x\mEQ y} &
				\msucc^{k-1}(x_{k})\mNE \msucc^{k-2}(x_{k+1})
			}
		\end{gather*}
\end{example}



\begin{definition}[First-in/First-out clause selection~\cite{DBLP:conf/cade/SchulzM16, DBLP:conf/cade/2016}]
	We keep track of the order clauses were added (e.g.\ by a queue).
	We restrict selection and adding of clauses
	in Procedure~\ref{proc:given:clause:algorithm} as follows:
	\begin{enumerate}
		\item[2.]
		We select the \coloremph{oldest} unprocessed clause as the best or given clause.
		\item[3.]
		We add each derived clause
		as the so far newest unprocessed clause.
	\end{enumerate}
Clearly we will not miss any clause or literal pairing.
\end{definition}

\subsubsection{Ordered Resolution}

\jek{} \( \ \Leftarrow\emptyclause\in S_i \).
With Ordered Resolution we conclude unsatisfiability of \( S \) whenever the empty clause is found (already present or derived).
New clauses are disjunctions of instances of an active and the given clause where conflicting literals were removed,
in other words the union of the two instances without the contradicting literals.
\begin{gather*}
\infer[\sigma=\{ x'\mapsto\mf(x), y\mapsto\mg(y') \}]{
	(\mcC \lor \mcD)\sigma
}{
	\mP(\mf(x), y) \lor \mcC & \lnot\mP(x',\mg(y')) \lor \mcD
}
\end{gather*}

\begin{example}
	We start with the clearly unsatisfiable set of clauses
\( S=\{ \, \mP(\ma)\lor\mQ(\ma), \mP(\ma)\lor\lnot\mQ(y), \lnot\mP(x) \, \} \).
	We assume \( \mP(\ma)\succ\mQ(\ma) \),
	we underline the maximal literal in the given clauses,
	we tint conflicts red,
	 and we derive the empty clause in the fifth iteration.

	\begin{align*}
	^{1:}&\boxed{\underline{\mP(\ma)}\lor\mQ(a)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(y) & ^{3:}&\lnot\mP(x)
	\\
	^{1:}&\mP(\ma)\lor\mQ(a)
	& ^{2:}&\boxed{\underline{\mP(\ma)}\lor\lnot\mQ(y)} & ^{3:}&\lnot\mP(x)
	\\
	^{1:}&{\colLo\mP(\ma)}\lor\mQ(a)
	& ^{2:}&{\colLo\mP(\ma)}\lor\lnot\mQ(y)
	& ^{3:}&\boxed{\underline{\lnot\mP(x)}}
	& ^{1,3:}&\mQ(\ma)
	& ^{2,3:}&\lnot\mQ(y)
	\\
	^{1:}&\mP(\ma)\lor\mQ(a)
	& ^{2:}&\mP(\ma)\lor{\colLo\lnot\mQ(y)}
	& ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\boxed{\underline{\mQ(\ma)}}
	& ^{2,3:}&\lnot\mQ(y)
	& ^{2,(1,3):}&\mP(\ma)
	\\
	^{1:}&\mP(\ma)\lor{\colLo\mQ(a)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(y)
	& ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\colLo\mQ(\ma)
	& ^{2,3:}&\boxed{\underline{\lnot\mQ(y)}}
	& ^{2,(1,3):}_{1,(2,3):}&\mP(\ma)
	& ^{(1,3),(2,3):}&\emptyclause
	\\
	\end{align*}
\end{example}

\subsubsection{InstGen}

\jek{} \( \ \Leftarrow \lnot\SAT(S_i\bot) \).
With \InstGen{} we conclude unsatisfiability of \( S \) whenever (a subset of) \( S_i\bot \) --- a set of ground instances --- is unsatisfiable.
We consider only proper instances of an processed or given clause
as probable new clauses to extend the set of clauses.
\begin{gather*}
	\infer[\sigma=\{ x'\mapsto\mf(x), y\mapsto\mg(y') \}]{
		\mP(\mf(x),\mg(y')) \lor\mcC\sigma
		\qquad
		\lnot\mP(\mf(x),\mg(y'))\lor\mcD\sigma
	}{
		\mP(\mf(x), y) \lor \mcC & \lnot\mP(x',\mg(y')) \lor \mcD
	}
\end{gather*}

\begin{example}
	Again we start with the clearly unsatisfiable set of clauses
\( S=\{ \, \mP(\ma)\lor\mQ(\ma), \mP(\ma)\lor\lnot\mQ(y), \lnot\mP(x) \, \} \).
	The processed and given clauses are already encoded and
	given to a \SAT{} or \SMT{} solver.
	The basic given clause algorithm would stop and fail after \( (4) \)
	since \( S_4\bot \) is still satisfiable and there is no conflict between the underlined selected literal of the given clause
	and any selected literals of any of the processed clauses.

	\begin{align*}
	(1)\quad^{1:}&\boxed{\underline{\mP(\ma)}\lor\mQ(\ma)}
	& ^{2:}&\mP(\ma)\lor\lnot\mQ(\consbot/y)
	& ^{3:}&\lnot\mP(\consbot/x)
	\\
	(2)\quad^{1:}&{\colHi\underline{\mP(\ma)}}\lor\mQ(\ma)
	& ^{2:}&\boxed{\underline{\mP(\ma)}\lor\lnot\mQ(\consbot/y)}
	& ^{3:}&\lnot\mP(\consbot/x)
	\\
	(3)\quad^{1:}&{\colHi\underline{\mP(\ma)}}\lor\mQ(\ma)
	& ^{2:}&{\colHi\underline{\mP(\ma)}}\lor\lnot\mQ(\consbot/y)
	& ^{3:}&\boxed{\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\lnot\mP(\ma)
	\\
	(4)\quad
	^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(\ma)
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	& ^{3:}&{\colHi\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\boxed{\underline{\lnot\mP(\ma)}}
	\end{align*}
	But the model did change in (4) and the selected literals of two of the processed clauses had to be changed too.
	Already processed clauses with changed selected literals have to be moved back to the unprocessed clauses.
	Then we hit a contradiction of ground instances in (7').
	\begin{align*}
	(4')\quad^{3:}&{\underline{\colHi\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\boxed{\underline{\lnot\mP(\ma)}}
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(\ma)
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	\\
	(5')\quad^{3:}&{\underline{\colHi\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\colHi\underline{\lnot\mP(\ma)}
	& ^{1:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\underline{\mQ(\ma)}}
	& ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(\consbot/y)
	\\
	(6')\quad^{3:}&{\colHi\underline{\lnot\mP(\consbot/x)}}
	& ^{1,3:}_{2,3:}&\colHi\underline{\lnot\mP(\ma)}
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\underline{\mQ(\ma)}
	& ^{2:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\underline{\lnot\mQ(\consbot/y)}}
	& ^{2,1:}&\mP(\ma)\lor\lnot\mQ(\ma)
	\\
	(7')\quad^{3:}&{\lnot\mP(\consbot/x)}
	& ^{1,3:}_{2,3:}&\colHi\lnot\mP(\tikzmark{NP}\ma)
	& ^{1:}&{\colLo\mP(\tikzmark{PP}\ma)}\lor\colN\mQ(\tikzmark{PQ}\ma)
	& ^{2:}&{\mP(\ma)\lor\lnot\mQ(\consbot/y)}
	& ^{2,1:}&\boxed{{\colLo\mP(\tikzmark{PA}\ma)}\lor\colN\lnot\mQ(\tikzmark{NQ}\ma)}
	\end{align*}

	\begin{tikzpicture}[overlay,remember picture, out=340, in=200 ]
	\draw[->, thick, dotted] (NP.south) to (PP.south);
	\draw[->, thick, dotted] (NP.south) to (PA.south);
	\draw[<->,colLo, thick] (PQ.south) to (NQ.south);
	\end{tikzpicture}
\end{example}


\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {unprocessed\\clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) { \SAT};

		\node (un) [mycircle] at (-15em,8em) {
			% cspell:disable
			un\-satis\-fiable
			% cspell:enable
			};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given\\clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {processed\\clauses};

		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick,
		%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) { \InstGen};
		\node (sa) [mycircle] at (16em,8em) {
			% cspell:disable
			satis\-fiable
			% cspell:enable
			};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};

		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);

		\draw[myarrow,dotted] (ac.east) to [bend left=25](pc);

		\end{tikzpicture}
		\caption{Proving loop with \SAT{} and \InstGen{}}\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}

\subsection{Bookkeeping}\label{sec:selected:literals:bookkeeping}

Just moving processed clauses back to unprocessed clauses may introduce unnecessary derivations from already considered literal pairings.
Since we have no control over the constructed models
the selected literal of a processed clause
could be deselected in a subsequent iteration \( m \)
and re-selected in an even later iteration \( n \).
Then some of this literals' pairings against
selected literals of the processed clauses
may have already been considered before iteration \( n \),
but our procedure did not keep track of that.

\begin{example}[InstGen]
	The first two clauses have been processed before step \( m \).
	The first clause moves to the unprocessed clauses in step \( m \)
	and could have been processed again before step \( n \).
	The first clause moves again to the unprocessed clauses in step \( n \).
When the first clause is processed after step \(n \)
its selected literal clashes again with the selected literal of
the second clause.
\begin{align*}
	^{1:}&\underline{\mP(x)}\lor L_1
	&^{2:}&\underline{\lnot\mP(\ma)}\lor L_2
	&&\textcolor{colG}{\cdots}
	&\textcolor{colG}{^{i:}}&\textcolor{colG}{L_1\lor L_2}
	&\textcolor{colG}{^{j:}}&\textcolor{colG}{\lnot L_1\lor\lnot L_2}
	&&\textcolor{colG}{\cdots}
	&\textcolor{colG}{^{1,2:}}&\textcolor{colG}{\mP(\ma)\lor L_1}
	\\
	(m)\quad
	^{1:}&\mP(x)\lor \underline{L_1}
	&^{2:}&\underline{\lnot\mP(\ma)}\lor L_2
	&&\cdots
	&^{i:}&\boxed{\underline{L_1}\lor L_2}
	&\textcolor{colG}{^{j:}}&\textcolor{colG}{\lnot L_1\lor\lnot L_2}
	&&\textcolor{colG}{\cdots}
	&&\textcolor{colG}{\cdots}
	\\
	&\vdots
	\\
	(n)\quad
	^{1:}&\underline{\mP(x)}\lor {L_1} &
	^{2:}&\underline{\lnot\mP(\ma)}\lor L_2 &
	&\cdots&
	^{i:}&{L_1}\lor \underline{L_2} &
	^{j:}&\boxed{\underline{\lnot L_1}\lor \lnot L_2} &
	&\textcolor{colG}{\cdots}
\end{align*}
\end{example}

\begin{procedure}
\end{procedure}



% \begin{align*}
% 	\textcolor{colHi}{\mP}\lor\mQ\lor\mR
% 	\\
% 	\mP\lor\textcolor{colHi}{\mQ}\lor\mR
% 	&&\lnot\mP\lor \textcolor{colHi}{\mQ} \lor \mR
% 	\\
% 	\mP\lor\textcolor{colHi}{\mQ}\lor\mR
% 	&&\lnot\mP\lor \textcolor{colHi}{\mQ} \lor \mR
% 	&&\mP\lor\lnot\mQ
% \end{align*}





% \subsection{An insufficient strategy}







\section{Term Indexing}





%“Implementations of theorem provers that use generative procedures like resolution (Robinson, 1965b; Chang and Lee, 1973) or Knuth-Bendix completion (Knuth and Bendix, 1970) face the problem of program degradation: The theorem prover`s rate of drawing conclusions falls off sharply with time due to an increasing amount of retained information (Wos, 1992). \cite{Graf1998}



A refutational theorem proving process produces (a lot of) clauses.
For each occurring clause, we have to find
all other clauses that match specific criteria.
% In a more general view we want to find existing clauses
% that subsume our clause or are subsumed by a our clause
First of all, of course, we want to avoid unnecessary clauses in our set of (processed) clauses\footnote{
	At least we might expect that we do not process multiple variants of a clause.
}.
Further we search for existing clauses that contain clashing literals to a literal in our clause.
% This search may be restricted by a given order (e.g.~superposition) or a propositional model (e.g.~\InstGenEQ).
In the presence of equality we search for subterms in literals that unifies with one side of an equation.

Naively we can just scan through all existing clauses (and literals)
and check each clause (and literal) for the desired qualities.
	Then the workload for processing one additional clause is proportional to the number of other clauses and
	the workload for checking a pair of clauses.
	The latter includes unification, which is at least linear to the size of clauses~\cite{ALBERT19933},
	while Robinson's unification algorithm~\cite{Robinson:1965:MLB:321250.321253} is exponential in the worst case.
	The complexity class for this direct approach of processing \( n \) clauses of fixed size (i.e.\ constant unification costs per pair) is \( \mcO(n^2) \).
%
	Term indexing~\cite{Graf1998} is about data structures and algorithms
	for faster retrieval of matching terms.

	\begin{definition}
		A \coloremph{position string} \( \ANGLES{p, s } \)
		is a pair of a position \( p \) and a symbol \( s \),
		e.g.\ variable symbol \( x \) or function symbol \( \mf \).
%
		We define the set of position strings of a term.
		\begin{gather*}
		\posS(t) =
		\begin{cases}
		\{ \ANGLES{\epsilon,x} \}
		& \text{if }t=x\in\SIGV \\
		\{ \ANGLES{\epsilon, \mf} \} \cup \{ \ANGLES{ip,s}\mid \ANGLES{p,s} \in\posS(t_i)\}
		&\text{if }t=\mf(t_1,\ldots,t_n)
		\end{cases}
		\end{gather*}
	\end{definition}



	\begin{definition}
		A \coloremph{term path} in a term \( t \)
		is a finite sequence
		\( {( \ANGLES{p_i,s_i} )}^{n}_{i=1}
			\)
		of position strings such that
		\( \ANGLES{p_i,s_i} \in \posS(t) \),
		and \( p_i = p_{i-1} k_i \)
		for all \( i > 1 \)
		and some \( k_i \in\mathbb{N} \),
		i.e.~\(p_{i-1}\) is the longest proper prefix of \(p_{i}\).


	\end{definition}

	\begin{definition}
		A \coloremph{term traversal} of a term \( t \)
		is a finite sequence
		\( {( \ANGLES{p_i,s_i} )}^{n}_{i=1}
			\)
		of position strings such that
		\( n = |\posS(t)| \) and
		\( \bigcup_{i=1}^{n} \{\ANGLES{p_i,s_i}\} = \posS(t) \).

		% \begin{gather*}
		% \MDEFINE[:\Leftrightarrow]{p \prec q}{clc}{
		% 	p < q & p\text{ is a proper prefix of }q
		% 	\\
		% 	i < j & \text{if }p=ras, q=rbt, a\in\mathbb{N}, b\in\mathbb{N}
		% }
		% \end{gather*}

		A pre-order term traversal \( {( \ANGLES{p_i,s_i} )}^{n}_{i=1} \)
		is a term traversal such that whenever \( i <_\mathbb{N} j \)
		for \( \ANGLES{p_i,s_i} \) and \( \ANGLES{p_j,s_j} \)
		then either the position
		\( p_i \) is a proper prefix of position \( p_j \)
		or the positions
		\( p_i = rms \) and \( p_j = rnt \)
		share a common (possible empty) prefix \( r \)
		and \(m <_\mathbb{N} n \) for natural numbers \( m \) and \( n \).
		(\(r,s,t\) are positions, i.e.\ sequences of natural numbers)

	\end{definition}

	\begin{example}
		We express term paths and term traversals
		with position strings,
		e.g.\ for term \( \mh(\mf(\ma, y )) \) we have \( \posS(
			{\mh(\mf(\ma, y ))}
			) = \{
			\ANGLES{\epsilon,\mh},
		\ANGLES{1,\mf},
		\ANGLES{11,\ma},
		\ANGLES{12,y}
		\}
		\).

	\begin{minipage}[c]{10.5cm}
		\begin{gather*}
			% {\ANGLES{\epsilon,\mh}\ANGLES{1,\mf}\ANGLES{11,\ma}
			% \tag*{{path from root to leaf \( \ma \) (---)}}
			% }
			% \\
			{\ANGLES{\epsilon,\mh}\ANGLES{1,\mf}\ANGLES{12,y}
			\tag*{{path from root to leaf \( y \) (dashed)}}
			}
			\\
			{\ANGLES{\epsilon,\mh}\ANGLES{1,\mf}\ANGLES{11,\ma}\ANGLES{12,y}
			\tag*{{pre-order traversal (dotted)}}
			}
		\end{gather*}
	\end{minipage}
	\qquad
	\begin{minipage}[c]{4.1cm}
		\begin{tikzpicture}[right]
		{\node (h) at (0,-1) {\( \ANGLES{\epsilon,\mh} \)};}
		{\node (hf) at (0,-2) {\( \ANGLES{1,\mf} \)};}
		{\node (hfa) at (-1,-3) {\( \ANGLES{11,\ma} \)};}
		{\node (hfy) at (1,-3) {\( \ANGLES{12,y} \)};}
		%
		{\path[->,dashed]
			(h) edge (hf)
			(hf)
			edge (hfy)
			;}
		{\path[->,dotted, bend right]
			(h) edge (hf)
			(hf) edge (hfa)
			(hfa) edge[bend left] (hfy)
			;}
		\end{tikzpicture}
	\end{minipage}
\end{example}

\begin{notation}
	Since \( p_{i} = p_{-1} k_{i} \) for
	all \( i > 1 \)  and
	some \( k_{i+1}\in\mathbb{N} \)
	we abbreviate term paths by omitting the prefixes in positions strings
	\( \ANGLES{p_{i-1} k_{i}, s_{i}} \) for \( i>1 \).
	\[
		{(\ANGLES{p_i, s_i })}_{i=1}^n
		\,=\, \ANGLES{p_1,s_1}{(\ANGLES{p_{i-1}k_i, s_i })}_{i=2}^n
		\,\simeq\, \ANGLES{p_1,s_1}{(\ANGLES{k_i, s_i })}_{i=2}^n
	\]
	For readability we omit the angles and separate
	positions and symbols with dots.
	\[ \ANGLES{p,\mh}\ANGLES{p1,\mf}\ANGLES{p12,y}
	\,\simeq\,\ANGLES{p,\mh}\ANGLES{1,\mf}\ANGLES{2,y}
	\,\simeq\,p.\mh.1.\mf.2.y \]
\end{notation}

\begin{notation}
	Since the pre-order term traversal is unique
	for any term
	and the arities of symbols are fixed we omit
	angles and positions at all and just separate symbols with dots.
	\[
		\ANGLES{\epsilon,\mh}\ANGLES{1,\mf}\ANGLES{11,\ma}\ANGLES{12,y}
		\simeq
		\mh.\mf.\ma. y
		\]
\end{notation}








	% \begin{definition}Let us first define some relations on terms, literals and clauses.
	% 	\begin{align*}
	% 	% \VRNT(s,t)&\Leftrightarrow
	% 	\exists\sigma\ &s\sigma = t\sigma, \sigma\text{ is renaming}
	% 	\tag*{ \(s\) and \(t\) are variants}
	% 	\\
	% 	% \INST(s,t)&\Leftrightarrow
	% 	\exists\sigma\ &s = t\sigma\tag*{\( s \) is instance of \( t \)}
	% 	\\
	% 	% \GNRL(s,t)&\Leftrightarrow
	% 	\exists\sigma\ &s\sigma = t\tag*{\( s \) is generalization of \( t \)}
	% 	\\
	% 	% \UNIF(s,t)&\Leftrightarrow
	% 	\exists\sigma\ &s\sigma = t\sigma
	% 	\tag*{\(s\) and \(t\) are unifiable}
	% 	\\
	% 	% \PSSTR(L, s)&\Leftrightarrow
	% 	\exists p\ &L|_p\text{ and } s \text { are unifiable}
	% 	\\
	% 	% \SUBS(\mcC, \mcD)&\Leftrightarrow
	% 	\exists\sigma\ &\mcC\sigma\subseteq\mcD
	% 	\tag*{clause \(\mcC \) subsumes clause \( \mcD \)}
	% 	\end{align*}
	% \end{definition}

\input{samples/termindexing}







\subsection{Clashing literals}

\subsection{Variants}

\subsection{Instances}

\subsection{Subsumption}



