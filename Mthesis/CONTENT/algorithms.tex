% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Implementation}

\chapter{Algorithms and Data Structures}

\section{Terms, Literals and Clauses}




\section{Given Clause Algorithm}

In the previous chapter we just randomly applied derivation rules
on pairs of clauses from the set of clauses 
to derive and add new clauses 
until we could conclude unsatisfiability of the set of clauses.

In this section we will discuss the given clause algorithm 
as a saturation process that eventually determines all possible derivate clauses
with respect to a given calculus, e.g. resolution.


Let $S=\{\, \mP(\ma)\lor\mQ(a), \mP(\ma)\lor\lnot\mQ(y), \lnot\mP(x) \,\}$.

In the following examples the given clause is boxed, 
the active clauses are on the left of the given clause, 
and the passive clauses are on the right.

\begin{example}[Ordered Resolution] $\mP(\ma)\succ\mQ(\ma)$
	
	\begin{align*}
	^{1:}&\boxed{\mP(\ma)\lor\mQ(a)} & ^{2:}&\mP(\ma)\lor\lnot\mQ(y) & ^{3:}&\lnot\mP(x) 
	\\
	^{1:}&\mP(\ma)\lor\mQ(a) & ^{2:}&\boxed{\mP(\ma)\lor\lnot\mQ(y)} & ^{3:}&\lnot\mP(x) 
	\\
	^{1:}&{\colLo\mP(\ma)}\lor\mQ(a) & ^{2:}&{\colLo\mP(\ma)}\lor\lnot\mQ(y) & ^{3:}&\boxed{\lnot\mP(x)} 
	& ^{1,3:}&\mQ(\ma) & ^{2,3:}&\lnot\mQ(y)
	\\
	^{1:}&\mP(\ma)\lor\mQ(a) & ^{2:}&\mP(\ma)\lor{\colLo\lnot\mQ(y)} & ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\boxed{\mQ(\ma)} & ^{2,3:}&\lnot\mQ(y) & ^{2,(1,3):}&\mP(\ma)
	\\
	^{1:}&\mP(\ma)\lor{\colLo\mQ(a)} & ^{2:}&\mP(\ma)\lor\lnot\mQ(y) & ^{3:}&\lnot\mP(x)
	& ^{1,3:}&\colLo\mQ(\ma) & ^{2,3:}&\boxed{\lnot\mQ(y)} & ^{2,(1,3):}_{1,(2,3):}&\mP(\ma)
	& ^{(1,3),(2,3):}&\emptyclause
	\\
	\end{align*}
\end{example}


\begin{example}[InstGen]The active and given clauses are already encoded and given to a \SAT solver.
	A naive given clause algorithm would fail because step four changes the model, 
	but the clash is between newly selected literals of already active clauses.
	
	\begin{align*}
	(1)\quad^{1:}&\boxed{\mP(\ma)\lor\mQ(a)} & ^{2:}&\mP(\ma)\lor\lnot\mQ(y) & ^{3:}&\lnot\mP(x)
	\\
	(2)\quad^{1:}&{\colHi\mP(\ma)}\lor\mQ(a) & ^{2:}&\boxed{\mP(\ma)\lor\lnot\mQ(y)} & ^{3:}&\lnot\mP(x) 
	\\
	(3)\quad^{1:}&{\colHi\mP(\ma)}\lor\mQ(a) & ^{2:}&{\colHi\mP(\ma)}\lor\lnot\mQ(y) & ^{3:}&\boxed{\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\lnot\mP(\ma)
	\\
	(4')\quad
	^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(a) & ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(y) & ^{3:}&{\colHi\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\boxed{\lnot\mP(\ma)}
	\\
	(4)\quad^{3:}&{\colHi\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\boxed{\lnot\mP(\ma)}
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(a) & ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(y)
	\\
	(5)\quad^{3:}&{\colHi\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\colHi\lnot\mP(\ma)
	& ^{1:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\mQ(a)} & ^{2:}&{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(y)
	\\
	(6)\quad^{3:}&{\colHi\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\colHi\lnot\mP(\ma)
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(a) & ^{2:}&\boxed{{\colLo\mP(\ma)}\lor\colHi\lnot\mQ(y)}
	& ^{2(1):}&\mP(\ma)\lor\lnot\mQ(\ma)
	\\
	(7)\quad^{3:}&{\colHi\lnot\mP(x)} 
	& ^{1,3:}_{2,3:}&\colHi\lnot\mP(\ma)
	& ^{1:}&{\colLo\mP(\ma)}\lor\colHi\mQ(a) & ^{2:}&{\colLo\mP(\ma)\lor\colHi\lnot\mQ(y)}
	& ^{2(1):}&\boxed{\mP(\ma)\lor\lnot\mQ(\ma)}
	\end{align*}
\end{example}

\section{Term Indexing}

\subsection{Clashing literals}

\subsection{Variants}



