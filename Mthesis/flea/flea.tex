% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{FLEA}

\input{epigraphs/faust}

In this chapter we introduce \verb|FLEA| --
our {\textbf f}irst order {\textbf l}ogic with {\textbf e}quality theorem {\textbf a}ttester. 
It is 
-- as the reader may allready suspect --
a modest implementation of an instantiation based theorem prover for first order clauses with equality.

%We disucss its general architecture and elaborate on some implementation details.


\section{Data struture}

\begin{lstlisting}[language=flea]{Simplified defintion of general terms}}
protocol Node: Hashable {
	associatedtype Symbol : Hashable
	var symbol: Symbol { get set }
	var nodes: [Self]? { get set }
}
\end{lstlisting}

\section{Encodings}

\begin{figure}
	test
\end{figure}

We can simply encode first order atoms purely propositional 
when we construct the name for the propositional atom 
from a predicate or equation recursivly.

\begin{definition}
\DEFINE{\xi(\mct)}{
	\mc_0 &\text{if } \mct=x\in\mcV, \mc_0\not\in\mcF 
	\tag*{}\\
	\mc &\text{if } \mct=c\in\mcFn[0]\\
	\mcf\dis\xi(t_1)\dis\ldots\dis\xi(t_n) &\text{if }\mct=\mcf(t_1,\ldots,t_n), \mcf\in\mcFn
}
\end{definition}

\begin{example}
	\begin{align*}
	\xi(\mpp(f(x,y),g(y)) &= \mpp\dis\mf\dis\bot\dis\bot\dis\mg\dis\bot\\
	\xi(\mf(x,y)\mEQ \mg(y)) &= {\mEQ}\dis\mf\dis\bot\dis\bot\dis\mg\dis\bot\\
	\end{align*}
\end{example}

\DEFINE{\Xi(\mct)}{
	\mc_0 : U &\text{if } \mct=x\in\mcV, \mc_0\not\in\mcFn[0]  
	\\
	\mc  : U &\text{if } \mct=c\in\mcFfn[0]
	\\
	\mf
	: (U^n\rightarrow U)\ \Xi(t_1)\ \ldots\ \Xi(t_n)
	&\text{if }\mct=\mf(t_1,\ldots,t_n), \mf\in\mcFfn 
	\\
	\mP  : \mathsf{Bool} &\text{if } \mct=p\in\mcFPn[0]
	\\
	\mP
	: (U^n\rightarrow \mathsf{Bool})\ \Xi(t_1)\ \ldots\ \Xi(t_n)
	&\text{if }\mct=\mP(t_1,\ldots,t_n), \mP\in\mcFPn 
}

\begin{lstlisting}[language=FLEA]{Propositional encoding}
func encodeSAT<N:Node>(term: N) -> term_t {
	switch n.symbol.type {
		case .negation:
			return yices_not( encode( term.nodes!.first!) )
		
		case .predicate, .equation:
			return typedSymbol( $\xi$(term), term_tau: boolType)
	}	
}
\end{lstlisting}

\begin{lstlisting}[language=FLEA]{EUF encoding}
func encodeEUF<N:Node>(term: N) -> term_t {
	switch term.symbol.type {
	case .negation:
		return yices_not( encodeEUF( term.nodes.first!) )

	case .predicate:
		return application(term.symbol, nodes:term.nodes!, term_tau: boolType)
		
	case .equation:
		return typedSymbol( $\xi$(term), term_tau: boolType)
	}	
}
\end{lstlisting}


\begin{lstlisting}[language=flea]{Yices types, symbols, and constants}
let boolType : type_t = yices_bool_type(void)

let freeType : type_t = yices_new_uninterpreted_type(void)
yices_set_type_name(freeType, "$\tau$") // pretty printing

func typedSymbol(_ symbol: String, term_tau: type_t) -> term_t {
	var t = yices_get_term_by_name(symbol)
	if t == NULL_TERM {
		t = yices_new_uninterpreted_term(term_tau)
		yices_set_term_name(t, symbol)
	}
	return t
}

func constant(_ symbol: String, term_tau: type_t) -> term_t {
	return typedSymbol(symbol, term_tau: term_tau)
}
\end{lstlisting}




\subsection{QF\_EUF}

\begin{lstlisting}[language=flea]
func domain(_ count: Int, tau: type_t) -> [type_t] {
	return [type_t](repeating: tau, count: count)
}
\end{lstlisting}

\begin{lstlisting}[language=flea]
func function(_ symbol: String, 
		domain: [type_t], range: type_t) -> term_t {
	let f_tau = yices_function_type(UInt32(domain.count), domain, range)
	return typedSymbol(symbol, term_tau: f_tau)
}
\end{lstlisting}

\begin{lstlisting}[language=flea]
func application(_ symbol: String, 
			args: [term_t], term_tau: type_t) -> term_t {
	let f = function(symbol, 
	domain:domain(args.count, tau:Yices.free_tau), range: term_tau)
	return yices_application(f, UInt32(args.count), args)
}
\end{lstlisting}





\section{Implentation}


\section{Experiments}