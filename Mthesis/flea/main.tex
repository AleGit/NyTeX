% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{FLEA}

\input{epigraphs/faust}

In this chapter we introduce \verb|FLEA| --
First order Logic with Equality theorem Attester. 
It is 
-- as the reader may allready suspect --
a modest implementation of an instantiation based theorem prover for first order clauses with equality.

%We disucss its general architecture and elaborate on some implementation details.


\section{Data struture}

\begin{lstlisting}[language=flea]{Simplified defintion of general terms}}
protocol Node: Hashable {
	associatedtype Symbol : Hashable
	var symbol: Symbol { get set }
	var nodes: [Self]? { get set }
}
\end{lstlisting}

\section{Yices encodings}

We can simply encode first order atoms purely propositional 
when we construct the name for the propositional atom 
from a predicate or equation recursivly.

\DEFINE{\xi(\mct)}{
	\bot &\text{if } \mct=x\in\mcV \\
	\mc &\text{if } \mct=c\in\mcFO\\
	\mcf,\xi(t_1),\ldots,\xi(t_n) &\text{if }\mct=\mcf(t_1,\ldots,t_n), \mcf\in\mcFn
}

\begin{example}
	\begin{align*}
	\xi(\mpp(f(x,y),g(y) &= \mpp,\mf,\bot,\bot,\mg,\bot\\
	\xi(\mf(x,y)\mEQ \mg(y) &= {\mEQ},\mf,\bot,\bot,\mg,\bot\\
	\end{align*}
\end{example}

\begin{lstlisting}[language=FLEA]{Propositional encoding}
func encodeSAT<N:Node>(term: N) -> term_t {
	switch n.symbol.type {
		case .negation:
			return yices_not( encode( term.nodes!.first!) )
		
		case .predicate, .equation:
			return typedSymbol( $\xi$(term), term_tau: boolType)
	}	
}
\end{lstlisting}

\begin{lstlisting}[language=FLEA]{EUF encoding}
func encodeEUF<N:Node>(term: N) -> term_t {
	switch term.symbol.type {
	case .negation:
		return yices_not( encodeEUF( term.nodes.first!) )

	case .predicate:
		return application(term.symbol, nodes:term.nodes!, term_tau: boolType)
		
	case .equation:
		return typedSymbol( $\xi$(term), term_tau: boolType)
	}	
}
\end{lstlisting}


\begin{lstlisting}[language=flea]{Yices types, symbols, and constants}
let boolType : type_t = yices_bool_type(void)

let freeType : type_t = yices_new_uninterpreted_type(void)
yices_set_type_name(freeType, "$\tau$") // pretty printing

func typedSymbol(_ symbol: String, term_tau: type_t) -> term_t {
	var t = yices_get_term_by_name(symbol)
	if t == NULL_TERM {
		t = yices_new_uninterpreted_term(term_tau)
		yices_set_term_name(t, symbol)
	}
	return t
}

func constant(_ symbol: String, term_tau: type_t) -> term_t {
	return typedSymbol(symbol, term_tau: term_tau)
}
\end{lstlisting}




\subsection{QF\_EUF}

\begin{lstlisting}[language=flea]
func domain(_ count: Int, tau: type_t) -> [type_t] {
	return [type_t](repeating: tau, count: count)
}
\end{lstlisting}

\begin{lstlisting}[language=flea]
func function(_ symbol: String, 
		domain: [type_t], range: type_t) -> term_t {
	let f_tau = yices_function_type(UInt32(domain.count), domain, range)
	return typedSymbol(symbol, term_tau: f_tau)
}
\end{lstlisting}

\begin{lstlisting}[language=flea]
func application(_ symbol: String, 
			args: [term_t], term_tau: type_t) -> term_t {
	let f = function(symbol, 
	domain:domain(args.count, tau:Yices.free_tau), range: term_tau)
	return yices_application(f, UInt32(args.count), args)
}
\end{lstlisting}





\section{Implentation}


\section{Experiments}