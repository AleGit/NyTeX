% !TeX root = ../mythesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Completeness}

In the previous chapter we stated some calculi
that has been used for the implementation
of automated theorem provers.
%
It was easy to see that Gilmore`s prover is theoretically complete,
but practically very inefficient.
Additionally it would not stop for clearly satisfiable and simple sets of clauses.
While it seams intuitive that resolution is complete
--- we search for all clashing literals between clauses and resolve them ---
it is puzzling that ordered resolution and then superposition are indeed complete.
At first sight we would expect that all these restrictions
lead to ignoring important inferences.

A small set of rules and strict conditions for the application of a rule
could improve the efficiency of a procedure, but undermine the completeness
of the procedure, e.g.~an empty calculus,
i.e.~a calculus without any rules,
is obviously sound and very efficient, but not complete.

So for every set of sound inference rules the question remains
how far can we restrict them and still claim
that a set of clauses is satisfiable when no rule is applicable any more.





% We want to restrict our calculus as far as possible,
% such that there is a chance of termination

% As we have already seen in examples \InstGenEQ{}
% may terminate for a set of clauses without finding
% a unsatisfiable set of ground instances.
% We have claimed that in this case the set of clauses is satisfiable.

In the first Section~\vref{sec:unit:paramodulation:closures}
we state unit paramodulation for literal closures.
In Section~\vref{sec:inst:saturated:sets} we present
an untangled version of the proof of satisfiability
of saturated sets of closures
from the literature~\cite{GK2004csl}.
After that we look a saturation strategies in
Section~\vref{sec:saturation:strategies}
and finally we apply the completeness result to \InstGenEQ{}
in Section~\vref{sec:lifting}.

% Section~\vref{sec:inst:saturation:process},
% Section~\vref{sec:inst:process:fairness}.


\section{Unit paramodulation on literal closures}\label{sec:unit:paramodulation:closures}

\begin{definition}
    A closure is a pair of a clause \( C \) and a substitution \( \sigma \),
    conveniently written as \( C\cdot\sigma \). Two closures \( C\cdot\sigma = D\cdot\tau \)
    are the same if \( C \) is a variant of \( D \) and \( C\sigma \) is a variant of \( D\tau \).
    A closure \( C\cdot\sigma \) represents a clause \( C\sigma \),
    i.e.~the result of applying substitution \( \sigma \) to \( C \).
    A ground closure represents a ground clause.
\end{definition}

For the following definitions we assume
\( \succG \) as a a total, well-founded and monotone extension
from a total simplification ordering on ground terms
to ground literal and clauses~\cite{NR2001},
which always exists.


\begin{definition}
	% 4.3
    We define an order \( \succL \) on ground closures of literals
    as an arbitrary total well-founded extension of \( \succG \)
    such that
    \( L\cdot\sigma\succL L'\cdot\sigma' \) whenever
    \( L\sigma\succG L'\sigma' \).

	% 5.1
    We define an order \( \succC \) on ground closures
    as an arbitrary total well-founded extension of
    \( \succC' \) --- an inherently well-founded order defined as extension of \( \succG \)
    such that
    \( C\cdot\tau\succC' D\cdot\rho \) whenever
    \( C\tau\succG D\rho \) or \( C\theta = D \) for an proper instantiator \( \theta \).
\end{definition}

\begin{remark}
    In summary we assume \( \succG \), \( \succL \), \( \succC \) as
        total, well-founded, and monotone extensions of a
        total simplification order \( \succ \)
        over ground terms to ground (literal) clauses
        and ground (literal) closures
        such that the following properties hold
       \begin{align*}
            s\sigma\mNE t\sigma \quad&\succG\quad s\sigma\mEQ t\sigma
           &
           L\sigma \succG L'\sigma'
           \quad&\Rightarrow\quad
            L\cdot\sigma \succL L'\cdot\sigma'
           \\
            L\sigma\lor C\sigma \quad&\succG\quad L\sigma
       &
       \left.
       \begin{array}{r}
        C\tau=D\rho, C\theta=D
        \\
        \text{or } C\tau\succG D\rho
    \end{array}
       \right \}
           \quad&\Rightarrow\quad
            C\cdot\tau\succC{} D\cdot\rho{}
       \end{align*}
        for arbitrary terms \( s,t \),
        literals \( L, L' \),
        clauses \( C,D \),
        ground substitutions \( \sigma, \tau, \rho \),
        and instantiator \( \theta \).
        Note that the order on unit closures is slightly different than on literal closures, e.g.:
       \begin{align*}
            (\mf(x)\mEQ x)\cdot \{ x\mapsto \ma \}
            &\succC
            (\mf(\ma)\mEQ\ma)\cdot\emptyset
            & \theta = \{ x\mapsto \ma \}
       \\
        (\mf(x)\mEQ x)\cdot \{ x\mapsto \ma \}
        &\not\succL
        (\mf(\ma)\mEQ\ma)\cdot\emptyset
       \end{align*}
\end{remark}

\begin{definition}[Unit paramodulation for literal closures~\cite{GK2004csl}]\label{def:unit:paramodulation}
   \input{SNIPPETS/UPI}
    where
   \input{SNIPPETS/UPC}
   \end{definition}

   \begin{example}
        Let \( \mf(s,t,u)\succG\mg(s') \) for all ground terms
       \( r,s,t,s' \).
        % \( \succ_{kbo} \) order on terms.
       \begin{gather*}
           \infer[\theta]{
               \left(
                   \mh(\underbrace{
                       \boxed{\mg(x')}
                        }_{r\theta})\mNE\mg(x')
                   \right)\cdot\rho
            }{
               \left(
                   \overbrace{\mf(x,y,\mc)}^{\ell}
                   \mEQ
                   \overbrace{\mg(x)}^r
               \right)\cdot \sigma
            & \left(
               \mh(\overbrace{
                   \boxed{\mf(x',\mh(y'), z')}
                    }^{\ell'})\mNE\mg(x')
               \right)\cdot \sigma'
            }
       \end{gather*}
       \begin{align*}
           \sigma &= \{x\mapsto\ma, y\mapsto\mh(\mb)\} &
            \sigma' &= \{x'\mapsto\ma, y'\mapsto\mb, z'\mapsto\mc \}
            \\
            \theta &= \{x\mapsto x',y\mapsto\mh(y'),z'\mapsto\mc \}
              &
            \rho &=\{ x'\mapsto \ma, y'\mapsto \mb \}
            \\
            \ell'\theta &= \mf(x',\mh(y'),\mc)
             &
            \ell'\theta\rho &= \mf(\ma, \mh(\mb), \mc) = \ell\sigma = \ell'\sigma'
       \end{align*}
   \end{example}


   \begin{lemma}
        Let \( R \) be a ground rewrite system and UP is applicable to
       \( (l\mEQ r)\cdot\sigma, L[l']\cdot\sigma' \)
        with conclusion
       \( L[r]\theta\cdot\rho \).
        If \( \sigma,\sigma' \) are irreducible w.r.t.~R then \( \rho \) is irreducible w.r.t.~R.
   \end{lemma}

   \begin{proof}
        Assume otherwise.
        Hence there is a \(
            x\in\var(l'\theta)
        \) such that
       \( x\theta\rho \) is reducible by \(
            R
            \).

   \end{proof}

           \begin{example}
        The set of literal closures
       \( \{ \,
        (\mf(x)\mEQ\mb)\cdot \{ x\mapsto\ma \}, \,
       \ma\mEQ \mb, \,
       \mf(\mb)\mNE\mb \,
       \} \) is inconsistent,
        but the empty clause is not derivable
        if \( \ma\succG\mb \).
           \end{example}

\section{Satisfiability of saturated sets}\label{sec:inst:saturated:sets}

In this section we will define saturated set of literal closures
with respect to unit paramodulation.
Additionally we will show that a saturated set of literal closures
is satisfiable if and only if its grounding is satisfiable.

   \begin{definition}[UP-Redundancy]
        Let \( \mcL \) be a set of literal closures. We define
       \begin{itemize}
           \item \( \IRRED_R(\mcL) =
           \{ \,
            L\cdot\sigma\in\mcL \mid
           \sigma\text{ is irreducible w.r.t.~}R
           \, \} \)

        for an arbitrary ground rewrite system \( R \)

       \item
       \(
       \mcL_{L\cdot\sigma\succL} =
       \{ \,
        L'\!\cdot\sigma'\in\mcL \mid
        L\cdot\sigma\succL L'\cdot\sigma'
       \, \}
         \).

       \item Literal closure \( L\cdot\sigma \) is UP-redundant in \( \mcL \) if

       \begin{gather*}
            % cspell:disable
            R \cup irred_R(\mcL_{L\cdot\sigma\succL}) \vDash L\sigma
            % cspell:enable
       \end{gather*}
        for every ground rewrite system \( R \)

        oriented by \( \succG \)
        where \( \sigma \) is irreducible w.r.t.~\( R \).

       \item
       \( \mcR_{UP}(\mcL) \) denotes the set of all UP-redundant closures in \( \mcL \).
   \end{itemize}
\end{definition}

   \begin{definition}[UP-Saturation]

            The UP-{saturation process}
            is a sequence \( {\{ \mcL_i \}}_{i=0}^\infty \)
            where \( \mcL_{i+1} \) is constructed from \( \mcL_i \)
            by removing redundant literal closures in \( \mcL_i \)
            or by adding inferences of \( \mcL_i \) until saturation.
           \begin{gather*}
           \mcL_{i+1} = \left \{
                   \begin{array}{lclc}
                       \mcL_i \backslash L\cdot\sigma
                        &\text{if}
                        &R \cup \IRRED_R(\mcL_{i,L\cdot\sigma\succL}) \entails L\sigma
                       \\
                       \\
                       \mcL_i \cup \, \emptyclause
                        &\text{if}
                        &\left \{ \begin{array}{l}
                            (s\mNE t)\cdot\tau\in\mcL_i
                           \\
                            s\tau = t\tau,\,
                           \mu=\mgu(s,t)
                       \end{array}\right.
                       \\
                       \\
                       \mcL_i \cup{} \, L[r]\theta\cdot\rho{}
                        &\text{if}
                        &\left \{ \begin{array}{l}
                            (\ell\mEQ r)\cdot\sigma,\,
                            L[\ell']\cdot\sigma'\in\mcL_i
                           \\
                           \ell\sigma\succG r\sigma,\,
                           \theta=\mgu(\ell,\ell'),
                           \\
                           \ell'\notin\mcV,\,
                           \ell\sigma = \ell'\sigma' = \ell'\theta\rho,
                       \end{array}\right.
                       \\
                       \\
                       \mcL_i
                        &&\text{otherwise}
                   \end{array}
               \right.
               \end{gather*}

            The set of persistent closures \( \mcL^\infty \) is the lower limit of \( \mcL_i \).

            % i.e.~the lower limit of the sequence.
   \end{definition}
   \begin{definition}[UP-Fairness]

            The UP-saturation process is {UP-fair} if for every UP-inference
            with premises in \( \mcL^\infty \) the conclusion is UP-redundant
            w.r.t.~\( \mcL_j \) for some \( j \).
   \end{definition}
   \begin{definition}

            For a set of literals \( \mcL \) we define
            the saturated set of literal closures
           \( \mcL^{sat} = \mcL^\infty\backslash\mcR_{UP}(\mcL^\infty) \)
            for some UP-saturation process
           \( {\{ \mcL_i \}}_{i=0}^\infty \)
            with \( \mcL_0 = \mcL \).
   \end{definition}


       \begin{lemma}
        The set \( \mcL^{sat} \) is unique because
        for any two UP-fair saturation processes
        \( {\{ \mcL_i \}}_{i=0}^\infty \) and
        \( {\{ \mcL'_i \}}_{i=0}^\infty \)
        with \( \mcL_0 = \mcL'_0 \) we have
        \begin{gather*}
            \mcL^\infty \backslash \mcR_{UP}(\mcL^\infty)
            =
            \mcL'^\infty \backslash \mcR_{UP}(\mcL'^\infty)
        \end{gather*}
       \end{lemma}

\begin{definition}[Inst-Redundancy]\label{def:inst:redundant}

    Let \( S \) be a set of clauses.

   \begin{itemize}
       \item A ground closure \( C \) is Inst-redundant in \( S \)
        if for some \( k \)
        % consequence of smaller ground instances \( C_1,\ldots,C_k \) of \( S \), i.e.~
       \begin{itemize}
           \item \( C'_i\in S \), \( C_i=C'_i\cdot\sigma'_i \), \( C\succC C_i \) \hfill for \( i\in 1\ldots k \)
           \item such that \( C_1,\ldots,C_k\models C \)
       \end{itemize}

       \item
        A (possible non-ground) clause \( C \) is called Inst-redundant in \( S \)

    if each ground closure \( C\cdot\sigma \) is Inst-redundant in \( S \).


   \item
   \( R_{Inst}(S) \) denotes the set of all Inst-redundant clauses in \( S \).


   \end{itemize}

\end{definition}

\begin{example}
   \( S =
       \{ \,
       \mf(x)\mEQ x,\,
       \mf(\ma)\mEQ \ma,\,
       \mf(\mf(x))\mEQ\mf(x)
       \,  \)

   \( R_{Inst}(S) = \{ \, \mf(\mf(x))\mEQ\mf(x) \, \} \)
   \end{example}

   \begin{definition}[S-Relevance]
        Let \( S \) be a set of clauses \( S \), let \( I_\bot \) be a model of \( S\bot \).

       \begin{itemize}
           \item
        A selection function \( \sel \) maps clauses to literals such that
       \begin{align*}
           \sel(C)&\in C
            &&&
            I_\bot&\models\sel(C)\bot
       \end{align*}

       \item
        The set of \( S \)-relevant literal closures
       \begin{align*}
           \mcL_S &= \left \{ \, L\cdot\sigma \mid
           \begin{array}{l}
                L\lor C\in S,\,L = \sel(L\lor C)\\
                (L\lor C)\cdot\sigma\text{ is not Inst-redundant in S},\\
           \end{array}
           \, \right \}
       \end{align*}




   \end{itemize}
\end{definition}

\begin{definition}[Inst-Saturation]
    Let \( \mcL_S^{sat} \) denote the saturation process of \( \mcL_S \).
    Then a set of clauses \( S \) is Inst-saturated w.r.t.~a selection function \( \sel \),
            if \( \mcL_S^{sat} \) does not contain the empty literal clause.
\end{definition}

       \begin{theorem}\label{theorem:inst:saturated:satisfiable}
        If a set of clauses \( S \) is Inst-saturated,
        and \( S\bot \) is satisfiable,

        then \( S \) is also satisfiable.
       \end{theorem}

       \begin{proof} We assume that \( S \) is not satisfiable.
           \begin{enumerate}
               \item We construct a candidate model \( \mcI \) in Definition~\vref{def:candidate:model:construction}.
               \item We can show that \( \mcI \) is a model by Lemma~\vref{lemma:model:is:candidate}.

                That contradicts our assumption.
           \end{enumerate}
            We discard our assumption and conclude that \( S \) is satisfiable.
           \end{proof}

   \begin{definition}[{Candidate Model Construction}]\label{def:candidate:model:construction}

        Let \( S \) be an Inst-saturated set of clauses,
        i.e.~\( \emptyclause\not\in\mcL_S^{sat} \), SAT\( (S\bot) \).

        Let \( L = L'\cdot\sigma \in\mcL_S^{sat} \).
        We define inductively:

           \begin{itemize}
               \item \( I_L = \{ \, \epsilon_M\mid L\succL M \, \} \)
               \hfill  IH:~\( \epsilon_M \) is defined for any \( M\mid L\succL M \)

               \item \( R_L = \{ s \to t \mid s\mEQ t\in I_L, s\succG t \} \)

                   \item \( \epsilon_L = \left \{
                       \begin{array}{cll}
                           \emptyset &\text{if }
                            L'\sigma\text{ reducible by }R_L
                           \\
                           \emptyset &\text{if }
                            I_L\vDash L'\sigma
                           \text{ or }
                            I_L\vDash \overline{L'}\sigma
                            &\text{(defined)}
                           \\
                           \{ L'\sigma \}
                            &\text{otherwise}
                            &\text{(productive)}
                       \end{array}
                   \right. \)

               \item
               \( R_S = \bigcup_{L\in\mcL_S^{sat}} R_L \)
               \hfill
               \( R_S \) is convergent and interreduced

               \item
               \( I_S = \bigcup_{L\in\mcL_S^{sat}} \epsilon_L \)
               \hfill
               \( I_S \) is consistent,
               \( L\sigma\in I_S \) is irreducible by \( R_S \)
           \end{itemize}
       \end{definition}

            Let \( \mcI \) be an arbitrary consistent extension of \( I_S \)

            in all the following lemmata.


       \begin{lemma}\label{existence}

        If any \( L\cdot\sigma\in\mcL_S \), irreducible by \( R_S \) exists with \( \mcI\not\models L\sigma \)

        then there is a \( L'\cdot\sigma'\in \IRRED_{R_S}(\mcL_S^{sat}) \) with \( \mcI\not\models L'\sigma' \).
       \end{lemma}

       \begin{proof}
            We have two cases

       \begin{itemize}
           \item If \( L\cdot\sigma \) is not UP-redundant in \( \mcL_S^{sat} \),
            then \( L'\cdot\sigma'=L\cdot\sigma \).
           \hfill\checkmark{}

           \item If \( L\cdot\sigma \) is UP-redundant in \( \mcL_S^{sat} \).
        By construction \( \sigma \) is irreducible by \( R_S \). Then we have
       \begin{align*}
            R_S \cup \IRRED_{R_S}(
               \{
                L'\cdot\sigma'\in\mcL_S^{sat}
               \mid
                L\cdot\sigma \succL L'\cdot\sigma'
               \}
            )
           \models
            L\sigma
       \end{align*}
        % At least one \( L'\cdot\sigma'\in \IRRED{R_S}(\mcL_S^{sat}) \)
        with \( \mcI\not\models L'\sigma' \).
       \hfill \checkmark{}
       \end{itemize}
   \end{proof}


       \begin{lemma}\label{irreducible}
            Whenever
           \begin{gather*}
                M\cdot\tau = \min_{\succL}\!
               \left \{ \,
                L'\cdot\tau' \mid
                L'\cdot\sigma' \in \IRRED_{R_S}(\mcL_S^{sat}), \,
                L'\sigma'\text{ false in }\mcI \,
               \right \}
           \end{gather*}
            is defined, then \( M\cdot\tau \) is irreducible by \( R_S \).
       \end{lemma}

       \begin{proof}
            Assume \( M\cdot\tau \) is reducible by \( (\ell\to r)\in R_S \)

            and \( (\ell\to r) \) is produced by \( (\ell'\mEQ r')\cdot\rho\in\mcL_S^{sat} \).

           \vspace{0.7em}
            Now UP-inference is applicable because \( \tau \) is irreducible by \( R_S \),
           \begin{gather*}
               \infer[UP]
                {M[r']\theta\cdot\mu}
                {(\ell'\mEQ r')\cdot\rho & M[\ell'']\cdot\tau}
           \end{gather*}
           \( \mu \) is irreducible by \( R_S \), and \( M[r']\theta\mu \){ is false in }\( \mcI \).
           \hfill\ldots

        We have two cases

           \begin{itemize}
               \item If \( M[r']\theta\cdot\mu \) is not UP-redundant in \( \mcL_S^{sat} \)
                then \( M[r']\theta\cdot\mu\in\mcL_S^{sat} \).

               \vspace{0.3em}
                Now \( M\cdot\tau\succL
                M[r']\theta\cdot\mu\in \IRRED_{R_S}(\mcL_S^{sat}) \)

                contradicts minimality of \( M\cdot\tau \).
               \hfill
               \vspace{0.3em}

               \item If \( M[r']\theta\cdot\mu \) is UP-redundant in \( \mcL_S^{sat} \) then
               \vspace{-0.3em}
               \begin{gather*}
                    R_S \cup \IRRED_{R_S}
                   \{
                        M'\cdot\tau'\in\mcL_S^{sat}\mid
                        M[r']\theta\cdot\mu \succL M'\tau'
                       \} \models M[r']\theta\mu
               \end{gather*}
                Hence there is \( M'\cdot\tau'\in\mcL_S^{sat} \) false in \( \mcI \) such that
               \( M\cdot\tau\succL M[r']\theta\cdot\mu\succL M'\cdot\tau' \),

               \( M'\cdot\tau' \) contradicts minimality of \( M\cdot\tau \).
               \hfill

           \end{itemize}

            Hence \( M\cdot\tau \) is irreducible by \( R_S \).
           \hfill\qed{}
       \end{proof}





       \begin{lemma}\label{equation}
            Let \( M\cdot\tau\in\mcL_S^{sat} \),
            irreducible by \( R_S \), and defined (not productive).

            From \( \mcI\not\models M\tau \) follows that \( M \) is not an equation \( (s\mEQ t) \).

       \begin{proof}
            Assume \( M = (s\mEQ t) \). Then we have
           \begin{itemize}
               \item \( I_{M\cdot\tau}\models (s\mNE t)\tau \)
               \item All literals in \( I_{M\cdot\tau} \) are irreducible by \( R_{M\cdot\tau} \)
               \item \( s\tau \) and \( t\tau \) are irreducible by \( R_{M\cdot\tau} \)
               \item \( R_{M\cdot\tau} \) is a convergent term rewrite system
           \end{itemize}
            Hence \( (s\mNE t)\tau\in I_{M\cdot\tau} \)
            is produced to \( I_{M\cdot\tau} \) by some \( (s'\mNE t')\cdot\tau' \),

            but \( (s'\mNE t')\tau'\succG (s\mEQ t)\tau \)
            and \( (s'\mNE t')\cdot\tau'\succL M\cdot\tau \).
           \hfill

       \end{proof}
       \end{lemma}


       \begin{lemma}\label{inequation}
            Let \( M\cdot\tau\in\mcL_S^{sat} \),
            irreducible by \( R_S \), and defined (not productive).

            From \( \mcI\not\models M\tau \) follows that \( M \) is not an inequation \( (s\mNE t) \).
           \begin{proof}
            Assume \( M\cdot\tau \) is inequation \( (s\mNE t)\cdot\tau \). We have
           \begin{itemize}
               \item \( I_{M\cdot\tau}\models (s\mEQ t)\tau \)
               \item \( s\tau \) and \( t\tau \) are irreducible by \( R_{M\cdot\tau} \)
           \end{itemize}
            Hence \( s\tau = t\tau \) and equality resolution is applicable.

            Contradiction to \( \emptyclause\not\in\mcL_S^{sat} \).
           \hfill

       \end{proof}
       \end{lemma}




       \begin{lemma}\label{lemma:model:is:candidate}
           \( \mcI \) is a model for all ground instances of \( S \)
       \end{lemma}

       \begin{proof}
            Assume \( \mcI \) is not a model.

            Hence a minimal ground closure \(
                D = \min_{\succC} \{ \,
                C'\cdot\sigma \mid C'\in S, \,
               \mcI\not\models C'\sigma \,
               \} \),
                an instance of a clause in \( S \),
               \( \false \) in \( \mcI \), must exist. Further on

       \begin{itemize}
           \item \( D = D'\cdot\sigma \) is not Inst-redundant.
           \vspace{0.2em}

            Otherwise by Definition~\ref{def:inst:redundant} there are
           \( D_1,\ldots,D_n\models D \), \( D\succC D_i \) for all \( i \),

            and \( D_j \) \( \false \) in \( \mcI \) for one \( j \), which contradicts minimality.
           \hfill

           \item \( x\sigma \) irreducible by \( R_S \) for every variable \( x \) in \( D' \).
           \vspace{0.2em}

            Otherwise let \( (\ell\to r)\tau\in R_L \) and \( x\sigma = x\sigma{[l\tau]}_p \) for some variable x in D'.
            We define substitution \( \sigma' \) with \( x\sigma' = x\sigma{[r\tau]}_p \) and \( y\sigma' = y\sigma \) for \( y\neq x \).
           \( D'\sigma' \) is false in \( \mcI \) and \( D\succC D'\cdot\sigma' \),
            which contradicts minimality.\hfill
       \end{itemize}

        Since \( D \) is not Inst-redundant in \( S \),
        we have for some literal \( L \),

        that \( D' = L\lor D'' \), \( \sel(D') = L \), \( L\cdot\sigma\in\mcL_S \),
       \( L\sigma \) is \( \false \) in \( \mcI \).
       \vspace{0.7em}

        Hence the following literal closure
       \begin{gather*}
            M\cdot\tau = \min_{\succL}\!
   \left \{ \,
        L'\cdot\tau' \mid
        L'\cdot\sigma' \in \IRRED_{R_S}(\mcL_S^{sat}), \,
       \mcI\not\models L'\cdot\sigma' \,
   \right \}
       \end{gather*}
        exists by Lemma~\ref{existence}, is irreducible by Lemma~\ref{irreducible},
        and is not productive.
        Since \( \mcI\not\models M\cdot\tau \) the literal
        M cannot be an equation by Lemma~\ref{equation}
        or an inequation by Lemma~\ref{inequation}.
        We have derived a contradiction from our only assumption.

        Therefore \( \mcI \) is a model for all instances of \( S \),
        hence
        % \( S \) is satisfiable and
        Theorem~\vref{theorem:inst:saturated:satisfiable} holds.
   \end{proof}

%    \IMPROVE{Section~\vref{sec:saturation:strategies}}

   \section{Saturation Strategies}\label{sec:saturation:strategies}

   So far we have only shown that a Inst-saturated set of clauses
   \( S \) is satisfiable if \( S\bot \) is satisfiable.
   Now we take a look at how Inst-saturation can be achieved
   starting from a set of clauses \( S^1 \).

   \begin{definition}
    An Inst-\coloremph{saturation process} is a sequence of triples
    \(
        {\{
            \langle
            S^i, I^{i}_{\!\bot}, \sel^i
            \rangle
            \}}_{i=1}^\infty
    \)
    where \( S^i \) is a set of clauses,
    \( I^{i}_{\!\bot} \) a model for \( S^i\bot \),
    and \( \sel^i \) a selection function based on that model.
%
    We try to go from a given state
    \( {\{ \langle S^i, I^{i}_{\!\bot}, \sel^i \rangle \}} \)
    to a successor state
    \( {\{ \langle S^{i+1}, I^{i+1}_{\!\bot}, \sel^{i+1} \rangle \}} \)
    by first performing one of the following steps
    \begin{itemize}
        \item
        \( S^{i+1} = S^i \cup N \)
        where \( N \) is a set of clauses such that
        \( S^i \entails N \)
        \item
        \( S^{i+1} = S^i \setminus \{ C \} \)
        where clause \( C \) is Inst-redundant in \( S^{i} \).
    \end{itemize}
\noindent If \( S^{i+1}\! \bot \) is unsatisfiable
the process terminates with result “unsatisfiable”.
Otherwise we build \( I^{\,i+1}_{\!\bot} \) and \( \sel^{\,i+1} \)
from \( S^{i+1}\!\bot \).
%
The set of persistent clauses \( S^\infty \) denotes the lower limit of \( {\{ S^i \}}_{i=1}^\infty \).
\end{definition}

\begin{definition}
    Let
    \( K = \{ (L_1\lor C_1)\cdot\sigma, \ldots, (L_n\lor C_n)\cdot\sigma \} \)
    be a finite set of closures
    of clauses from \( S^\infty \).
    Let \( \mcL = \{ L_1\cdot\sigma, \ldots, L_n\cdot\sigma \} \).
    The pair \( (K,L) \) is a \coloremph{permanent conflict} if
    \( \mcL^{sat} \) contains the empty clause
    and for infinitely many \( i \)
    we have \( \sel^i(L_j\lor C_j) = L_j \)
    for \( 1\leq j < n \).
    An Inst-saturation process is \coloremph{Inst-fair}
    if for every persistent conflict
    \( (K,L) \)
    at least one of the closures in \( K \)
    is Inst-redundant in \( S^i \) for some \( i \).
    \end{definition}

    \begin{lemma}
        Let \( S^\infty \) be a set of persistent clauses
        of an Inst-fair saturation process
        \( {\{ \langle S^i, {I\!_\bot}^i, \sel^i \rangle \}}_{i=1}^\infty \),
        and let \( S^\infty \! \bot \) be satisfiable.
        Then there exists a model \( I \! \bot \) of \( S^\infty \! \bot \)
        and a selection function \( \sel \) based on \( I \! \bot \)
        such that \(S^\infty \) is Inst-saturated w.r.t. \( \sel \).
    \end{lemma}

    \begin{proof} …
    \end{proof}


        In an \emph{Inst-fair} saturation process
        % \( { \{ \langle S^i, I^{i}_{\!\bot}, \sel^i \rangle \}}_{i=1}^\infty \)
        the set of ground instances
        \( S^i \! \bot \) is either satisfiable for all \( i \)
        or unsatisfiable for some \( i \).
        In the first case an Inst-saturated \( S^i \)
        with satisfiable \( S^i \! \bot \) proves satisfiability of \( S^1 \),
        while in the second case the first unsatisfiable \( S^i \! \bot \)
        provides evidence of the unsatisfiability of \( S^1 \).
%
    It remains to ensure that the Inst-saturation process is Inst-fair.


    We represent UP-proofs as binary trees.
    We label the nodes by closures
    and substitutions from the corresponding inferences.
    At each node we assume that the left proof branch
    is variable disjoint from the right proof branch
    (which can be achieved by variable renaming).
    We construct a \coloremph{P-relevant instantiator}
    of literal \( L \in \mcL \)
    as composition \( \theta = \theta_1\ldots\theta_k \)
    of the sequence of substitutions \( (\theta_i)_{i=1}^k \)
    along the path of length \( k \)
    from leaf \( L\cdot\sigma \)
    to the root of a proof \( P \).
    Further we construct the \coloremph{P-relevant instance}
    \( L\theta\cdot\tau \) from
    \( L \cdot \sigma \) with \( \theta \)
    with \( L\theta\tau = L\sigma \).


    \begin{lemma}
        Let \( \mcP \) be the set of all P-relevant instances
        of all leafs of a proof \( P \) of the empty clause.
        Then \( \mcP \bot \) is unsatisfiable.
    \end{lemma}

    \begin{corollary}
        Let \( (K, \mcL) \) be a persistent conflict
        and \( P \) a proof of the empty clause from \( \mcL \) in \( UP \),
        then at least one \(P\)-relevant instantiator is proper.
    \end{corollary}

    We make closures in \( K \)
    of a persistent conflict \( (K,\mcL) \)
    Inst-redundant by adding their P-relevant proper instances.
    We make and Inst-saturation process fair
    by UP-saturating literal closures from persisting conflicts
    and adding proper instantiations of clauses with substitutions
    gained from proofs of the empty clause.


    \section{Unit paramodulation for literals}\label{sec:lifting}

    \begin{definition}[Unit paramodulation for literals~\cite{GK2004csl}]\label{def:unit:paramodulation}
        \input{SNIPPETS/UPLI}
         where
        \input{SNIPPETS/UPLC}
        \end{definition}

    We construct P-relevant instantiators and P-relevant instances
    of literals \( L\sigma \) from proofs in UPL of the empty clause
    in the same way as above.

    \begin{lemma}
        Let \(Lit\) be a set of literals such that \( Lit\bot \) is satisfiable.
        Further let \( \mcL \) be a set of ground closures from \( Lit \)
        such that the empty clause is derivable in \( UP \) from \( \mcL \).
        Then there is a proof of the empty clause in \( UPL \) from \( Lit \)
        such that for at least one closure \( L \cdot \sigma \in \mcL \),
        P-relevant instance of \(L\) is \( L\theta \)
        where \( \theta \) is a proper instantiator
        and \( L\sigma = L\theta\tau \) for some ground substitution \( \tau \).
    \end{lemma}

    \section{InstGenEQ}

    So far \( \mathsf{UPLC} \) and \( \mathsf{UPL} \) only deal
    with equations but not with predicates.
    In this section we justify Definition~\vref{def:unit-superpositin-calculus}

    \begin{definition}
        For a given first order signature \( \mcF = \mcFfPE \).
        We derive a purely equational signature \( \mcF' \) from \( \mcF \):
        \[
            \mcF'_\mf = \mcFf
            \disjointunion
            \{ \mc_\top \}
            \disjointunion
            \{ \mf_{\mP_{\!i}} \mid \mP_{\!i} \in \mcFP \}
            \]
        such that \( \mc_\top \) is a constant function symbol,
        and \( \arity(\mf_{\mP_{\!i}}) = \arity(\mP_{\!i}) \) for all \( i \).

    \end{definition}

    \begin{definition}
        We translate any set of clauses over signature \( \mcF \)
        into a equisatisfiable and purely equational set of clauses over signature \( \mcF' \)
        by replacing predicates with equations.
        \begin{align*}
            T(S) &= \bigcup_{C\in S} T(C) &
            T(C) &= \bigcup_{L\in C} T(L) \\
            T(s\mEQ t) &= s\mEQ t &
            T(s\mNE t) &= s\mNE t \\
            T(\mP(t_1,\ldots,t_n)) &= \mf_\mP(t_1,\ldots,t_n)\mEQ\mc_\mP &
            T(\lnot\mP(t_1,\ldots,t_n)) &= \mf_\mP(t_1,\ldots,t_n)\mNE\mc_\mP \\
            % T(L) &= \left \{
            %     \begin{array}{ll}
            %         s \mEQ t \\
            %         s \mNE t \\
            %         \mf_\mP(t_1,\ldots,t_n) \mEQ \mc_\bot \\
            %         \mf_\mP(t_1,\ldots,t_n) \mNE \mc_\bot
            %     \end{array}
            %     \right.
            %     \tag{literal}
        \end{align*}
    \end{definition}

    % \begin{lemma}
    %     We can simulate all derivation rules of \InstGenEQ with unit paramodulation for literals.
    % \end{lemma}


    \begin{corollary}
        We can represent proofs in \InstGenEQ
        as proofs in unit paramodulation of literals.
    \end{corollary}

    \begin{proof}
        We simulate each derivation steps that uses a \InstGenEQ~rule
        by (partial) proof branches on translated literals.
        \begin{itemize}
            \item unit paramodulation
            \begin{gather*}
                \infer
                [  ]
                {(A[t]\mNE\mc_\top)\,\sigma}
                {s\mEQ t&A[s']\mNE\mc_\top}
                \qquad\qquad
                \infer
                [  ]
                {(A[t]\mEQ \mc_\top)\,\sigma}
                {s\mEQ t&A[s']\mEQ \mc_\top}
                \end{gather*}
            where \( \sigma=\mgu(s,s') \) is defined,
            \( s'\not\in\mcV \),
            \( (s\sigma)\theta\succ (t\sigma)\theta \)

            for some grounding substitution \( \theta \);

            \item unit superposition
            \begin{gather*}
            \infer
            [  ]
            {(u[t]\mNE v)\,\sigma}
            {s\mEQ t&u[s']\mNE v}
            \qquad\qquad
            \infer
            [  ]
            {(u[t]\mEQ v)\,\sigma}
            {s\mEQ t&u[s']\mEQ v}
            \end{gather*}
            where \( \sigma=\mgu(s,s') \) is defined,
            \( s'\not\in\mathcal{V}, \)
            \( s\sigma\theta\succ t\sigma\theta \),
            \( u[s']\sigma\theta\succ v\sigma\theta \)

            for some grounding substitution \( \theta \);

            \item unit equality resolution and unit resolution
            \begin{gather*}
                \infer
                [(\sigma)]
                {\emptyclause}
                {s\mNE t}
                \quad\quad\quad\qquad
                \infer[(\sigma)]
        {
            \infer[(\emptyset)]
            {\emptyclause}
            {\mc_\top \mNE \mc\top}
        }
        {A\mEQ\mc_\top & B\mNE\mc_\top}
                \end{gather*}
            where \( s \) and \( t \) (\( A \) and \( B \) respectively) are unifiable.
        \end{itemize}
    \end{proof}














