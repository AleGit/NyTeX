% !TeX root = ../mythesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Completeness}

In the previous chapter we stated some calculi
that has been used for the implementation
of automated theorem provers.
%
It was easy to see that Gilmore`s prover is theoretically complete,
but practically very inefficient.
Additionally it would not stop for clearly satisfiable and simple sets of clauses.
While it seams intuitive that resolution is complete
--- we search for all clashing literals between clauses and resolve them ---
it is puzzling that ordered resolution and then superposition are indeed complete.
At first sight we could expect that all these restrictions
would ignore important inferences at least in some special cases.

In general a smaller set of sound rules
and stricter conditions for a rule's application
could improve the efficiency of a procedure,
but undermine the completeness
of the procedure, e.g.~an empty calculus,
i.e.~a calculus without any rules,
is obviously sound and very efficient, but not complete.
%
In other words we have to prove for every saturation based calculus
that we can decide satisfiability of any saturated set of clauses.
That's even true for Gilmore's prover, but in most cases
---
the signature contains at least one not-constant predicate symbol
(or the equality symbol)
and one non-constant function symbol
---
sets of clauses cannot saturate.






% We want to restrict our calculus as far as possible,
% such that there is a chance of termination

% As we have already seen in examples \InstGenEQ{}
% may terminate for a set of clauses without finding
% a unsatisfiable set of ground instances.
% We have claimed that in this case the set of clauses is satisfiable.

In the first Section~\vref{sec:reasoning:on:equational:closures}
we state unit paramodulation for literal closures.
In Section~\vref{sec:inst:saturated:sets} we present
an untangled version of the proof of satisfiability
of saturated sets of closures
from the literature~\cite{GK2004csl}.
After that we look a saturation strategies in
Section~\vref{sec:saturation:strategies}
and finally we apply the completeness result to \InstGenEQ{}
in Section~\vref{sec:equational:reasoning:on:predicates}.

% Section~\vref{sec:inst:saturation:process},
% Section~\vref{sec:inst:process:fairness}.


\section{Equational Reasoning on equation closures}\label{sec:reasoning:on:equational:closures}

\begin{definition}
    A closure is a pair of a clause \( C \) and a substitution \( \sigma \),
    conveniently written as \( C\cdot\sigma \). Two closures \( C\cdot\sigma = D\cdot\tau \)
    are the same if \( C \) is a variant of \( D \) and \( C\sigma \) is a variant of \( D\tau \).
    A closure \( C\cdot\sigma \) represents a clause \( C\sigma \),
    i.e.~the result of applying substitution \( \sigma \) to \( C \).
    A ground closure represents a ground clause.
\end{definition}

For the following definitions we assume
\( \succG \) as a a total, well-founded and monotone extension
from a total simplification ordering on ground terms
to ground literal and clauses~\cite{NR2001},
which always exists.


\begin{definition}
	% 4.3
    We define an order \( \succL \) on ground closures of literals
    as an arbitrary total well-founded extension of \( \succG \)
    such that
    \( L\cdot\sigma\succL L'\cdot\sigma' \) whenever
    \( L\sigma\succG L'\sigma' \).

	% 5.1
    We define an order \( \succC \) on ground closures
    as an arbitrary total well-founded extension of
    \( \succC' \) --- an inherently well-founded order defined as extension of \( \succG \)
    such that
    \( C\cdot\tau\succC' D\cdot\rho \) whenever
    \( C\tau\succG D\rho \) or \( C\theta = D \) for an proper instantiator \( \theta \).
\end{definition}

\begin{remark}
    In summary we assume \( \succG \), \( \succL \), \( \succC \) as
        total, well-founded, and monotone extensions of a
        total simplification order \( \succ \)
        over ground terms to ground (literal) clauses
        and ground (literal) closures
        such that the following properties hold
       \begin{align*}
            s\sigma\mNE t\sigma \quad&\succG\quad s\sigma\mEQ t\sigma
           &
           L\sigma \succG L'\sigma'
           \quad&\Rightarrow\quad
            L\cdot\sigma \succL L'\cdot\sigma'
           \\
            L\sigma\lor C\sigma \quad&\succG\quad L\sigma
       &
       \left.
       \begin{array}{r}
        C\tau=D\rho, C\theta=D
        \\
        \text{or } C\tau\succG D\rho
    \end{array}
       \right \}
           \quad&\Rightarrow\quad
            C\cdot\tau\succC{} D\cdot\rho{}
       \end{align*}
        for arbitrary terms \( s,t \),
        literals \( L, L' \),
        clauses \( C,D \),
        ground substitutions \( \sigma, \tau, \rho \),
        and instantiator \( \theta \).
        Note that the order on unit closures is slightly different than on literal closures, e.g.:
       \begin{align*}
            (\mf(x)\mEQ x)\cdot \{ x\mapsto \ma \}
            &\succC
            (\mf(\ma)\mEQ\ma)\cdot\emptyset
            & \theta = \{ x\mapsto \ma \}
       \\
        (\mf(x)\mEQ x)\cdot \{ x\mapsto \ma \}
        &\not\succL
        (\mf(\ma)\mEQ\ma)\cdot\emptyset
       \end{align*}
\end{remark}

   %%% see CS2011PhD, p.45f %%%

   \begin{definition}[Unit superposition and resolution on closures~\cite{GK2004csl,CS2011PhD}, UPC]\label{def:unit:superposition:on:closures}
    \begin{gather*}
        \infer[(\sigma)]
        {(\underset{\mEQ}{L}[r])\sigma\cdot\rho}
        {(l\mEQ r)\cdot\theta_{\!_1} & (\underset{\mEQ}{L}[l'])\cdot\theta_{\!_2}}
    \qquad\qquad\qquad
        \infer[(\sigma')]
        {\emptyclause}
        {(s'\mNE t')\cdot\theta'}
    \end{gather*}
    with \( \underset{\mEQ}{L}[l'] \in \{ s[l']\mNE t, s[l']\mEQ t \} \) and
    \begin{itemize}
        \item
        \( \sigma = \mgu(l,l') \),
        \( l'\not\in\mcV \),
        \( l\theta_{\!_1} \succG r\theta_{\!_1} \),
        \( s['l']\theta_{\!_2} \succG t\theta_{\!_2} \)
        \hfill \( \sigma' = \mgu(s',t') \)
        \item
        \( l\theta_{\!_1} = l'\theta_{\!_2} \),
        \( \var(\{l,r\}) \cap \var(\{ s[l'],t \}) = \emptyset \)
        \hfill \( s'\theta' = r'\theta' \)
        \item
        \( \rho \) such that
        \( (\theta_{\!_1}\cup\theta_{\!_2}) = \sigma\rho \),
        \( \domain(\rho) \subseteq \var(\{ s[r],t \}) \)
    \end{itemize}
   \end{definition}

%    \begin{example}
%         Let \( \mf(s,t,u)\succG\mg(s') \) for all ground terms
%        \( r,s,t,s' \).
%         % \( \succ_{kbo} \) order on terms.
%        \begin{gather*}
%            \infer[\theta]{
%                \left(
%                    \mh(\underbrace{
%                        \boxed{\mg(x')}
%                         }_{r\theta})\mNE\mg(x')
%                    \right)\cdot\rho
%             }{
%                \left(
%                    \overbrace{\mf(x,y,\mc)}^{\ell}
%                    \mEQ
%                    \overbrace{\mg(x)}^r
%                \right)\cdot \sigma
%             & \left(
%                \mh(\overbrace{
%                    \boxed{\mf(x',\mh(y'), z')}
%                     }^{\ell'})\mNE\mg(x')
%                \right)\cdot \sigma'
%             }
%        \end{gather*}
%        \begin{align*}
%            \sigma &= \{x\mapsto\ma, y\mapsto\mh(\mb)\} &
%             \sigma' &= \{x'\mapsto\ma, y'\mapsto\mb, z'\mapsto\mc \}
%             \\
%             \theta &= \{x\mapsto x',y\mapsto\mh(y'),z'\mapsto\mc \}
%               &
%             \rho &=\{ x'\mapsto \ma, y'\mapsto \mb \}
%             \\
%             \ell'\theta &= \mf(x',\mh(y'),\mc)
%              &
%             \ell'\theta\rho &= \mf(\ma, \mh(\mb), \mc) = \ell\sigma = \ell'\sigma'
%        \end{align*}
%    \end{example}

   \begin{example}
    Let \( \mf(s,t,u)\succG\mg(s') \) for all ground terms
   \( r,s,t,s' \).
    % \( \succ_{kbo} \) order on terms.
   \begin{gather*}
       \infer[(\sigma)]{
           \left(
               \mh(\underbrace{
                   \boxed{\mg(x')}
                    }_{r\sigma})\mNE\mg(x')
               \right)\cdot\rho
        }{
           \left(
               \overbrace{\mf(x,y,\mc)}^{l}
               \mEQ
               \overbrace{\mg(x)}^r
           \right)\cdot \theta_{\!_1}
        & \left(
           \mh(\overbrace{
               \boxed{\mf(x',\mh(y'), z')}
                }^{l'})\mNE\mg(x')
           \right)\cdot \theta_{\!_2}
        }
   \end{gather*}
   \begin{align*}
       \theta_{\!_1} &= \{x\mapsto\ma, y\mapsto\mh(\mb)\} &
       \theta_{\!_2} &= \{x'\mapsto\ma, y'\mapsto\mb, z'\mapsto\mc \}
        \\
        \sigma &= \{x\mapsto x',y\mapsto\mh(y'),z'\mapsto\mc \}
          &
        \rho &=\{ x'\mapsto \ma, y'\mapsto \mb \}
   \end{align*}
   \begin{align*}
   \sigma\rho &= \{
    x\mapsto x'\!\rho,y\mapsto\mh(y')\rho,z'\mapsto\mc,
    x'\mapsto \ma, y'\mapsto \mb
    \}
    \\
    &= \{ x\mapsto \ma,y\mapsto\mh(\mb),z'\mapsto\mc,
    x'\mapsto \ma, y'\mapsto \mb
        \}
    = \theta_{\!_1}\cup\theta_{\!_2}
   \end{align*}
\end{example}


   \begin{lemma}
        Let \( R \) be a ground rewrite system and USC is applicable to
       \( (l\mEQ r)\cdot\theta_{\!_1}, L[l']\cdot\theta_{\!_2} \)
        with conclusion
       \( L[r]\sigma\cdot\rho \).
        If \( \theta_{\!_1}, \theta_{\!_2} \) are irreducible w.r.t.~R
        then \( \rho \) is irreducible w.r.t.~R.
   \end{lemma}

   \begin{proof}
        Assume otherwise.
    %     Hence there is a \(
    %         x\in\var(l'\theta)
    %     \) such that
    %    \( x\theta\rho \) is reducible by \(
    %         R
    %         \).

   \end{proof}

           \begin{example}
        The set of literal closures
       \( \{ \,
        (\mf(x)\mEQ\mb)\cdot \{ x\mapsto\ma \}, \,
       \ma\mEQ \mb, \,
       \mf(\mb)\mNE\mb \,
       \} \) is inconsistent,
        but the empty clause is not derivable
        if \( \ma\succG\mb \).
           \end{example}

\section{Satisfiability of saturated sets}\label{sec:inst:saturated:sets}

In this section we will define saturated set of literal closures
with respect to unit paramodulation.
Additionally we will show that a saturated set of literal closures
is satisfiable if and only if its grounding is satisfiable.

   \begin{definition}[UP-Redundancy]
        Let \( \mcL \) be a set of literal closures. We define
       \begin{itemize}
           \item \( \IRRED_R(\mcL) =
           \{ \,
            L\cdot\sigma\in\mcL \mid
           \sigma\text{ is irreducible w.r.t.~}R
           \, \} \)

        for an arbitrary ground rewrite system \( R \)

       \item
       \(
       \mcL_{L\cdot\sigma\succL} =
       \{ \,
        L'\!\cdot\sigma'\in\mcL \mid
        L\cdot\sigma\succL L'\cdot\sigma'
       \, \}
         \).

       \item Literal closure \( L\cdot\sigma \) is UP-redundant in \( \mcL \) if

       \begin{gather*}
            % cspell:disable
            R \cup irred_R(\mcL_{L\cdot\sigma\succL}) \vDash L\sigma
            % cspell:enable
       \end{gather*}
        for every ground rewrite system \( R \)

        oriented by \( \succG \)
        where \( \sigma \) is irreducible w.r.t.~\( R \).

       \item
       \( \mcR_{UP}(\mcL) \) denotes the set of all UP-redundant closures in \( \mcL \).
   \end{itemize}
\end{definition}

   \begin{definition}[UP-Saturation]

            The UP-{saturation process}
            is a sequence \( {\{ \mcL_i \}}_{i=0}^\infty \)
            where \( \mcL_{i+1} \) is constructed from \( \mcL_i \)
            by removing redundant literal closures in \( \mcL_i \)
            or by adding inferences of \( \mcL_i \) until saturation.
           \begin{gather*}
           \mcL_{i+1} = \left \{
                   \begin{array}{lclc}
                       \mcL_i \backslash L\cdot\sigma
                        &\text{if}
                        &R \cup \IRRED_R(\mcL_{i,L\cdot\sigma\succL}) \entails L\sigma
                       \\
                       \\
                       \mcL_i \cup \, \emptyclause
                        &\text{if}
                        &\left \{ \begin{array}{l}
                            (s\mNE t)\cdot\tau\in\mcL_i
                           \\
                            s\tau = t\tau,\,
                           \mu=\mgu(s,t)
                       \end{array}\right.
                       \\
                       \\
                       \mcL_i \cup{} \, L[r]\theta\cdot\rho{}
                        &\text{if}
                        &\left \{ \begin{array}{l}
                            (\ell\mEQ r)\cdot\sigma,\,
                            L[\ell']\cdot\sigma'\in\mcL_i
                           \\
                           \ell\sigma\succG r\sigma,\,
                           \theta=\mgu(\ell,\ell'),
                           \\
                           \ell'\notin\mcV,\,
                           \ell\sigma = \ell'\sigma' = \ell'\theta\rho,
                       \end{array}\right.
                       \\
                       \\
                       \mcL_i
                        &&\text{otherwise}
                   \end{array}
               \right.
               \end{gather*}

            The set of persistent closures \( \mcL^\infty \) is the lower limit of \( \mcL_i \).

            % i.e.~the lower limit of the sequence.
   \end{definition}
   \begin{definition}[UP-Fairness]

            The UP-saturation process is {UP-fair} if for every UP-inference
            with premises in \( \mcL^\infty \) the conclusion is UP-redundant
            w.r.t.~\( \mcL_j \) for some \( j \).
   \end{definition}
   \begin{definition}

            For a set of literals \( \mcL \) we define
            the saturated set of literal closures
           \( \mcL^{sat} = \mcL^\infty\backslash\mcR_{UP}(\mcL^\infty) \)
            for some UP-saturation process
           \( {\{ \mcL_i \}}_{i=0}^\infty \)
            with \( \mcL_0 = \mcL \).
   \end{definition}


       \begin{lemma}
        The set \( \mcL^{sat} \) is unique because
        for any two UP-fair saturation processes
        \( {\{ \mcL_i \}}_{i=0}^\infty \) and
        \( {\{ \mcL'_i \}}_{i=0}^\infty \)
        with \( \mcL_0 = \mcL'_0 \) we have
        \begin{gather*}
            \mcL^\infty \backslash \mcR_{UP}(\mcL^\infty)
            =
            \mcL'^\infty \backslash \mcR_{UP}(\mcL'^\infty)
        \end{gather*}
       \end{lemma}

\begin{definition}[Inst-Redundancy]\label{def:inst:redundant}

    Let \( S \) be a set of clauses.

   \begin{itemize}
       \item A ground closure \( C \) is Inst-redundant in \( S \)
        if for some \( k \)
        % consequence of smaller ground instances \( C_1,\ldots,C_k \) of \( S \), i.e.~
       \begin{itemize}
           \item \( C'_i\in S \), \( C_i=C'_i\cdot\sigma'_i \), \( C\succC C_i \) \hfill for \( i\in 1\ldots k \)
           \item such that \( C_1,\ldots,C_k\models C \)
       \end{itemize}

       \item
        A (possible non-ground) clause \( C \) is called Inst-redundant in \( S \)

    if each ground closure \( C\cdot\sigma \) is Inst-redundant in \( S \).


   \item
   \( R_{Inst}(S) \) denotes the set of all Inst-redundant clauses in \( S \).


   \end{itemize}

\end{definition}

\begin{example}
   \( S =
       \{ \,
       \mf(x)\mEQ x,\,
       \mf(\ma)\mEQ \ma,\,
       \mf(\mf(x))\mEQ\mf(x)
       \,  \)

   \( R_{Inst}(S) = \{ \, \mf(\mf(x))\mEQ\mf(x) \, \} \)
   \end{example}

   \begin{definition}[S-Relevance]
        Let \( S \) be a set of clauses \( S \), let \( I_\bot \) be a model of \( S\bot \).

       \begin{itemize}
           \item
        A selection function \( \sel \) maps clauses to literals such that
       \begin{align*}
           \sel(C)&\in C
            &&&
            I_\bot&\models\sel(C)\bot
       \end{align*}

       \item
        The set of \( S \)-relevant literal closures
       \begin{align*}
           \mcL_S &= \left \{ \, L\cdot\sigma \mid
           \begin{array}{l}
                L\lor C\in S,\,L = \sel(L\lor C)\\
                (L\lor C)\cdot\sigma\text{ is not Inst-redundant in S},\\
           \end{array}
           \, \right \}
       \end{align*}




   \end{itemize}
\end{definition}

\begin{definition}[Inst-Saturation]
    Let \( \mcL_S^{sat} \) denote the saturation process of \( \mcL_S \).
    Then a set of clauses \( S \) is Inst-saturated w.r.t.~a selection function \( \sel \),
            if \( \mcL_S^{sat} \) does not contain the empty literal clause.
\end{definition}

       \begin{theorem}\label{theorem:inst:saturated:satisfiable}
        If a set of clauses \( S \) is Inst-saturated,
        and \( S\bot \) is satisfiable,

        then \( S \) is also satisfiable.
       \end{theorem}

       \begin{proof} We assume that \( S \) is not satisfiable.
           \begin{enumerate}
               \item We construct a candidate model \( \mcI \) in Definition~\vref{def:candidate:model:construction}.
               \item We can show that \( \mcI \) is a model by Lemma~\vref{lemma:model:is:candidate}.

                That contradicts our assumption.
           \end{enumerate}
            We discard our assumption and conclude that \( S \) is satisfiable.
           \end{proof}

   \begin{definition}[{Candidate Model Construction}]\label{def:candidate:model:construction}

        Let \( S \) be an Inst-saturated set of clauses,
        i.e.~\( \emptyclause\not\in\mcL_S^{sat} \), SAT\( (S\bot) \).

        Let \( L = L'\cdot\sigma \in\mcL_S^{sat} \).
        We define inductively:

           \begin{itemize}
               \item \( I_L = \{ \, \epsilon_M\mid L\succL M \, \} \)
               \hfill  IH:~\( \epsilon_M \) is defined for any \( M\mid L\succL M \)

               \item \( R_L = \{ s \to t \mid s\mEQ t\in I_L, s\succG t \} \)

                   \item \( \epsilon_L = \left \{
                       \begin{array}{cll}
                           \emptyset &\text{if }
                            L'\sigma\text{ reducible by }R_L
                           \\
                           \emptyset &\text{if }
                            I_L\vDash L'\sigma
                           \text{ or }
                            I_L\vDash \overline{L'}\sigma
                            &\text{(defined)}
                           \\
                           \{ L'\sigma \}
                            &\text{otherwise}
                            &\text{(productive)}
                       \end{array}
                   \right. \)

               \item
               \( R_S = \bigcup_{L\in\mcL_S^{sat}} R_L \)
               \hfill
               \( R_S \) is convergent and interreduced

               \item
               \( I_S = \bigcup_{L\in\mcL_S^{sat}} \epsilon_L \)
               \hfill
               \( I_S \) is consistent,
               \( L\sigma\in I_S \) is irreducible by \( R_S \)
           \end{itemize}
       \end{definition}

            Let \( \mcI \) be an arbitrary consistent extension of \( I_S \)

            in all the following lemmata.


       \begin{lemma}\label{existence}

        If any \( L\cdot\sigma\in\mcL_S \), irreducible by \( R_S \) exists with \( \mcI\not\models L\sigma \)

        then there is a \( L'\cdot\sigma'\in \IRRED_{R_S}(\mcL_S^{sat}) \) with \( \mcI\not\models L'\sigma' \).
       \end{lemma}

       \begin{proof}
            We have two cases

       \begin{itemize}
           \item If \( L\cdot\sigma \) is not UP-redundant in \( \mcL_S^{sat} \),
            then \( L'\cdot\sigma'=L\cdot\sigma \).
           \hfill\checkmark{}

           \item If \( L\cdot\sigma \) is UP-redundant in \( \mcL_S^{sat} \).
        By construction \( \sigma \) is irreducible by \( R_S \). Then we have
       \begin{align*}
            R_S \cup \IRRED_{R_S}(
               \{
                L'\cdot\sigma'\in\mcL_S^{sat}
               \mid
                L\cdot\sigma \succL L'\cdot\sigma'
               \}
            )
           \models
            L\sigma
       \end{align*}
        % At least one \( L'\cdot\sigma'\in \IRRED{R_S}(\mcL_S^{sat}) \)
        with \( \mcI\not\models L'\sigma' \).
       \hfill \checkmark{}
       \end{itemize}
   \end{proof}


       \begin{lemma}\label{irreducible}
            Whenever
           \begin{gather*}
                M\cdot\tau = \min_{\succL}\!
               \left \{ \,
                L'\cdot\tau' \mid
                L'\cdot\sigma' \in \IRRED_{R_S}(\mcL_S^{sat}), \,
                L'\sigma'\text{ false in }\mcI \,
               \right \}
           \end{gather*}
            is defined, then \( M\cdot\tau \) is irreducible by \( R_S \).
       \end{lemma}

       \begin{proof}
            Assume \( M\cdot\tau \) is reducible by \( (\ell\to r)\in R_S \)

            and \( (\ell\to r) \) is produced by \( (\ell'\mEQ r')\cdot\rho\in\mcL_S^{sat} \).

           \vspace{0.7em}
            Now UP-inference is applicable because \( \tau \) is irreducible by \( R_S \),
           \begin{gather*}
               \infer[UP]
                {M[r']\theta\cdot\mu}
                {(\ell'\mEQ r')\cdot\rho & M[\ell'']\cdot\tau}
           \end{gather*}
           \( \mu \) is irreducible by \( R_S \), and \( M[r']\theta\mu \){ is false in }\( \mcI \).
           \hfill\ldots

        We have two cases

           \begin{itemize}
               \item If \( M[r']\theta\cdot\mu \) is not UP-redundant in \( \mcL_S^{sat} \)
                then \( M[r']\theta\cdot\mu\in\mcL_S^{sat} \).

               \vspace{0.3em}
                Now \( M\cdot\tau\succL
                M[r']\theta\cdot\mu\in \IRRED_{R_S}(\mcL_S^{sat}) \)

                contradicts minimality of \( M\cdot\tau \).
               \hfill
               \vspace{0.3em}

               \item If \( M[r']\theta\cdot\mu \) is UP-redundant in \( \mcL_S^{sat} \) then
               \vspace{-0.3em}
               \begin{gather*}
                    R_S \cup \IRRED_{R_S}
                   \{
                        M'\cdot\tau'\in\mcL_S^{sat}\mid
                        M[r']\theta\cdot\mu \succL M'\tau'
                       \} \models M[r']\theta\mu
               \end{gather*}
                Hence there is \( M'\cdot\tau'\in\mcL_S^{sat} \) false in \( \mcI \) such that
               \( M\cdot\tau\succL M[r']\theta\cdot\mu\succL M'\cdot\tau' \),

               \( M'\cdot\tau' \) contradicts minimality of \( M\cdot\tau \).
               \hfill

           \end{itemize}

            Hence \( M\cdot\tau \) is irreducible by \( R_S \).
           \hfill\qed{}
       \end{proof}





       \begin{lemma}\label{equation}
            Let \( M\cdot\tau\in\mcL_S^{sat} \),
            irreducible by \( R_S \), and defined (not productive).

            From \( \mcI\not\models M\tau \) follows that \( M \) is not an equation \( (s\mEQ t) \).

       \begin{proof}
            Assume \( M = (s\mEQ t) \). Then we have
           \begin{itemize}
               \item \( I_{M\cdot\tau}\models (s\mNE t)\tau \)
               \item All literals in \( I_{M\cdot\tau} \) are irreducible by \( R_{M\cdot\tau} \)
               \item \( s\tau \) and \( t\tau \) are irreducible by \( R_{M\cdot\tau} \)
               \item \( R_{M\cdot\tau} \) is a convergent term rewrite system
           \end{itemize}
            Hence \( (s\mNE t)\tau\in I_{M\cdot\tau} \)
            is produced to \( I_{M\cdot\tau} \) by some \( (s'\mNE t')\cdot\tau' \),

            but \( (s'\mNE t')\tau'\succG (s\mEQ t)\tau \)
            and \( (s'\mNE t')\cdot\tau'\succL M\cdot\tau \).
           \hfill

       \end{proof}
       \end{lemma}


       \begin{lemma}\label{inequation}
            Let \( M\cdot\tau\in\mcL_S^{sat} \),
            irreducible by \( R_S \), and defined (not productive).

            From \( \mcI\not\models M\tau \) follows that \( M \) is not an inequation \( (s\mNE t) \).
           \begin{proof}
            Assume \( M\cdot\tau \) is inequation \( (s\mNE t)\cdot\tau \). We have
           \begin{itemize}
               \item \( I_{M\cdot\tau}\models (s\mEQ t)\tau \)
               \item \( s\tau \) and \( t\tau \) are irreducible by \( R_{M\cdot\tau} \)
           \end{itemize}
            Hence \( s\tau = t\tau \) and equality resolution is applicable.

            Contradiction to \( \emptyclause\not\in\mcL_S^{sat} \).
           \hfill

       \end{proof}
       \end{lemma}




       \begin{lemma}\label{lemma:model:is:candidate}
           \( \mcI \) is a model for all ground instances of \( S \)
       \end{lemma}

       \begin{proof}
            Assume \( \mcI \) is not a model.

            Hence a minimal ground closure \(
                D = \min_{\succC} \{ \,
                C'\cdot\sigma \mid C'\in S, \,
               \mcI\not\models C'\sigma \,
               \} \),
                an instance of a clause in \( S \),
               \( \false \) in \( \mcI \), must exist. Further on

       \begin{itemize}
           \item \( D = D'\cdot\sigma \) is not Inst-redundant.
           \vspace{0.2em}

            Otherwise by Definition~\ref{def:inst:redundant} there are
           \( D_1,\ldots,D_n\models D \), \( D\succC D_i \) for all \( i \),

            and \( D_j \) \( \false \) in \( \mcI \) for one \( j \), which contradicts minimality.
           \hfill

           \item \( x\sigma \) irreducible by \( R_S \) for every variable \( x \) in \( D' \).
           \vspace{0.2em}

            Otherwise let \( (\ell\to r)\tau\in R_L \) and \( x\sigma = x\sigma{[l\tau]}_p \) for some variable x in D'.
            We define substitution \( \sigma' \) with \( x\sigma' = x\sigma{[r\tau]}_p \) and \( y\sigma' = y\sigma \) for \( y\neq x \).
           \( D'\sigma' \) is false in \( \mcI \) and \( D\succC D'\cdot\sigma' \),
            which contradicts minimality.\hfill
       \end{itemize}

        Since \( D \) is not Inst-redundant in \( S \),
        we have for some literal \( L \),

        that \( D' = L\lor D'' \), \( \sel(D') = L \), \( L\cdot\sigma\in\mcL_S \),
       \( L\sigma \) is \( \false \) in \( \mcI \).
       \vspace{0.7em}

        Hence the following literal closure
       \begin{gather*}
            M\cdot\tau = \min_{\succL}\!
   \left \{ \,
        L'\cdot\tau' \mid
        L'\cdot\sigma' \in \IRRED_{R_S}(\mcL_S^{sat}), \,
       \mcI\not\models L'\cdot\sigma' \,
   \right \}
       \end{gather*}
        exists by Lemma~\ref{existence}, is irreducible by Lemma~\ref{irreducible},
        and is not productive.
        Since \( \mcI\not\models M\cdot\tau \) the literal
        M cannot be an equation by Lemma~\ref{equation}
        or an inequation by Lemma~\ref{inequation}.
        We have derived a contradiction from our only assumption.

        Therefore \( \mcI \) is a model for all instances of \( S \),
        hence
        % \( S \) is satisfiable and
        Theorem~\vref{theorem:inst:saturated:satisfiable} holds.
   \end{proof}

%    \IMPROVE{Section~\vref{sec:saturation:strategies}}

   \section{Saturation Strategies}\label{sec:saturation:strategies}

   So far we have only shown that a Inst-saturated set of clauses
   \( S \) is satisfiable if \( S\bot \) is satisfiable.
   Now we take a look at how Inst-saturation can be achieved
   starting from a set of clauses \( S^1 \).

   \begin{definition}
    An Inst-\coloremph{saturation process} is a sequence of triples
    \(
        {\{
            \langle
            S^i, I^{i}_{\!\bot}, \sel^i
            \rangle
            \}}_{i=1}^\infty
    \)
    where \( S^i \) is a set of clauses,
    \( I^{i}_{\!\bot} \) a model for \( S^i\bot \),
    and \( \sel^i \) a selection function based on that model.
%
    We try to go from a given state
    \( {\{ \langle S^i, I^{i}_{\!\bot}, \sel^i \rangle \}} \)
    to a successor state
    \( {\{ \langle S^{i+1}, I^{i+1}_{\!\bot}, \sel^{i+1} \rangle \}} \)
    by first performing one of the following steps
    \begin{itemize}
        \item
        \( S^{i+1} = S^i \cup N \)
        where \( N \) is a set of clauses such that
        \( S^i \entails N \)
        \item
        \( S^{i+1} = S^i \setminus \{ C \} \)
        where clause \( C \) is Inst-redundant in \( S^{i} \).
    \end{itemize}
\noindent If \( S^{i+1}\! \bot \) is unsatisfiable
the process terminates with result “unsatisfiable”.
Otherwise we build \( I^{\,i+1}_{\!\bot} \) and \( \sel^{\,i+1} \)
from \( S^{i+1}\!\bot \).
%
The set of persistent clauses \( S^\infty \) denotes the lower limit of \( {\{ S^i \}}_{i=1}^\infty \).
\end{definition}

\begin{definition}
    Let
    \( K = \{ (L_1\lor C_1)\cdot\sigma, \ldots, (L_n\lor C_n)\cdot\sigma \} \)
    be a finite set of closures
    of clauses from \( S^\infty \).
    Let \( \mcL = \{ L_1\cdot\sigma, \ldots, L_n\cdot\sigma \} \).
    The pair \( (K,L) \) is a \coloremph{permanent conflict} if
    \( \mcL^{sat} \) contains the empty clause
    and for infinitely many \( i \)
    we have \( \sel^i(L_j\lor C_j) = L_j \)
    for \( 1\leq j < n \).
    An Inst-saturation process is \coloremph{Inst-fair}
    if for every persistent conflict
    \( (K,L) \)
    at least one of the closures in \( K \)
    is Inst-redundant in \( S^i \) for some \( i \).
    \end{definition}

    \begin{lemma}
        Let \( S^\infty \) be a set of persistent clauses
        of an Inst-fair saturation process
        \( {\{ \langle S^i, {I\!_\bot}^i, \sel^i \rangle \}}_{i=1}^\infty \),
        and let \( S^\infty \! \bot \) be satisfiable.
        Then there exists a model \( I \! \bot \) of \( S^\infty \! \bot \)
        and a selection function \( \sel \) based on \( I \! \bot \)
        such that \(S^\infty \) is Inst-saturated w.r.t. \( \sel \).
    \end{lemma}

    \begin{proof} …
    \end{proof}


        In an \emph{Inst-fair} saturation process
        % \( { \{ \langle S^i, I^{i}_{\!\bot}, \sel^i \rangle \}}_{i=1}^\infty \)
        the set of ground instances
        \( S^i \! \bot \) is either satisfiable for all \( i \)
        or unsatisfiable for some \( i \).
        In the first case an Inst-saturated \( S^i \)
        with satisfiable \( S^i \! \bot \) proves satisfiability of \( S^1 \),
        while in the second case the first unsatisfiable \( S^i \! \bot \)
        provides evidence of the unsatisfiability of \( S^1 \).
%
    It remains to ensure that the Inst-saturation process is Inst-fair.


    We represent UP-proofs as binary trees.
    We label the nodes by closures
    and substitutions from the corresponding inferences.
    At each node we assume that the left proof branch
    is variable disjoint from the right proof branch
    (which can be achieved by variable renaming).
    We construct a \coloremph{P-relevant instantiator}
    of literal \( L \in \mcL \)
    as composition \( \theta = \theta_1\ldots\theta_k \)
    of the sequence of substitutions \( {(\theta_i)}_{i=1}^k \)
    along the path of length \( k \)
    from leaf \( L\cdot\sigma \)
    to the root of a proof \( P \).
    Further we construct the \coloremph{P-relevant instance}
    \( L\theta\cdot\tau \) from
    \( L \cdot \sigma \) with \( \theta \)
    with \( L\theta\tau = L\sigma \).


    \begin{lemma}
        Let \( \mcP \) be the set of all P-relevant instances
        of all leafs of a proof \( P \) of the empty clause.
        Then \( \mcP \bot \) is unsatisfiable.
    \end{lemma}

    \begin{corollary}
        Let \( (K, \mcL) \) be a persistent conflict
        and \( P \) a proof of the empty clause from \( \mcL \) in \( UP \),
        then at least one \(P\)-relevant instantiator is proper.
    \end{corollary}

    We make closures in \( K \)
    of a persistent conflict \( (K,\mcL) \)
    Inst-redundant by adding their P-relevant proper instances.
    We make and Inst-saturation process fair
    by UP-saturating literal closures from persisting conflicts
    and adding proper instantiations of clauses with substitutions
    gained from proofs of the empty clause.


    \section{Equational reasoning on equation literals}\label{sec:reasoning:on:equational:literals}

    \begin{definition}[Unit superposition and resolution on literals~\cite{GK2004csl,CS2011PhD}, UPL]\label{def:unit:superposition:on:literals}
        \begin{gather*}
            \infer[(\sigma)]
            {(\underset{\mEQ}{L}[r])\sigma}
            {(l\mEQ r) & (\underset{\mEQ}{L}[l'])}
        \qquad\qquad\qquad
            \infer[(\sigma')]
            {\emptyclause}
            {(s'\mNE t')}
        \end{gather*}
        with \( \underset{\mEQ}{L}[l'] \in \{ s[l']\mNE t, s[l']\mEQ t \} \) where
        for some grounding substitution \( \theta \)
        \begin{itemize}
            \item
            \( \sigma = \mgu(l,l') \),
            \( l'\not\in\mcV \),
            \( l\sigma\theta \succG r\sigma\theta \),
            \( s[l']\sigma\theta \succG t\sigma\theta \)
            \hfill \( \sigma' = \mgu(s',t') \)
            \item
            \( l\theta_{\!_1} = l'\theta_{\!_2} \),
            \( \var(\{l,r\}) \cap \var(\{ s[l'],t \}) = \emptyset \)
            \item
            \( \domain(\theta) \subseteq \var(\{ l\sigma,r\sigma,s[l']\sigma,t\sigma \}) \)
        \end{itemize}
    \end{definition}

    We construct P-relevant instantiators and P-relevant instances
    of literals \( L\sigma \) from proofs in UPL of the empty clause
    in the same way as above.

    \begin{lemma}
        Let \(Lit\) be a set of literals such that \( Lit\bot \) is satisfiable.
        Further let \( \mcL \) be a set of ground closures from \( Lit \)
        such that the empty clause is derivable in \( UP \) from \( \mcL \).
        Then there is a proof of the empty clause in \( UPL \) from \( Lit \)
        such that for at least one closure \( L \cdot \sigma \in \mcL \),
        P-relevant instance of \(L\) is \( L\theta \)
        where \( \theta \) is a proper instantiator
        and \( L\sigma = L\theta\tau \) for some ground substitution \( \tau \).
    \end{lemma}

    \section{Equational reasoning on predicate literals}\label{sec:equational:reasoning:on:predicates}

    So far the calculi in Definitions~\ref{def:unit:superposition:on:closures} (UPC)
    and~\ref{def:unit:superposition:on:literals} (UPL) dealt
    with equations only.
    In this section we translate first order logic
    into purely equational logic and
    justify the inference rules in Definition~\vref{def:unit-superpositin-calculus}.
    Intuitively we just replace predicate symbols with Boolean function symbols
    and demand that functional predicates evaluate to true or not true in a model.

    \begin{definition}
        Let \( \mcF = \mcFfPE \) be a first order signature.
        We construct an extended set of function symbols
        % from \( \mcF \)
        \[
            {\mcF'_\mf} = \mcFf
 \disjointunion
            \{ \mc_\top \mid \mc_\top\not\in\mcF \}
 \disjointunion
            \{ \mP_{\mf} \mid \mP \in \mcFP, \mP_{\mf}\not\in\mcFf \}
            \]
        such that \( \mc_\top \) is a constant function symbol,
        and \( \arity(\mP_{\mf}) = \arity(\mP) \) for all \( \mP_\mf \).
        We extend our term order \( \succG \) to the new symbols
        such that \( \mc_\top \) is the smallest “predicate” ground term.
    \end{definition}

    \begin{definition}
        We translate a set of clauses over signature \( \mcF \)
        into a equisatisfiable and purely equational set of clauses
        over purely equational signature
        \( {\mcF'_{\!\mEQ}} = {\mcF'_\mf}
        \, \disjointunion \, \emptyset
        \, \disjointunion  \{ \mEQ \} \)
        by replacing predicates with equations.
        \begin{align*}
            T_\mEQ(S) &= \bigcup_{C\in S} T_\mEQ(C) &
            T_\mEQ(C) &= \bigcup_{L\in C} T_\mEQ(L) \\
            T_\mEQ(s\mEQ t) &= s\mEQ t &
            T_\mEQ(s\mNE t) &= s\mNE t \\
            T_\mEQ(\mP(t_1,\ldots,t_n)) &= \mP_\mf(t_1,\ldots,t_n)\mEQ\mc_\top &
            T_\mEQ(\lnot\mP(t_1,\ldots,t_n)) &= \mP_\mf(t_1,\ldots,t_n)\mNE\mc_\top
        \end{align*}
    \end{definition}

    The original equations of terms stay unchanged
    while we replace each predicate with an equation,
    and each negated predicate with an inequation,
    where we have a “predicate” term on the left side
    and a the “predicate” constant \( \mc_\top \) on the right side.



    \begin{corollary}
        We can represent proofs in \InstGenEQ{}
        as proofs in {UPL}.
    \end{corollary}

    \begin{proof}
        Unit superposition and unit equality resolution work the same.
        We simulate derivation steps with predicates in \InstGenEQ{}
        as proofs with translated predicates in {UPL} for
        \begin{itemize}
            \item unit paramodulation
            \begin{gather*}
                \infer
                [ (\sigma) ]
                {A_\mf[t]\sigma\mNE\mc_\top}
                {s\mEQ t&A_\mf[s']\mNE\mc_\top}
                \qquad\qquad
                \infer
                [ (\sigma)  ]
                {A_\mf[t]\sigma\mEQ \mc_\top}
                {s\mEQ t&A_\mf[s']\mEQ \mc_\top}
                \end{gather*}
            where \( \sigma=\mgu(s,s') \) is defined,
            \( s'\not\in\mcV \),
            \( s\sigma\theta\succG t\sigma\theta \),
            \( \textcolor{colG}{(A_\mf[s']\sigma\theta\succG\mc_\top)} \)

            for some grounding substitution \( \theta \);

            \item % unit equality resolution and
            unit resolution
            \begin{gather*}
                % \infer
                % [(\sigma)]
                % {\emptyclause}
                % {s\mNE t}
                % \quad\quad\quad\qquad
                \infer[(\sigma)]
                {
                    \infer[(\emptyset)]
                    {\emptyclause}
                    {\mc_\top \mNE \mc_\top}
                    }
                {A\mEQ\mc_\top & \lnot B\mNE\mc_\top}
            \end{gather*}
            where \( \sigma=\mgu(A,B) \) is defined,
            \textcolor{colG}{
                \( (A\sigma\theta\succ\mc_\top) \)
                for any grounding substitution \( \theta \)
            }
        \end{itemize}
    \end{proof}

    \begin{remark}
        The transformation from predicate logic
        to purely equational logic
        and the application of the unit para\-modulation
        to translated literals are well defined,
        e.g.\ we will not end up with literals like
        \( x \mEQ \mc_\top \),
        \( \mP_\mf(x) \mEQ x \) or
        \( \mf(\mP_\mf(x)) \mEQ x \).

        Implicitly we define two sorts of function symbols in the transformation,
        uninterpreted and Boolean function symbols.
        Boolean function symbols only appear at the root positions of terms.
        The root symbols of the two terms of an equation are always of the same sort.

        Due the extended order \( \succG \), where
        \( \mc_\top \) is the smallest term,
        even \( \mP_\mf(x) \mEQ \mQ_\mf(x) \) cannot be derived from
        literals \( \mP_\mf(x) \mEQ \mc_\top \) and \(\mQ_\mf(x) \mEQ \mc_\top \). So we can easily transform derived literals back to predicate logic.

        Further we can easily transform predicate models to equational models and vice versa.
        \begin{align*}
            \mcM\models&\,\mP(s)
            &\Longleftrightarrow&&
            \mcM'\models&\,\mP(s)\mEQ \mc_\top
            \\
            \mcM\models&\,\lnot\mP(s)
            &\Longleftrightarrow&&
            \mcM'\models&\,\mP(s)\mNE \mc_\top
        \end{align*}
        i.e.\ %
        \( s\in P_{\mcM} \) if and only if the evaluations
        \( v'_{\mcM'}(\mP(s)) = v'_{\mcM'}(\mc_\top) \) are equal.
    \end{remark}














