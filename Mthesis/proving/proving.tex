% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automation}

\input{epigraphs/syllogism}

In this chapter we demonstrate instance-based proving procedures.
We highlight the impact of undecidability in first order logic
for Gilmore's prover and the \InstGen framework.
It seems natural to expect decision procedures for decidable fragments of first order logic,
but that does not automatically follow from refutational completeness of these procedures.


%An we judge the procedures by there theoretical performance on decidable fragments. 
%
We know by Herbrand's theorem 
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Hebrand model. 
And we know by compactness 
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving 
is to find an unsatisfiable and finite set of ground instances for a given set of clauses.
In general a failure in this search does not show satisfiability of the given set of clauses.
In practice we make many detours in the search and we experience very finite resources of space and time. 
In theory we have no bound on the size of the smallest set of unsatisfiable ground instances.

%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.


To actually prove a theorem 
we first make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we efficiently trormansform the negated formula into an {\myem equisatisfiable} set of clauses,
i.e.~the formula is satisfiable if and only if the set of clauses is satisfiable.
%This can be done efficiently with Skolemization \cite{books/el/RV01/Hahnle01} and Tseitin-transformation \cite{tseitin70, PLAISTED1986293} as shown in \cite{Nonnengart01computingsmall}.

It would sufficient to just luckily guess an unsatisfiable set of ground instances. 
But usually a sequence of systematically growing sets of ground instances is generated 
such that an unsatisfiable one will be found 
for an arbitrary unsatisfiable set of clauses
eventually.



%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula $F$ is satisfiable if and only if a set of clauses $S$ is satisfiable 
%%	then we call $F$ and $S$ are equisatisfiable.
%\end{definition}
%
%Tseitin's transformation \cite{tseitin70} -- 
%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.




\section{Gilmore's Prover}

In 1960 Paul Gilmore presented the first {\myem implementation} of an automated 
theorem prover \cite{5392528} for first order logic without equality,
which happened to use an instantiation-based approach. 
The procedure is theoretically complete, i.e.~for every valid formula 
a proof can be found eventually.

In practice this prover ran into memory issues or time outs more often than not.
We will discuss reasons for this inefficiency after we have described and demonstrated the procedure.

The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:fosca:is:mortal}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C  
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula to clausal normal form $S_{(\ref{ex:fosca:is:mortal})} = A\land B \land\lnot C \equiv \lnot F$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	As last step we transform the single formula in 
	the set of ground instances $S_0$ into a disjunctive normal form 
	for easy satisfiability checking.
%
\begin{gather*}
%S^{\ref{ex:fosca:is:mortal},0} \equiv \begin{array}{c}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
%\end{array}
\end{gather*}
Both conjunctions contain complementary literals and we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

\begin{procedure}[Gilmore's Prover]\label{proc:gilmore's:prover}
	We translate the negation of our formula $F$ into an equisatisfiable set of clauses 
	$\lnot F \approx S = \bigcup_{i=1}^{n} \mcC_i$ with an efficient algorithm \cite{tseitin70}, \cite{PLAISTED1986293}.
	Then we start our first iteration with $k=0$.
	\begin{enumerate}
		
		\item We create the set of all ground terms up to term depth $k$, 
		i.e.~the partial Herbrand universe $H_k$ according to Definition \ref{def:hk}. 
		We use $H_k$ to create the set of clause instances $S_k$ 
		by substituting all variables 
		in each clause by terms from $H_k$ in any possible permutation.
		\[ S_k = \bigcup_{i=1}^{n} 
		\{\,
			\mcC_i\sigma \mid \mcC_i \in S,\,\sigma: \mcV\to H_k
		\,\}
		\]
		
		\item We translate $S_k$ into an equivalent disjunctive normal form 
		(i.e.~a disjunction of conjunctions of literals)
		where satisfiability is easily checked.
		
		

		\item When every conjunction contains a pair of complementary literals 
		then we exit the procedure and report unsatisfiability of $S$, 
		hence validity of $F$.

Otherwise we increase $k$ by one and continue with step 1.
		
		
	\end{enumerate}
	
\end{procedure}

Gilmore's procedure will always terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability in first order logic
which does not exist because of undecidability of satisfiability in first order logic.

It is easy to see that for a set of clauses without non-constant function symbols
we can stop the procedure after one iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$,
i.e.~no new elements were added to the Hebrand universe and now new ground instances could be generated.
%
%On the other hand the procedure will never terminate 
%even for very simple satisfiable sets where the Herbrand universe is infinite, 
%i.e.~there is at least one non-constant function symbol.

\begin{example}\label{ex:unsat:nexsx}
	Let $k\in\mathbb{N}$ be an arbitrary but fixed number.
	Consider the unsatisfiable set of clauses
	$S_{(\ref{ex:unsat:nexsx})} = \{\, \lnot\mcL_1,\,\mcL_2\, \} =
	\{\,
	{ \lnot\mE(x, \ms(x)))},\, 
	{ \mE(\ms^{k}(y), \ms(\ms^{k}(y)))}
	\,\}$.
	The sets of instances $S_i$ are satisfiable for $i<k$.
	The set of instances $S_{k}$ is clearly unsatisfiable.
	%	
	\begin{align*}
	H_{0} :=&\ \{\,\mzero\,\} 
	&
	S_{0} :=&\ \{\, 
	{\colG \lnot\mE(\mzero,\msucc(\mzero))},\,
	{\colHi \mE(\ms^k(\mzero),\,\ms(\ms^k(\mzero)))}
	\,\}
	\subsetneq S_k
	\\
	H_{i+1} =&\ H_i\disjointunion\{\,\msucc(\msucc^{i}(\mzero))\,\}
	&
	S_{i+1} \supsetneq&\
	\{\,
	{\colG \lnot\mE(\msucc^{i+1}(\mzero),\msucc(\msucc^{i+1}(\mzero))),\,
	\mE(\ms^k(\msucc^{i+1}(\mzero)), \ms(\ms^k(\msucc^{i+1}(\mzero))))}
	\,\}
	\\
	H_{k} \supsetneq&\ \{\,\msucc^{k}(\mzero)\,\} 
	&
	S_{k} \supsetneq&\
	\{\,
	{\colLo \lnot\mE(\msucc^{k}(\mzero),\msucc(\msucc^{k}(\mzero)))},\,
	{\colG\mE(\ms^k(\msucc^{k}(\mzero)), \ms(\ms^k(\msucc^{k}(\mzero))))}
%	{\ldots}
	\,\}
	\end{align*}
	We've produced $2\cdot k$ {\myem irrelevant} instances, i.e. these clauses did not cause any conflict in 
	propositional satisfiability. 
	In this example the guess for a finite unsatisfiable set of ground instances appears feasible and yields a smaller set.
	\[
	\{\, 
	\lnot\mcL_1\sigma,\,\mcL_2\sigma
	\,\} \qquad \sigma=\{x\mapsto \msucc^k(\mzero),\,y\mapsto \mzero\}
	\]
\end{example}

\begin{definition}
	For an unary function symbol $\msucc$, a natural number
	$i\in\mathbb{N}$, and an arbitrary term $t\in\mcTf$ we introduce the notation
	\[
	\begin{array}{rl}
	\msucc^0(t) &:=\ t \\
	\msucc^{i+1}(t) &:=\ \msucc(\msucc^i(t))
	\end{array}
	\]
\end{definition}



\begin{example}\label{ex:sat:exy}
	Consider the formula 
	$G = \exists x\forall y\,\mE(x,y)$
	which is a member of the Ackermann prefix class $\forall^*\exists\forall^*$ 
	of first order formulae
	where the satisfiability problem is decidable.
	The set of clauses 
	$S_{(\ref{ex:sat:exy})}= \{\,\mE(\mzero,y)\,\}$ is equisatisfiable to $G$ and clearly satisfiable.
	The procedure yields the following sequence of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \mE(\mzero,\mzero)
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\mzero,\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
	So Gilmore's prover wouldn't terminate on this simple and decidable problem.
\end{example}



We have observed three main disadvantages in Gilmore's procedure.
\begin{enumerate}
	\item\label{enum:gilmore:generation}
	 The generation of instances is unguided. 
	With each iteration exponentially many (mostly useless)
	instances are created
	-- depending on the number and the arities of used symbols.
%	\begin{align*}
%		H'_0 &= \{\,\mc \,\}  
%		&H_0 = H'_0
%		\\
%		H'_1 &= \{\,\mf(\mc), \mg(\mc,\mc) \,\} 
%		&H_1 = H_0 \cup H'_1
%		\\
%		H'_2 &= 
%		\{\, 
%			\mf(\mf(\mc)), \mf(\mg(\mc,\mc)), 
%			\mg(\mc, \mf(\mc)), \mg(\mc, \mg(\mc,\mc)), \\
%			&\qquad \mg(\mf(\mc), \mc), \mg(\mf(\mc), \mf(\mc)), \mg(\mf(\mc), \mg(\mc,\mc)), \\
%			&\qquad \mg(\mg(\mc,\mc),\mc), \mg(\mg(\mc,\mc),\mf(\mc)), \mg(\mg(\mc,\mc), \mg(\mc,\mc)) 
%		\,\} 
%		&H_2 = H_1 \cup H'_2	
%		\\
%		H'_{i+1} &= 
%			\{\, \mf(a), \mg(a,b), \mg(b,a) \mid a\in H'_i, b\in H_i \, 
%			\}
%			&H_i = \bigcup_{j=1}^{i} H'_j
%		\end{align*}\\[-1.0em]	
\begin{align*}
	\lvert S_{i} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)
	&
	\lvert H_0 \rvert &\geq 1	
	\\
	\lvert S_{i+1} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i+1}\rvert^n \right)
%	\geq \lvert S_i \rvert^n
	&
	\lvert H_{i+1}\rvert &\geq 
	\sum_{n>0}\left(
	\lvert\mcFfn\rvert\cdot\lvert H_i \rvert^n
	\right) 
%	\\
%	&\geq \sum_n \left( \lvert \mcFPn \rvert\cdot 
%	\left( 
%	\sum_{n>0}\left(\lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)\right)^n\ \right) \geq \lvert S_i \rvert^n
\end{align*}
		This makes disadvantage No.~\ref{enum:gilmore:transformation} 
		which is invoked at every iteration even worse.
	\item\label{enum:gilmore:transformation} 
	The check for unsatisfiability is far from efficient.
	The transformation from a set of clauses 
	to a formula in disjunctive normal form
	can introduce an exponential\footnote{
		If a general algorithm without exponential blowup existed 
		for the transformation of 
		an arbitrary propositional formula into 
		an equi-\allowbreak{}satisfiable formula in disjunctive normal 
		form (where satisfiability is a linear check) 
		then $\mathsf{SAT}$ would be in $\mcP$
%		$\mathsf{SAT}\in\mcP$  
		and $\mcP = \mcN\mcP$. 
	}  
	blow up of the size of the formula 
	-- depending on the number of clauses $n$ in the set 
	and the number of literals $c_i$ per clause $\mcC_i$ 
	we get the disjunction of
	$\prod_{1}^{n} c_i$ 
	conjunctions of $n$ literals.
	  \begin{align*}
	  \bigwedge_{i=1}^{n} 
	  \left(
	  	\bigvee_{j_i=1}^{c_i} p_{(i,j_i)} 
	  \right)
	  \ &\equiv
	  \bigvee_{(j_1,\ldots,j_n)}
	  \left(
	  	\bigwedge_{i=1}^{n} p_{(i,j_i)}
	  \right)
	  &\text{with }(j_1,\ldots,j_n)\in\prod_{i=1}^{n}\{ 1,\ldots,c_i \}
	\end{align*}
	In total the number of literals in the set of clauses is 
	$n\cdot \bar{c}_{arith}$, 
	while the equivalent disjunctive normal form contains 
	$(\bar{c}_{geom})^n\cdot n$ literals\footnote{
		%		$\prod_{1}^{n} c_i = (\bar{c}_{geom})^n$
		%		with the geometric mean 
		Geometric $\bar{c}_{geom} := \left(\prod_{1}^{n}c_i\right)^{\frac{1}{n}}$, 
		arithmetic $\bar{c}_{arith} := \left(\sum_{1}^{n}c_i\right)\cdot\frac{1}{n}$ mean, and
		%		where
				$\bar{c}_{geom} 
				\leq 
				\bar{c}_{arith}$.
	}.
	\begin{gather*}
%	a∧(b∨c)∧(d∨e∨f)
%	\\
%	\equiv
%	\\
%	(a∧b∧d)∨(a∧b∧e)∨(a∧b∧f)∨(a∧c∧d)∨(a∧c∧e)∨(a∧c∧f)
%\\
		\{ 1 \}\times\{1,2\}\times\{1,2,3\} = 
		\{
			(1,1,1),(1,1,2),(1,1,3),
			(1,2,1),(1,2,2),(1,2,3)
		\}
	\end{gather*}
	
	\item\label{enum:gilmore:termination}
	The procedure will not terminate for satisfiable sets 
	when at least one non-constant predicate symbol is used in the set of clauses and 
	one non-constant function symbol is available, e.g.~for $S=\{\,\mP(\mf(x)) \,\}$ we get
	\begin{align*}
	H_0 &= \{\,\mc\,\} & S_0 &= \{\,\mP(\mf(\mc))\,\} 
	\\
	H_{i+1} &= \bigcup_{k=0}^{i+1}\{\, \mf^{k}(\mc))\,\}
	& 
	S_{i+1} &= \{\, \mP(\mf(a)) \mid a\in H_{i+1}
	\,\}
	\\
	 &\mf^{i+1}(\mc) \in H_{i+1}\setminus H_i
	 &
	 &
	 \mP(\mf(\mf^{i+1}(\mc))) \in S_{i+1} \setminus S_i
	\end{align*}
\end{enumerate}



Issue \ref{enum:gilmore:transformation} was already implicitly 
addressed in 1960 \cite{Davis:1960:CPQ:321033.321034}
and refined in 1962 \cite{Davis:1962:MPT:368273.368557}
by Davis, Putnam, Longeman, and Loveland, 
which was the starting point for the development of efficient propositionally satisfiability checkers, i.e.~efficient modern SAT solvers.

\section{Resolution}

\section{InstGen}

Gilmore's prover blindly constructs new ground instances. 

\begin{definition}[\InstGen] Let $A, B$ be atoms and $\mcC,\mcD$ be clauses.
	\begin{gather*}
	\infer
	[{\InstGen}] 
	{(A\lor\mathcal C)\sigma\qquad (\lnot B\lor\mathcal D)\sigma}
	{A\lor\mathcal C\quad&\quad \lnot B\lor\mathcal D}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$
%		, $\sigma$ is proper
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{example}
	With \InstGen we immediately can derive a helpful clause from set
$S_{(\ref{ex:unsat:nexsx})} =
\{\,
{ \lnot\mE(x, \ms(x)))},\, 
{ \mE(\ms^k(y), \ms(\ms^k(y)))}
\,\}$ 
 introduced in Example \ref{ex:unsat:nexsx}. 
\begin{gather*}
\infer[x\mapsto\msucc^k(y)]{
	{\colLo \lnot\mE(\ms^k(y), \ms(\ms^k(y))))} \qquad
	{\colG \mE(\ms^k(y), \ms(\ms^k(y)))}
}{
	{ \lnot\mE(x, \ms(x)))} &
	{\colHi \mE(\ms^k(y), \ms(\ms^k(y)))}
}
\end{gather*}
	
\end{example}

\begin{example}
	With \InstGen we cannot derive any new clause from satisfiable set 
	$S_{(\ref{ex:sat:exy})  } = \{\,\mE(\mzero,y)\,\}$ 
	introduced in Example \ref{ex:sat:exy}.
\end{example}

\begin{lemma}
	The set of clauses 
	$S_0 = S \cup
	\{ 
		 A\lor\mathcal C, \lnot B\lor\mathcal D
	\}$ 
	is satisfiable if and only if
	the derived set of clauses 
	$S_1 = S_0 \cup \{ (A\lor\mathcal C)\sigma, (\lnot B\lor\mathcal D)\sigma\}$
	with $\sigma = \mgu(A,B)$ 
	is satisfiable.
\end{lemma}

\begin{proof}
	
\end{proof}

\begin{procedure}[Inst-Gen-Loop]\label{proc:inst:gen:loop}
	As in Gilmore's prover (Procedure \ref{proc:gilmore's:prover}) 
	we translate the negation of our formula $F$ into an equisatisfiable set of clauses 
	$S_0$. Then we introduce a distinct constant symbol 
	$\consbot\not\in\mcF(S_0)$ even when there are constant symbols in the signature. 
	We start our first iteration with $k=0$.
	
	\begin{enumerate}
		\item\label{step:igl:skbot}
		We construct a set $S_{k}\,\subsbot$ of ground instances from $S_k$
		where instantiator $\subsbot := \{ x\mapsto \consbot \mid x\in\var(S_k) \} $ 
		substitutes all occurring variables with constant symbol $\consbot$.
%		
		\item\label{step:igl:sksat} We check decidable satisfiability of $S_k\,\subsbot$ with a \SAT or \SMT-solver.
		
		If $S_k\,\subsbot$ is unsatisfiable then we exit the procedure and report {\myem unsatistifiablity of $S$}.
		
		\item\label{step:igl:model} The set $S_k\,\subsbot$ is satisfiable, hence we can retrieve a model $\mcM_k \models S_k\subsbot$.
		We select one literal $L_i = \sel(\mcC_i)$ per clause $\mcC_i \in S_k$ 
		such that the each grounded selected literal holds in model
		$\mcM_k\models L_i\subsbot$ for all $i\leq | S_k |$.
		
		\item\label{step:igl:clashes} We search for pairs of selected literals $(A, \lnot B) = (L_i, L_j^c)$
		such that the most general unifier $\tau = \mgu(A,B)$ exists.
		
		\item We set $S_{k+1} ::= S_k$ and for each pair of clashing literals $(L_i, L^c_j)$ 
		we apply \InstGen to the originating clauses 
		$\{\, \mcC_{i}, \mcC_{j}\, \} = \{\,L_i\lor\mcC, L_j\lor\mcD\,\}$
%		where $\sel(\mcC_{i_1}) = L_i$ and $\sel(\mcC_{i_2})=\lnot L_j$
		to add new (not necessarily ground) instances to $S_{k+1}$.
		
		If no new clauses were added, i.e.~$S_{k+1} = S_k$ after all pairs were processed we exit the procedure and report {\myem satistifiablity of $S$}.
		
		\item We increase $k$ by $1$ and continue with step \ref{step:igl:skbot}. 
		
	\end{enumerate}
	

\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {passive clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) { \SMT};
		\node (un) [mycircle] at (-15em,8em) {un\-satis\-fiable};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {active clauses};
		
		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick, 
%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) { \InstGen};
		\node (sa) [mycircle] at (16em,8em) {satis\-fiable};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};
		
		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);
		\end{tikzpicture}
		\caption{Proving loop with \SMT and \InstGen}
		\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}
\end{procedure}

\begin{example} The selected literals of the first and the second clause change between iterations.
%	1. p(a) | q(a)
%	2. p(a) | ~q(X)
%	3. ~p(X)
\begin{align*}
S_0 &= \{\,
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x) 
\,\}
\\
S_0\subsbot &=\{\, 
	{\colHi\mP(\ma)}\lor\mQ(\ma),
	{\colHi\mP(\ma)}\lor\lnot\mQ(\consbot),
	{\colHi\lnot\mP(\consbot)} 
\,\}
\tag{satisfiable}
\\
&\qquad\infer[
	x\mapsto\ma
	]{
		{\colG \mP(\ma)\lor\mQ(\ast)}\quad\lnot\mP(\ma)
	}{
		\mP(\ma)\lor\mQ(\ast) & \lnot\mP(x)
	} 
\tag*{$\ast\in\{\ma,y\}$}
\\
S_1 &=\{\, 
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x),
	\lnot\mP(\ma) 
\,\}
\\
S_1\subsbot &=\{\,
	{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
	{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
	{\colHi\lnot\mP(\consbot)},
	{\colHi\lnot\mP(\ma)} 
\,\}
\tag{satisfiable}
\\
&\qquad\infer[
y\mapsto\ma
]{
	{\colG \mP(\ma)\lor\mQ(\ma)}\quad\mP(\ma)\lor\lnot\mQ(\ma)
}{
	\mP(\ma)\lor\mQ(\ma) & \mP(\ma)\lor\lnot\mQ(y)
} 
\\
S_2 &=\{\, 
\mP(\ma)\lor\mQ(\ma),
\mP(\ma)\lor\lnot\mQ(y),
\lnot\mP(x),
\lnot\mP(\ma),
\mP(\ma)\lor\lnot\mQ(\ma) 
\,\}
\\
S_2\subsbot &=\{\,
{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
{\colHi\lnot\mP(\consbot)},
{\colHi\lnot\mP(\ma)},
{\colLo\mP(\ma)}\lor{\colLo\lnot\mQ(\ma)} 
\,\}
\tag{unsatisfiable}
\end{align*}
\end{example}

\begin{lemma}
	The $\tau = \mgu(A,B)$ in Procedure \ref{proc:inst:gen:loop}, 
	step \ref{step:igl:clashes} is a proper instantiator, 
	i.e.~it is not a variable renaming.
\end{lemma}
\begin{proof}
	Assume $\tau$ in Procedure \ref{proc:inst:gen:loop}
	is a renaming, then we have 
	$A\tau\subsbot = A\subsbot$,
	$B\tau\subsbot = B\subsbot$,
	and by definition of the most general unifier $A\tau = B\tau$. 
	Hence $A\subsbot = B\subsbot$ which contradicts that 
	$M_k\models A\subsbot, \lnot B\subsbot$ 
	by definition of step \ref{step:igl:model}. 
	Hence the assumption is false and $\tau$ must be a proper instantiator.
\end{proof}





\begin{example}\label{ex:unsat2}
Let $S_0 = S_{(\ref{ex:unsat:nexsx})}$ be the set of unsatisfiable clauses from Example \ref{ex:unsat:nexsx}. 
Then the initial set of ground instances 
$S_0\subsbot =\
\{\,
{ \lnot\mE(\consbot, \ms(\consbot)))}, 
{ \mE(\ms^k(\consbot), \ms(\ms^k(\consbot)))}
\,\}$
is satisfiable with domain $A = \{ \consbot, \ms(\consbot), \ms^k(\consbot), \ms(\ms^k(\consbot)) \}$
and predicate interpretation 
$\mE^\mcI = \{ (\ms^k(\consbot), \ms(\ms^k(\consbot))
 \} \subseteq A^2$. 
% 
 With just two unit clauses we easily find the only pair of clashing literals and compute the unifier
 $\tau = \{ x\mapsto \msucc(s^k(y)) \}$. 
 By application of \InstGen we construct our next set of clauses
$
S_1 =\
S_0 \disjointunion
 \{\,
% { \lnot\mE(x, \ms(x)))},\  
% { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\ms^k(y), \ms(\ms^k(y)))}
 \,\}
 $ 
 and get an unsatisfiable set of ground instances $S_1\subsbot$.
\end{example}




\section{Equality}



	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we don't find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

\begin{align*}
	 x \mEQ x & \tag*{reflexivity} \\
	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	x_1\mNE y_1\lor x_2\mNE y_2
	\lor x_1\mNE x_2
	\lor y_1\mEQ y_2
	\tag*{$\mEQ$-congruence}
\end{align*}

\begin{align*}
	x \mEQ x & \tag*{reflexivity} 
	\\
	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
	\\
	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
	\\
	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	(x_1\mEQ y_1
	\land x_2\mEQ y_2
	\land x_1\mEQ x_2)
	\limp y_1\mEQ y_2
	& \quad P\in\mcFPn[2]
		\tag*{$\mEQ$-congruence}
\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.

\section{Examples}

\begin{example}
	\begin{align*}
	\ack(\mzero,y) &\mEQ \msucc(y) \\
	\ack(\msucc(x),\mzero) &\mEQ \ack(x, \msucc(\mzero)) \\
	\ack(\msucc(x),\msucc(y)) &\mEQ \ack(x, \ack(\msucc(x),y)) \\
	\\
%	x &\mNE \msucc(x)\\
	x &\mNE y \lor \msucc(x) \mEQ \msucc(y)\\
	\mzero &\mNE \msucc(x)\\
	\end{align*}
\end{example}



