% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automated Theorem Proving}

\input{epigraphs/syllogism}

In this chapter we demonstrate the implications of undecidability of first order logic 
for instantiation-based proving procedures like Gilmore's prover or the InstGen framework.
%An we judge the procedures by there theoretical performance on decidable fragments. 
%
We know by Herbrand's theorem 
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Hebrand model. 
And we know by compactness 
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving 
is to find an unsatisfiable set of ground instances of a given set of clauses.
%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.

To actually prove a theorem 
we first make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we utilize existing efficient transformation algorithms \cite[...]{tseitin70, PLAISTED1986293}
from an arbitrary formula to an equisatisfiable set of clauses, 
i.e.the formula is satisfiable if and only if the set of clauses is satisfaible, 
but formula and set of clauses may have different models.
To actually find an unsatisfiable set of unsatisfiable ground instances
usually a sequence of sets of ground instances is generated.


%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula $F$ is satisfiable if and only if a set of clauses $S$ is satisfiable 
%%	then we call $F$ and $S$ are equisatisfiable.
%\end{definition}
%
%Tseitin's transformation \cite{tseitin70} -- 
%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.




\section{Gilmore's Prover}

Paul Gilmore presented the first {\myem implementation} of an automated first order theorem prover in 1960 \cite{5392528}.
%
The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:syllo}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C  
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula to conjunctive normal form $\lnot F \equiv A\land B \land\lnot C$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	As last step we transform the single formula in 
	the set of ground instances $S_0$ into a disjunctive normal form 
	for easy satisfiability checking.
%
\begin{gather*}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\end{gather*}
Both conjunctions contain complementary literals and we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

Gilmore's procedure will always terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability
which cannot exist because of undecidability of satisfiability in first order logic.

It is easy to see that for a set of clauses without non-constant function symbols
we can stop the procedure after one iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$.
%
On the other hand the procedure will never terminate 
even for very simple satisfiable sets where the Herbrand universe is infinite, 
i.e.~there is at least on non-constant function symbol.

\begin{example}
	Consider the formula 
	$F = \forall x\exists y\,\lnot\mE(x,y)$
	which is a member of the Ackermann class $\forall^*\exists\forall^*$ 
	where satisfiability is decidable.
	The set of clauses 
	$S = \{ \lnot\mE(x,\msucc(x)) \}$ is equisatisfiable to $F$.
	The procedure yields the following sequences of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \lnot\mE(\mzero,\msucc(\mzero))
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\msucc^i(\mzero),\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
\end{example}


\begin{example}\label{ex:simplesat}
%	Consider the unsatisfiable set of clauses $S=\{ \mN(\msucc^{k+2}(\mzero)), \lnot\mN(\msucc(x))  \}$
%	\begin{align*}
%	H_{0} :=&\  \{ \mzero \} 
%	&
%	S_{0} :=&\ \{ \mN(\msucc^{k+2}(\mzero)), \lnot\mN(\msucc(\mzero))
%	\}
%	\tag*{satisfiable}
%	\\
%	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
%	&
%	S_{i+1} :=&\ S_i \disjointunion \{ \lnot\mN(\msucc(\msucc^i(\mzero)))
%	\}
%	\tag*{satisfiable}
%	\end{align*}
\end{example}

 

\begin{example}\label{ex:succ}
%	Consider the satisfiable set of clauses 
%	$S_{\ref{ex:succ}} = \{ 
%	\lnot\mE(\msucc(x), \mzero), 
%	\lnot \mE(\msucc(x), \msucc(y)) \lor \mE(x,y)
%	\}$ with binary predicate symbol $\mE$, unary function symbol $\msucc$, and constant symbol $\mzero$.
%	\begin{align*}
%	H_0 :=&\quad \{ \mzero \} & \mcC_0' &= \{  
%	\lnot\mE(\msucc(\mzero), \mzero), 
%	\lnot \mE(\msucc(\mzero), \msucc(\mzero)) \lor \mE(\mzero,\mzero)
%	\}
%	\\
%	H_1 :=&\quad \{ \msucc(\mzero) \} & \mcC_1' &= \{ 
%		\lnot\mE(\msucc(\msucc(\mzero), \mzero),
%		\lnot \mE(\msucc(\msucc(\mzero)), \msucc(\msucc(\mzero))) \lor \mE(\msucc(\mzero),\msucc(\mzero))
%	 \}
%	 \\\ldots
%	 \\
%	 H_i :=&\quad \{ 
%	 \msucc(\msucc^i(\mzero)) \} & \mcC_i' &= \{  
%	 \lnot\mE(\msucc(\msucc^i(\mzero)), \mzero), 
%	 \lnot \mE(\msucc(\msucc^i(\mzero)), \msucc(\msucc^i(\mzero)) \lor \mE(\msucc^i(\mzero),\msucc^i(\mzero))
%	 \}
%	\end{align*} 
%	It is easy to see that each $\mcC_i'$ is satisfiable and Gilmore's prover will proceed for ever.
%	\begin{align*}
%	A := &\ \{ \mzero \} \\
%	s := &\ \mzero\mapsto\mzero \\
%	\mE := &\ \{\ \} \subseteq A\times A
%	\end{align*}
\end{example}

\begin{definition}
	For a unary function symbol $\msucc$,
	$i\in\mathbb{N}$ and an arbitrary term $t\in\mcTf$ we introduce the notation
	\[
\begin{array}{rl}
\msucc^0(t) &:=\ t \\
\msucc^{i+1}(t) &:=\ \msucc(\msucc^i(t))
\end{array}
	\]
\end{definition}



Gilmore's prover has two main disadvantages:
\begin{enumerate}
	\item The generation of all instances up to a certain term depth.
	\item The transformation to a disjunctive normal form to check unsatisfiability.
\end{enumerate}

The second was already addressed by Davis and Putnam in 1960
which lead to the development of effective SAT Solvers.

\begin{example}\label{ex:unsatE2}
	Consider the set of clauses 
	$S =\
	\{
	{ \lnot\mE(x, \ms(x)))}, 
	{ \mE(\ms^k(y), \ms(\ms^k(y)))}
	\}$ 
	where the set of instances $S_k$ is clearly unsatisfiable for any $k\in\mathbb{N}$.
%	
\begin{align*}
H_{0} :=&\  \{ \mc \} 
&
S_{0} :=&\ \{ 
{\colHi\lnot\mE(\mc,\msucc(\mc))},\
{\colEm \mE(\ms^k(\mc), \ms(\ms^k(\mc)))}
\}
\\
H_{i} :=&\ \{ \mc, \ldots, \msucc^i(\mc) \} 
&
S_{i} \supsetneq&\
\{
{\colEm \lnot\mE(\msucc^i(\mc),\msucc(\msucc^i(\mc)))},\
{\mE(\ms^k(\msucc^i(\mc)), \ms(\ms^k(\msucc^i(\mc))))}
\}
\end{align*}
\end{example}

\section{InstGen}

\begin{example}\label{ex:unsat2}
Let $S$ be the set of clauses 
$S_0 =\
\{
{ \lnot\mE(x, \ms(x)))}, 
{ \mE(\ms^k(y), \ms(\ms^k(y)))}
\}$
 from Example \ref{ex:unsatE2}. 
 The selected literals clash with unifier 
 $\sigma = \{ x\mapsto \msucc(s^k(y)) \}$ and we get a new instance
and $S_1 =\
 \{
 { \lnot\mE(x, \ms(x)))},\  
 { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\ms^k(y), \ms(\ms^k(y)))}
 \}$
\end{example}




\section{Equality}



	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we cannot find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

\begin{align*}
	 x \mEQ x & \tag*{reflexivity} \\
	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	x_1\mNE y_1\lor x_2\mNE y_2
	\lor x_1\mNE x_2
	\lor y_1\mEQ y_2
	\tag*{$\mEQ$-congruence}
\end{align*}

\begin{align*}
	x \mEQ x & \tag*{reflexivity} 
	\\
	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
	\\
	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
	\\
	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	(x_1\mEQ y_1
	\land x_2\mEQ y_2
	\land x_1\mEQ x_2)
	\limp y_1\mEQ y_2
	& \quad P\in\mcFPn[2]
		\tag*{$\mEQ$-congruence}
\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.



