% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automated Theorem Proving}

\input{epigraphs/syllogism}

In this chapter we demonstrate the implications of undecidability of first order logic 
for instantiation-based proving procedures like Gilmore's prover or the InstGen framework.
%An we judge the procedures by there theoretical performance on decidable fragments. 
%
We know by Herbrand's theorem 
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Hebrand model. 
And we know by compactness 
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving 
is to find an unsatisfiable and finite set of ground instances for a given set of clauses.
In general a failure in this approach does not show satisfiability of the given set of clauses.
%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.


To actually prove a theorem 
we first make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we utilize existing efficient transformation algorithms \cite{tseitin70, PLAISTED1986293}
from an arbitrary formula to an equisatisfiable set of clauses, 
i.e.~the formula is satisfiable if and only if the set of clauses is satisfiable, 
but the original formula and the resulting set of clauses may have very different models.
It is sufficient to just guess an unsatisfiable set of ground instances. 
But usually a sequence of sets of ground instances is generated 
such that eventually an unsatisfiable one is found for arbitrary unsatisfiable set of clauses.



%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula $F$ is satisfiable if and only if a set of clauses $S$ is satisfiable 
%%	then we call $F$ and $S$ are equisatisfiable.
%\end{definition}
%
%Tseitin's transformation \cite{tseitin70} -- 
%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.




\section{Gilmore's Prover}

In 1960 Paul Gilmore presented the first {\myem implementation} of an automated 
theorem prover \cite{5392528} for first order logic without equality,
which happened to use an instantiation-based approach. 
The procedure was theoretically complete, i.e.~for every valid formula 
a proof will be found eventually.

In practice this prover ran into memory issues or time outs more often than not.
We will discuss reasons for this inefficiency after we have described and demonstrated the procedure.

The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:syllo}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C  
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula to conjunctive normal form $\lnot F \equiv A\land B \land\lnot C$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	As last step we transform the single formula in 
	the set of ground instances $S_0$ into a disjunctive normal form 
	for easy satisfiability checking.
%
\begin{gather*}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\end{gather*}
Both conjunctions contain complementary literals and we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

Gilmore's procedure will always terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability
which cannot exist because of undecidability of satisfiability in first order logic.

It is easy to see that for a set of clauses without non-constant function symbols
we can stop the procedure after one iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$.
%
On the other hand the procedure will never terminate 
even for very simple satisfiable sets where the Herbrand universe is infinite, 
i.e.~there is at least one non-constant function symbol.

\begin{definition}
	For an unary function symbol $\msucc$, a natural number
	$i\in\mathbb{N}$, and an arbitrary term $t\in\mcTf$ we introduce the notation
	\[
	\begin{array}{rl}
	\msucc^0(t) &:=\ t \\
	\msucc^{i+1}(t) &:=\ \msucc(\msucc^i(t))
	\end{array}
	\]
\end{definition}

\begin{example}
	Consider the formula 
	$G = \exists x\forall y\,\mE(x,y)$
	which is a member of the Ackermann prefix class $\forall^*\exists\forall^*$ 
	of first order formulae
	where the satisfiability problem is decidable.
	The set of clauses 
	$S = \{ \mE(\mzero,y) \}$ is equisatisfiable to $G$ and clearly satisfiable.
	The procedure yields the following sequence of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \mE(\mzero,\mzero)
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\mzero,\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
	So Gilmore's prover wouldn't terminate on this simple and decidable problem.
\end{example}



Gilmore's prover has two main disadvantages:
\begin{enumerate}
	\item The generation of all instances up to a certain term depth.
	\item The transformation to a disjunctive normal form to check unsatisfiability.
\end{enumerate}

The second was already addressed by Davis and Putnam in 1960
which lead to the development of effective SAT Solvers.

\begin{example}\label{ex:unsatE2}
	Consider the set of clauses 
	$S =\
	\{
	{ \lnot\mE(x, \ms(x)))}, 
	{ \mE(\ms^k(y), \ms(\ms^k(y)))}
	\}$ 
	where the sets of instances $S_i$ are satisfiable for $i<k$,
	but the set of instances $S_{i+1}$ is clearly unsatisfiable for $i+1 = k\in\mathbb{N}$.
%	
\begin{align*}
H_{0} :=&\  \{ \mc \} 
&
S_{0} :=&\ \{ 
{\colHi\lnot\mE(\mc,\msucc(\mc))},\
{\colEm \mE(\ms^k(\mc), \ms(\ms^k(\mc)))}
\}
\\
H_{i+1} :=&\ H_i \disjointunion \{ \msucc^{i+1}(\mc) \} 
&
S_{i+1} \supsetneq&\
\{
{\colEm \lnot\mE(\msucc^{i+1}(\mc),\msucc(\msucc^{i+1}(\mc)))},\
{\mE(\ms^k(\msucc^{i+1}(\mc)), \ms(\ms^k(\msucc^{i+1}(\mc))))}
\}
\end{align*}
In this case the guess for a finite unsatisfiable set of ground instances appears more easy and yields a smaller set.
\[
	\{ 
		{\lnot\mE(\mc,\msucc(\mc))},\
		{\colHi \mE(\ms^k(\mc), \ms(\ms^k(\mc)))},
		{\colLo \lnot\mE(\msucc^{k}(\mc),\msucc(\msucc^{k}(\mc)))}		
	\}
\]
\end{example}

\section{InstGen}

Gilmore's prover blindly constructs new ground instances. 

\begin{definition}[Inst-Gen]
	\begin{gather*}
	\infer
	[\atop\text{Inst-Gen}] 
	{(A\lor\mathcal C)\sigma\qquad (\lnot B\lor\mathcal D)\sigma}
	{A\lor\mathcal C\quad&\quad \lnot B\lor\mathcal D}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$, $\sigma$ is proper\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{lemma}
	The set of clauses 
	$S_0 = S \cup
	\{ 
		 A\lor\mathcal C, \lnot B\lor\mathcal D
	\}$ 
	is satisfiable if and only if
	the derived set of clauses 
	$S_1 = S_0 \cup \{ (A\lor\mathcal C)\sigma, (\lnot B\lor\mathcal D)\sigma\}$
	with $\sigma = \mgu(A,B)$ 
	is satisfiable.
\end{lemma}

\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {passive clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) {SMT};
		\node (un) [mycircle] at (-15em,8em) {un\-satis\-fiable};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {active clauses};
		
		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick, 
%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) {\large InstGen};
		\node (sa) [mycircle] at (16em,8em) {satis\-fiable};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};
		
		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);
		\end{tikzpicture}
		\caption{Proving loop with SMT and InstGen}
		\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}



InstGen introduces a new distinct constant $\bot\not\in\mcF$

\begin{example}\label{ex:unsat2}
Let $S$ be the set of clauses from Example \ref{ex:unsatE2}. 
Then the initial set of ground instances 
$S_0 =\
\{
{ \lnot\mE(\bot, \ms(\bot)))}, 
{ \mE(\ms^k(\bot), \ms(\ms^k(\bot)))}
\}$
is satisfiable with domain $A = \{ \bot, \ms(\bot), \ms^k(\bot), \ms(\ms^k(\bot)) \}$
and predicate interpretation 
$\mE^\mcI = \{ (\ms^k(\bot), \ms(\ms^k(\bot))
 \} \subseteq A^2$. 
 
 With just two unit clause ew easily find candidates for the application of the InstGen rule 
 $\sigma = \{ x\mapsto \msucc(s^k(y)) \}$ and we get the next set of ground instances
$S_1 =\
 \{
 { \lnot\mE(x, \ms(x)))},\  
 { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\ms^k(y), \ms(\ms^k(y)))}
 \}$
\end{example}




\section{Equality}



	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we cannot find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

\begin{align*}
	 x \mEQ x & \tag*{reflexivity} \\
	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	x_1\mNE y_1\lor x_2\mNE y_2
	\lor x_1\mNE x_2
	\lor y_1\mEQ y_2
	\tag*{$\mEQ$-congruence}
\end{align*}

\begin{align*}
	x \mEQ x & \tag*{reflexivity} 
	\\
	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
	\\
	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
	\\
	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	(x_1\mEQ y_1
	\land x_2\mEQ y_2
	\land x_1\mEQ x_2)
	\limp y_1\mEQ y_2
	& \quad P\in\mcFPn[2]
		\tag*{$\mEQ$-congruence}
\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.



