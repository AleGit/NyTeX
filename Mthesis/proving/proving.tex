% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automation}

\input{epigraphs/syllogism}

In this chapter we demonstrate the implications of undecidability of first order logic 
for instantiation-based proving procedures with Gilmore's prover and the InstGen framework.
It seems natural to expect decision procedures for decidable fragments of first order logic.

%An we judge the procedures by there theoretical performance on decidable fragments. 
%
We know by Herbrand's theorem 
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Hebrand model. 
And we know by compactness 
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving 
is to find an unsatisfiable and finite set of ground instances for a given set of clauses.
In general a failure in this search does not show satisfiability of the given set of clauses.
%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.


To actually prove a theorem 
we first make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we utilize existing efficient transformation algorithms \cite{tseitin70, PLAISTED1986293}
from an arbitrary formula to an equisatisfiable set of clauses, 
i.e.~the formula is satisfiable if and only if the set of clauses is satisfiable, 
but the original formula and the resulting set of clauses may have very different models.
It is sufficient to just guess an unsatisfiable set of ground instances. 
But usually a sequence of sets of ground instances is generated 
such that eventually an unsatisfiable one is found for arbitrary unsatisfiable set of clauses.



%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula $F$ is satisfiable if and only if a set of clauses $S$ is satisfiable 
%%	then we call $F$ and $S$ are equisatisfiable.
%\end{definition}
%
%Tseitin's transformation \cite{tseitin70} -- 
%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.




\section{Gilmore's Prover}

In 1960 Paul Gilmore presented the first {\myem implementation} of an automated 
theorem prover \cite{5392528} for first order logic without equality,
which happened to use an instantiation-based approach. 
The procedure is theoretically complete, i.e.~for every valid formula 
a proof can be found eventually.

In practice this prover ran into memory issues or time outs more often than not.
We will discuss reasons for this inefficiency after we have described and demonstrated the procedure.

The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:syllo}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C  
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula to conjunctive normal form $\lnot F \equiv A\land B \land\lnot C$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	As last step we transform the single formula in 
	the set of ground instances $S_0$ into a disjunctive normal form 
	for easy satisfiability checking.
%
\begin{gather*}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\end{gather*}
Both conjunctions contain complementary literals and we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

\begin{procedure}[Gilmore's Prover]
	We translate the negation of a formula $\lnot F$ into an equisatisfiable set of clauses 
	$\lnot F \approx S = \bigcup_{i=1}^{n} \mcC_i$.
	
	We start our first iteration with $i=0$.
	\begin{enumerate}
		
		\item We create $H_i$ (see Definition \ref{def:hk})
		and the set of instances $S_i$ by substituting all variables 
		in each clause by terms from $H_k$ in any possible permutation.
		\[ S_i = \bigcup_{i=1}^{n} 
		\{\,
			\mcC_i\sigma \mid \mcC_i \in S,\,\sigma: \mcV\to H_i
		\,\}
		\]
		
		\item We translate $S_i$ into an equivalent disjunctive normal form 
		(a disjunction of conjunctions)
		where satisfiability is easily checked.
		
		

\item When every conjunction contains a pair of complementary literals then we exit the procedure and report unsatisfiability of $\lnot F$.

Otherwise we increase $i$ by one and continue with step 1.
		
		
	\end{enumerate}
	
\end{procedure}

Gilmore's procedure will always terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability in first order logic
which does not exist because of undecidability of satisfiability in first order logic.

It is easy to see that for a set of clauses without non-constant function symbols
we can stop the procedure after one iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$.
%
%On the other hand the procedure will never terminate 
%even for very simple satisfiable sets where the Herbrand universe is infinite, 
%i.e.~there is at least one non-constant function symbol.

\begin{definition}
	For an unary function symbol $\msucc$, a natural number
	$i\in\mathbb{N}$, and an arbitrary term $t\in\mcTf$ we introduce the notation
	\[
	\begin{array}{rl}
	\msucc^0(t) &:=\ t \\
	\msucc^{i+1}(t) &:=\ \msucc(\msucc^i(t))
	\end{array}
	\]
\end{definition}

\begin{example}\label{ex:satEzy}
	Consider the formula 
	$G = \exists x\forall y\,\mE(x,y)$
	which is a member of the Ackermann prefix class $\forall^*\exists\forall^*$ 
	of first order formulae
	where the satisfiability problem is decidable.
	The set of clauses 
	$S = \{\,\mE(\mzero,y)\,\}$ is equisatisfiable to $G$ and clearly satisfiable.
	The procedure yields the following sequence of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \mE(\mzero,\mzero)
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\mzero,\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
	So Gilmore's prover wouldn't terminate on this simple and decidable problem.
\end{example}



We observe three main disadvantages in Gilmore's procedure.
\begin{enumerate}
	\item\label{enum:gilmore:generation}
	 The generation of instances is unguided. 
	With each iteration exponentially many 
	new instances are added
	-- depending on the number and the arities of used symbols.
	\begin{align*}
		H'_0 &= \{\,\mc \,\}  
		&H_0 = H'_0
		\\
		H'_1 &= \{\,\mf(\mc), \mg(\mc,\mc) \,\} 
		&H_1 = H_0 \cup H'_1
		\\
		H'_2 &= 
		\{\, 
			\mf(\mf(\mc)), \mf(\mg(\mc,\mc)), 
			\mg(\mc, \mf(\mc)), \mg(\mc, \mg(\mc,\mc)), \\
			&\qquad \mg(\mf(\mc), \mc), \mg(\mf(\mc), \mf(\mc)), \mg(\mf(\mc), \mg(\mc,\mc)), \\
			&\qquad \mg(\mg(\mc,\mc),\mc), \mg(\mg(\mc,\mc),\mf(\mc)), \mg(\mg(\mc,\mc), \mg(\mc,\mc)) 
		\,\} 
		&H_2 = H_1 \cup H'_2	
		\\
		H'_{i+1} &= 
			\{\, \mf(a), \mg(a,b), \mg(b,a) \mid a\in H'_i, b\in H_i \, 
			\}
			&H_i = \bigcup_{j=1}^{i} H'_j
		\end{align*}\\[-1.0em]		
		This makes disadvantage No.~\ref{enum:gilmore:transformation} 
		which is invoked at every iteration even worse.
	\item\label{enum:gilmore:transformation} 
	The check for unsatisfiability is far from efficient.
	The transformation from a set of clauses to a formula 
	in disjunctive normal form\footnote{
		If a general algorithm with polynomial complexity existed 
		that translates 
		an arbitrary propositional formula into 
		an equi-\allowbreak{}satisfiable formula in disjunctive normal 
		form (where satisfiability is a linear check) 
		then $\mathsf{SAT}$ would be in $\mcP$
%		$\mathsf{SAT}\in\mcP$  
		and $\mcP = \mcN\mcP$. 
	} 
	introduces an exponential 
	blow up of the size of the formula
	-- depending on the number of clauses $n$ in the set 
	and the number of literals $c_i$ per clause $\mcC_i$ we get the disjunction of
	$\prod_{1}^{n} c_i$ 
	conjunctions of $n$ literals.
	  \begin{align*}
	  \bigwedge_{i=1}^{n} 
	  \left(
	  	\bigvee_{j_i=1}^{c_i} p_{(i,j_i)} 
	  \right)
	  \ &\equiv
	  \bigvee_{(j_1,\ldots,j_n)}
	  \left(
	  	\bigwedge_{i=1}^{n} p_{(i,j_i)}
	  \right)
	  &\text{with }(j_1,\ldots,j_n)\in\prod_{i=1}^{n}\{ 1,\ldots,c_i \}
	\end{align*}
	In total the number of literals in the set of clauses is 
	$n\cdot \bar{c}_{arith}$, 
	while the equivalent disjunctive normal form contains 
	$(\bar{c}_{geom})^n\cdot n$ literals\footnote{
		%		$\prod_{1}^{n} c_i = (\bar{c}_{geom})^n$
		%		with the geometric mean 
		Geometric $\bar{c}_{geom} := \left(\prod_{1}^{n}c_i\right)^{\frac{1}{n}}$, 
		arithmetic $\bar{c}_{arith} := \left(\sum_{1}^{n}c_i\right)\cdot\frac{1}{n}$ mean, and
		%		where
				$\bar{c}_{geom} 
				\leq 
				\bar{c}_{arith}$.
	}.
	\begin{gather*}
%	a∧(b∨c)∧(d∨e∨f)
%	\\
%	\equiv
%	\\
%	(a∧b∧d)∨(a∧b∧e)∨(a∧b∧f)∨(a∧c∧d)∨(a∧c∧e)∨(a∧c∧f)
%\\
		\{ 1 \}\times\{1,2\}\times\{1,2,3\} = 
		\{
			(1,1,1),(1,1,2),(1,1,3),
			(1,2,1),(1,2,2),(1,2,3)
		\}
	\end{gather*}
	
	\item\label{enum:gilmore:termination}
	The procedure will not terminate for satisfiable sets 
	when at least one non-constant predicate symbol and 
	one non-constant function symbol are present in the signature.
	\begin{gather*}
	S=\{\,\mP(\mf(x)) \,\} \qquad H_0 = \{\,\mc\,\} \qquad S_0 = \{\,\mP(\mf(\mc))\,\} 
	\\
	\qquad H_i \subsetneq H_{i+1} = \bigcup_{k=0}^{i+1}\{\, \mf^{k}(\mc))\,\}
	\qquad S_{i} \subsetneq S_{i+1} = \{\, \mP(\mf(a)) \mid a\in H_{i+1}
	\,\}
	\end{gather*}
\end{enumerate}



The first was already addressed by Davis and Putnam in 1960 \cite{Davis:1960:CPQ:321033.321034}
which lead to the development of effective propositional SAT Solvers.

\begin{example}\label{ex:unsatE2}
	Consider the set of clauses 
	$S =
	\{\,
	{ \lnot\mE(x, \ms(x)))},\, 
	{ \mE(\ms^k(y), \ms(\ms^k(y)))}
	\,\}$ 
	where the sets of instances $S_i$ are satisfiable for $i<k$,
	but the set of instances $S_{i+1}$ is clearly unsatisfiable for $i+1 = k\in\mathbb{N}$.
%	
\begin{align*}
H_{0} :=&\ \{\,\mzero\,\} 
&
S_{0} :=&\ \{\, 
{\colHi\lnot\mE(\mzero,\msucc(\mzero))},\,
{\colEm \mE(\ms^k(\mzero),\,\ms(\ms^k(\mzero)))}
\,\}
\\
H_{i+1} :=&\ H_i \disjointunion \{\,\msucc^{i+1}(\mzero)\,\} 
&
S_{i+1} \supsetneq&\
\{\,
{\colEm \lnot\mE(\msucc^{i+1}(\mzero),\msucc(\msucc^{i+1}(\mzero)))},\,
{\mE(\ms^k(\msucc^{i+1}(\mzero)), \ms(\ms^k(\msucc^{i+1}(\mzero))))}
\,\}
\end{align*}
In this case the guess for a finite unsatisfiable set of ground instances appears feasible and yields a smaller set.
\[
	\{\, 
%		{\lnot\mE(\mc,\msucc(\mc))},\
		{\colHi \mE(\ms^k(\mzero), \ms(\ms^k(\mzero)))},
		{\colLo \lnot\mE(\msucc^{k}(\mzero),\msucc(\msucc^{k}(\mzero)))}		
	\,\}
\]
\end{example}

\section{InstGen}

Gilmore's prover blindly constructs new ground instances. 

\begin{definition}[\InstGen] Let $A, B$ be atoms and $\mcC,\mcD$ be clauses.
	\begin{gather*}
	\infer
	[{\InstGen}] 
	{(A\lor\mathcal C)\sigma\qquad (\lnot B\lor\mathcal D)\sigma}
	{A\lor\mathcal C\quad&\quad \lnot B\lor\mathcal D}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$
%		, $\sigma$ is proper
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{example}
	With \InstGen we cannot derive any new clause from satisfiable set 
	$S = \{\,\mE(\mzero,y)\,\}$ 
	introduced in Example \ref{ex:satEzy}.
\end{example}

\begin{example}
	With \InstGen we can derive a new clause from unsatisfiable set
$S =
\{\,
{ \lnot\mE(x, \ms(x)))},\, 
{ \mE(\ms^k(y), \ms(\ms^k(y)))}
\,\}$ 
 introduced in Example \ref{ex:unsatE2}. 
\begin{gather*}
\infer[x\mapsto\msucc^k(y)]{
	{\colLo \lnot\mE(\ms^k(y), \ms(\ms^k(y))))} \qquad
	{\colG \mE(\ms^k(y), \ms(\ms^k(y)))}
}{
	{ \lnot\mE(x, \ms(x)))} &
	{\colHi \mE(\ms^k(y), \ms(\ms^k(y)))}
}
\end{gather*}
	
\end{example}

\begin{lemma}
	The set of clauses 
	$S_0 = S \cup
	\{ 
		 A\lor\mathcal C, \lnot B\lor\mathcal D
	\}$ 
	is satisfiable if and only if
	the derived set of clauses 
	$S_1 = S_0 \cup \{ (A\lor\mathcal C)\sigma, (\lnot B\lor\mathcal D)\sigma\}$
	with $\sigma = \mgu(A,B)$ 
	is satisfiable.
\end{lemma}

\begin{proof}
	
\end{proof}

\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {passive clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) {SMT};
		\node (un) [mycircle] at (-15em,8em) {un\-satis\-fiable};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {active clauses};
		
		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick, 
%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) {\large InstGen};
		\node (sa) [mycircle] at (16em,8em) {satis\-fiable};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};
		
		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);
		\end{tikzpicture}
		\caption{Proving loop with SMT and InstGen}
		\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}



InstGen introduces a new distinct constant $\bot\not\in\mcF$

\begin{example}\label{ex:unsat2}
Let $S$ be the set of clauses from Example \ref{ex:unsatE2}. 
Then the initial set of ground instances 
$S_0 =\
\{
{ \lnot\mE(\bot, \ms(\bot)))}, 
{ \mE(\ms^k(\bot), \ms(\ms^k(\bot)))}
\}$
is satisfiable with domain $A = \{ \bot, \ms(\bot), \ms^k(\bot), \ms(\ms^k(\bot)) \}$
and predicate interpretation 
$\mE^\mcI = \{ (\ms^k(\bot), \ms(\ms^k(\bot))
 \} \subseteq A^2$. 
 
 With just two unit clause ew easily find candidates for the application of the InstGen rule 
 $\sigma = \{ x\mapsto \msucc(s^k(y)) \}$ and we get the next set of ground instances
$S_1 =\
 \{
 { \lnot\mE(x, \ms(x)))},\  
 { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\ms^k(y), \ms(\ms^k(y)))}
 \}$
\end{example}




\section{Equality}



	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we cannot find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

\begin{align*}
	 x \mEQ x & \tag*{reflexivity} \\
	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	x_1\mNE y_1\lor x_2\mNE y_2
	\lor x_1\mNE x_2
	\lor y_1\mEQ y_2
	\tag*{$\mEQ$-congruence}
\end{align*}

\begin{align*}
	x \mEQ x & \tag*{reflexivity} 
	\\
	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
	\\
	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
	\\
	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	(x_1\mEQ y_1
	\land x_2\mEQ y_2
	\land x_1\mEQ x_2)
	\limp y_1\mEQ y_2
	& \quad P\in\mcFPn[2]
		\tag*{$\mEQ$-congruence}
\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.

\section{Examples}

\begin{example}
	\begin{align*}
	\ack(\mzero,n) &\mEQ \msucc(n) \\
	\ack(\msucc(m),\mzero) &\mEQ \ack(m, \msucc(\mzero)) \\
	\ack(\msucc(m),\msucc(n)) &\mEQ \ack(m, \ack(\msucc(m),n))
	\end{align*}
\end{example}



