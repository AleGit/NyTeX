% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automation}

\input{epigraphs/syllogism}

In this chapter we demonstrate refutation complete proving procedures.
It seems natural to expect decision procedures for decidable fragments 
(Section \ref{sec:decidable:fol:fragments})
or decidable theories (Section \ref{sec:decidable:fol:theories}),
but we will see in simplest examples that this does not follow 
from refutation completeness.


%An we judge the procedures by there theoretical performance on decidable fragments. 
%
We know by Herbrand's theorem 
%(\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of (non-ground) clauses
and each finite set of ground instances of a satisfiable set of (non-ground) clauses
has a Hebrand model. 
And we know by compactness 
%(\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses is satisfiable then this set is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving 
is to find an unsatisfiable and finite set of ground instances for a given set of clauses.
In general a failure in this search does not show satisfiability of the given set of clauses.
In practice we make many detours in the search and we experience very finite resources of space and time. 
In theory we have no bound on the size of the smallest set of unsatisfiable ground instances.

%So the central idea of instantiation-based first order theorem proving is the
%translation of an undecidable problem into a (potentially infinite) sequence of decidable problems.


To actually prove a theorem 
we first make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we efficiently transform the negated formula into an {\myem equisatisfiable} set of clauses,
i.e.~the formula is satisfiable if and only if the set of clauses is satisfiable.
%This can be done efficiently with Skolemization \cite{books/el/RV01/Hahnle01} and Tseitin-transformation \cite{tseitin70, PLAISTED1986293} as shown in \cite{Nonnengart01computingsmall}.

It would sufficient to just luckily guess an unsatisfiable set of ground instances. 
But usually a sequence of systematically growing sets of ground instances is generated 
such that an unsatisfiable one will be found 
for an arbitrary unsatisfiable set of clauses
eventually.



%
%\section{Equisatisfiability}
%
%\begin{definition}
%%	If a formula $F$ is satisfiable if and only if a set of clauses $S$ is satisfiable 
%%	then we call $F$ and $S$ are equisatisfiable.
%\end{definition}
%
%Tseitin's transformation \cite{tseitin70} -- 
%
%
%There are some optimization to this transformation, e.g.~by Plaisted and Greenbaum in 1986 \cite{PLAISTED1986293}.



\section{Prenex CNF and clausal form}

In the previous chapter we stated the axioms and conjectures of theories in \FOF. 
Since Gilmore's prover, resolution and \InstGen work on set of clauses we present
the clausal forms of axioms in Table \ref{tab:presburger:axioms:clauses} .

\begin{table}[hbt]	
	\begin{align*}
	x\mEQ x,\ 
	x\mNE y\lor y\mEQ x,\ 
	x\mNE y\lor y\mNE z\lor x\mEQ z
	\tag*{equivalence}
	\\
	x\mNE y\lor \msucc(x)\mEQ\msucc(y) 
	\tag*{congruence of $\msucc$}
	\\
	\msucc(x) \mNE 0,\ 
	\msucc(x) \mNE \msucc(y) \lor x \mEQ y
	\tag*{natural numbers}
	\\
	x_1\mNE y_1\lor x_2\mNE y_2\lor x_1+y_1 \mEQ x_2+y_2
	\tag*{congruence of $+$}
	\\
	x + 0 \mEQ x,\ 
	x+\msucc(x) \mEQ \msucc(x+y)
	\tag*{addition}
	\\
	x_1\mNE y_1\lor x_2\mNE y_2\lor x_1\times y_1 \mEQ x_2\times y_2
	\tag*{congruence of $\times$}
	\\
	x \times 0 \mEQ 0,\ 
	x \times\msucc(y) \mEQ (x\times y) + x
	\tag*{multiplication}
	\\[0.5em]
	\lnot G_i(0) \lor \boxed{G(\mc_i)} \lor G_i(y),\ 
	\lnot G_i(0) \lor \boxed{\lnot G_i(\msucc(\mc_i))} \lor G_i(z)
	\tag*{induction schema}
	\\[0.5em]
	\underbrace{x\circ (y\circ z) \mEQ (x\circ y) \circ z}_{a},\,
	\underbrace{x\circ y \mEQ y\circ x}_{c},\, 
	\underbrace{x\circ e_\circ \mEQ x,\, e_\circ\circ x\mEQ x}_n
	\tag*{ACN}
	\end{align*}
	\caption{Clausal representation}
	\label{tab:presburger:axioms:clauses}
\end{table}

\begin{table}[hbt]	
	\begin{gather*}
	0\circ e_\circ\mNE 0
	\lor\boxed{
		c_\circ \circ e_\circ \mEQ c_\circ
	}
	\lor z\circ e_\circ \mEQ z
	\\
	0\circ e_\circ\mNE 0
	\lor\boxed{
		\msucc(c_\circ) \circ e_\circ \mNE \msucc(c_\circ)
	}
	\lor z\circ e_\circ \mEQ z
	\end{gather*}
	\caption{Induction axioms for neutral element}
	\label{tab:presburger:induction:clauses}
\end{table}

\begin{table}[hbt]	
	\begin{gather*}
	{0+y\mNE y+0} 
	\lor\boxed{\mc_2+y\mEQ y+\mc_2} 
	\lor{z+y\mEQ y+z} 
	\\
	0+y\mNE y+0 \lor 
	\boxed{\msucc(\mc_2)+y\mNE y+\msucc(\mc_2)} 
	\lor z+y\mEQ y+z
	\end{gather*}
	\caption{Induction axioms for commutativity}
	\label{tab:presburger:induction:commutativity}
\end{table}


\section{Gilmore's Prover}

In 1960 Paul Gilmore presented a first {\myem implementation} of an automated 
theorem prover \cite{5392528} for first order logic (without equality),
which happened to use an instantiation-based approach. 
The procedure is theoretically complete, i.e.~for every valid formula 
a refutation proof can be found eventually.

In practice this prover ran into memory issues or time outs more often than not.
We will discuss reasons for this inefficiency after we have described and demonstrated the procedure.

The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:fosca:is:mortal}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C \equiv (A\land B)\limp C  
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula to clausal normal form $S_{(\ref{ex:fosca:is:mortal})} = A\land B \land\lnot C \equiv \lnot F$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	As last step we transform the single formula in 
	the set of ground instances $S_0$ into a disjunctive normal form 
	for easy satisfiability checking.
%
\begin{gather*}
%S^{\ref{ex:fosca:is:mortal},0} \equiv \begin{array}{c}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
%\end{array}
\end{gather*}
Both conjunctions contain complementary literals and we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

\begin{procedure}[Gilmore's Prover]\label{proc:gilmore's:prover}
	We translate the negation of our formula $F$ into an equisatisfiable set of clauses 
	$\lnot F \approx S = \bigcup_{i=1}^{n} \mcC_i$ with an efficient algorithm \cite{tseitin70}, \cite{PLAISTED1986293}.
	Then we start our first iteration with $k=0$.
	\begin{enumerate}
		
		\item We create the set of all ground terms up to term depth $k$, 
		i.e.~the partial Herbrand universe $H_k$ according to Definition \ref{def:hk}. 
		We use $H_k$ to create the set of clause instances $S_k$ 
		by substituting all variables 
		in each clause by terms from $H_k$ in any possible permutation.
		\[ S_k = \bigcup_{i=1}^{n} 
		\{\,
			\mcC_i\sigma \mid \mcC_i \in S,\,\sigma: \mcV\to H_k
		\,\}
		\]
		
		\item We translate $S_k$ into an equivalent disjunctive normal form 
		(i.e.~a disjunction of conjunctions of literals)
		where satisfiability is easily checked.
		
		

		\item When every conjunction contains a pair of complementary literals 
		then we exit the procedure and report unsatisfiability of $S$, 
		hence validity of $F$.

Otherwise we increase $k$ by one and continue with step 1.
		
		
	\end{enumerate}
	
\end{procedure}

Gilmore's procedure will eventually terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability in first order logic
which does not exist because of undecidability of satisfiability in first order logic.

\begin{lemma}
	Gilmore's procedure is a decison procedure for monadic first order logic and the Sch√∂nfinkel-Bernays fragment. 
\end{lemma}

\begin{proof}
	In the absence of non-constant function symbols 
	the procedure can stop after the first iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$,
	i.e.~after the first iteration 
	no new terms are added to the Hebrand universe 
	and no new ground instances can be generated.
\end{proof}
%
%On the other hand the procedure will never terminate 
%even for very simple satisfiable sets where the Herbrand universe is infinite, 
%i.e.~there is at least one non-constant function symbol.



\begin{definition}
	For an unary function symbol $\mg\in\mcFfn[1]$, a natural number
	$i\in\mathbb{N}$, and an arbitrary term $t\in\mcTf$ we introduce the notation
	\[
	\mg^0(t) := t \qquad
	\mg^{i+1}(t) := \mg(\mg^i(t))
	\]
\end{definition}

\begin{example}\label{ex:unsat:nexsx}
	Let $k\in\mathbb{N}$ be an arbitrary but fixed number.
	Consider the unsatisfiable set of clauses
	$S_{(\ref{ex:unsat:nexsx})} = \{\, \lnot\mcL_1,\,\mcL_2\, \} =
	\{\,
	{ \lnot\mE(x, \msucc(x)))},\, 
	{ \mE(\msucc^{k}(y), \msucc(\msucc^{k}(y)))}
	\,\}$.
	The sets of instances $S_{i}$ are satisfiable for all $i<k$.
	The set of instances $S_{k}$ is clearly unsatisfiable.
	%	
	\begin{align*}
	H_{0} :=&\ \{\,\mzero\,\} 
	&
	S_{0} :=&\ \{\, 
	{\colG \lnot\mE(\mzero,\msucc(\mzero))},\,
	{\colHi \mE(\msucc^k(\mzero),\,\msucc(\msucc^k(\mzero)))}
	\,\}
	\subsetneq S_k
	\\
	H_{i+1} =&\ H_i\disjointunion\{\,\msucc(\msucc^{i}(\mzero))\,\}
	&
	S_{i+1} \supsetneq&\
	\{\,
	{\colG \lnot\mE(\msucc^{i+1}(\mzero),\msucc(\msucc^{i+1}(\mzero))),\,
	\mE(\msucc^k(\msucc^{i+1}(\mzero)), \msucc(\msucc^k(\msucc^{i+1}(\mzero))))}
	\,\}
	\\
	H_{k} \supsetneq&\ \{\,\msucc^{k}(\mzero)\,\} 
	&
	S_{k} \supsetneq&\
	\{\,
	{\colLo \lnot\mE(\msucc^{k}(\mzero),\msucc(\msucc^{k}(\mzero)))},\,
	{\colG\mE(\msucc^k(\msucc^{k}(\mzero)), \msucc(\msucc^k(\msucc^{k}(\mzero))))}
%	{\ldots}
	\,\}
	\end{align*}
	We've produced $2\cdot k$ {\myem irrelevant} instances, i.e. these clauses did not cause any conflict in 
	propositional satisfiability. 
	In this example the guess for a finite unsatisfiable set of ground instances appears feasible and yields a smaller set.
	\[
	\{\, 
	\lnot\mcL_1\sigma,\,\mcL_2\sigma
	\,\} \qquad \sigma=\{x\mapsto \msucc^k(\mzero),\,y\mapsto \mzero\}
	\]
\end{example}

\begin{example}\label{ex:sat:exy}
	Consider the satisfiable set of clauses $\{\lnot\mE(\mzero,\msucc(x)\}$.
	This set is clearly in the decidable Ackermann fragment of first order logic.
	But the procedure yields an infinite sequence of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \lnot\mE(\mzero,\msucc(\mzero))
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\mzero,\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
	So Gilmore's prover wouldn't terminate on this simple and decidable problem.
\end{example}



We have observed three main disadvantages in Gilmore's procedure.
\begin{enumerate}
	\item\label{enum:gilmore:generation}
	 The generation of instances is unguided. 
	With each iteration exponentially many (mostly useless)
	instances are created
	-- depending on the number and the arities of used symbols.
%	\begin{align*}
%		H'_0 &= \{\,\mc \,\}  
%		&H_0 = H'_0
%		\\
%		H'_1 &= \{\,\mf(\mc), \mg(\mc,\mc) \,\} 
%		&H_1 = H_0 \cup H'_1
%		\\
%		H'_2 &= 
%		\{\, 
%			\mf(\mf(\mc)), \mf(\mg(\mc,\mc)), 
%			\mg(\mc, \mf(\mc)), \mg(\mc, \mg(\mc,\mc)), \\
%			&\qquad \mg(\mf(\mc), \mc), \mg(\mf(\mc), \mf(\mc)), \mg(\mf(\mc), \mg(\mc,\mc)), \\
%			&\qquad \mg(\mg(\mc,\mc),\mc), \mg(\mg(\mc,\mc),\mf(\mc)), \mg(\mg(\mc,\mc), \mg(\mc,\mc)) 
%		\,\} 
%		&H_2 = H_1 \cup H'_2	
%		\\
%		H'_{i+1} &= 
%			\{\, \mf(a), \mg(a,b), \mg(b,a) \mid a\in H'_i, b\in H_i \, 
%			\}
%			&H_i = \bigcup_{j=1}^{i} H'_j
%		\end{align*}\\[-1.0em]	
\begin{align*}
	\lvert S_{i} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)
	&
	\lvert H_0 \rvert &\geq 1	
	\\
	\lvert S_{i+1} \rvert &= \sum_n \left( \lvert \mcFPn \rvert\cdot \lvert H_{i+1}\rvert^n \right)
%	\geq \lvert S_i \rvert^n
	&
	\lvert H_{i+1}\rvert &\geq 
	\sum_{n>0}\left(
	\lvert\mcFfn\rvert\cdot\lvert H_i \rvert^n
	\right) 
%	\\
%	&\geq \sum_n \left( \lvert \mcFPn \rvert\cdot 
%	\left( 
%	\sum_{n>0}\left(\lvert \mcFPn \rvert\cdot \lvert H_{i}\rvert^n \right)\right)^n\ \right) \geq \lvert S_i \rvert^n
\end{align*}
		This makes disadvantage No.~\ref{enum:gilmore:transformation} 
		which is invoked at every iteration even worse.
	\item\label{enum:gilmore:transformation} 
	The check for unsatisfiability is far from efficient.
	The transformation from a set of clauses 
	to a formula in disjunctive normal form\footnote{
		The Tseitin transformation yields an equisatisfiable conjunctive or clausal normal form.
	}
	usually introduces an exponential\footnote{
		If a general algorithm without exponential blowup existed 
		for the transformation of 
		an arbitrary propositional formula into 
		an equi\allowbreak{}satisfiable formula in disjunctive normal 
		form (where satisfiability is a linear check) 
		then $\mathsf{SAT}$ would appear to be in $\mcP$
%		$\mathsf{SAT}\in\mcP$  
		and $\mcP = \mcN\mcP$. 
	}  
	blow in the size of the formula 
	-- depending on the number of clauses $n$ in the set 
	and the number of literals $c_i$ per clause $\mcC_i$ 
	we get the disjunction of
	$\prod_{1}^{n} c_i$ 
	conjunctions of $n$ literals.
	  \begin{align*}
	  \bigwedge_{i=1}^{n} 
	  \left(
	  	\bigvee_{j_i=1}^{c_i} p_{(i,j_i)} 
	  \right)
	  \ &\equiv
	  \bigvee_{(j_1,\ldots,j_n)}
	  \left(
	  	\bigwedge_{i=1}^{n} p_{(i,j_i)}
	  \right)
	  &\text{with }(j_1,\ldots,j_n)\in\prod_{i=1}^{n}\{ 1,\ldots,c_i \}
	\end{align*}
	In total the number of literals in the set of clauses is 
	$n\cdot \bar{c}_{arith}$, 
	while the equivalent disjunctive normal form contains 
	$(\bar{c}_{geom})^n\cdot n$ literals\footnote{
		%		$\prod_{1}^{n} c_i = (\bar{c}_{geom})^n$
		%		with the geometric mean 
		Geometric mean $\bar{c}_{geom} := \left(\prod_{1}^{n}c_i\right)^{\frac{1}{n}}$, 
		arithmetic mean $\bar{c}_{arith} := \left(\sum_{1}^{n}c_i\right)\cdot\frac{1}{n}$, and
		%		where
				$\bar{c}_{geom} 
				\leq 
				\bar{c}_{arith}$.
	}.
	\begin{gather*}
%	a‚àß(b‚à®c)‚àß(d‚à®e‚à®f)
%	\\
%	\equiv
%	\\
%	(a‚àßb‚àßd)‚à®(a‚àßb‚àße)‚à®(a‚àßb‚àßf)‚à®(a‚àßc‚àßd)‚à®(a‚àßc‚àße)‚à®(a‚àßc‚àßf)
%\\
		\{ 1 \}\times\{1,2\}\times\{1,2,3\} = 
		\{
			(1,1,1),(1,1,2),(1,1,3),
			(1,2,1),(1,2,2),(1,2,3)
		\}
	\end{gather*}
	
	\item\label{enum:gilmore:termination}
	The procedure will not terminate for satisfiable sets 
	when at least one non-constant predicate symbol is used in the set of clauses and 
	one non-constant function symbol is available, e.g.~for $S=\{\,\mP(\mf(x)) \,\}$ we get
	\begin{align*}
	H_0 &= \{\,\mc\,\} & S_0 &= \{\,\mP(\mf(\mc))\,\} 
	\\
	H_{i+1} &= \bigcup_{k=0}^{i+1}\{\, \mf^{k}(\mc))\,\}
	& 
	S_{i+1} &= \{\, \mP(\mf(t)) \mid t\in H_{i+1}
	\,\}
	\\
	 \mf^{i+1}(\mc) &\in H_{i+1}\setminus H_i
	 &
	 \mP(\mf(\mf^{i+1}(\mc))) &\in S_{i+1} \setminus S_i
	\end{align*}
\end{enumerate}



Issue \ref{enum:gilmore:transformation} was already implicitly 
addressed in 1960 \cite{Davis:1960:CPQ:321033.321034}
and refined in 1962 \cite{Davis:1962:MPT:368273.368557}
by Davis, Putnam, Longeman, and Loveland, 
which was the starting point for the development of efficient propositionally satisfiability checkers, i.e.~efficient modern SAT solvers.

\section{Resolution}

\begin{definition}[Resolution] Let $A, B$ be atoms and $\mcC,\mcD$ be clauses.
	\begin{gather*}
	\infer
	[\text{Resolution}] 
	{(\mcC\lor\mcD)\sigma}
	{A\lor\mcC&\lnot B\lor\mcD}
	\qquad
	\infer
	[\text{Factoring}] 
	{(A\lor\mcC)\sigma}
	{A\lor B\lor\mcC}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$
		%		, $\sigma$ is proper
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{example}
	With Resolution we can derive the empty clause, i.e.~the unsatisfiability of set
	$S_{(\ref{ex:unsat:nexsx})} =
	\{\,
	{ \lnot\mE(x, \msucc(x)))},\, 
	{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
	\,\}$ 
	introduced in Example \ref{ex:unsat:nexsx} 
	in one step. 
	\begin{gather*}
	\infer[\{x\mapsto\msucc^k(y)\}]{
		\square
	}{
		{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))} &
		{ \lnot\mE(x, \msucc(x)))} &
	}
	\end{gather*}
\end{example}

\begin{example}
	With Resolution we cannot derive any new clause from satisfiable set 
	$S_{(\ref{ex:sat:exy})  } = \{\,\mE(\mzero,y)\,\}$ 
	introduced in Example \ref{ex:sat:exy} and we conclude satisfiability 
	of the Resolution-saturated set $S_{(\ref{ex:sat:exy})  }$ from the absence of the empty clause.
\end{example}

\begin{example}\label{ex:sat:nezsx}
	With satisfiable set $S_{\ref{ex:sat:nezsx}} = \{\, 
		\lnot\mE(\mzero,\msucc(x)), \mE(y,y') \lor \lnot \mE(\msucc(y),\msucc(y')
		\,\}$
		we observe an infinite sequence of resolutions,
		hence the set does not saturate.
		
	\begin{gather*}
%	\infer
%	[\{y\mapsto\mzero, y'\mapsto\msucc(x)\}]
%	{ 
%		\lnot \mE(\ms({\colN\mzero}),\ms({\colN\msucc(x)}) 
%	}{
%		{\colHi\mE(y,y')} \lor \lnot \mE(\ms(y),\ms(y')) 
%		&{\colLo \lnot\mE(\mzero,\ms(x))}
%	}
%	\tag{$i=0$}
%	\\[1em]
	\infer
	[\{y\mapsto\msucc^i(\mzero), y'\mapsto\msucc^{i+1}(x)\}]
	{
		\lnot \mE(\msucc({\colN\msucc^{i}(\mzero)}),\msucc({\colN\msucc^{i+1}(x)})) 
	}{
		{\colHi\mE(y,y')} \lor \lnot \mE(\msucc(y),\msucc(y')) 
		&{\colLo \lnot\mE(\msucc^i(\mzero),\msucc^{i+1}(x))}
	}
	\tag{$i\geq 0$}
	\\
	\infer[y\mapsto\msucc(\msucc(0)),y'\mapsto\msucc(\msucc(\msucc(x)))]{
		\msucc(\msucc(\msucc(0)))\mNE\msucc(\msucc(\msucc(\msucc(x))))
	}{\circ &
	\infer[y\mapsto\msucc(0),y'\mapsto(\msucc\msucc(x))]{
		\msucc(\msucc(0))\mNE\msucc(\msucc(\msucc(0)))
	}{\circ&
	\infer[y\mapsto 0, y'\mapsto\msucc(0)]
	{ \msucc(0)\mNE\msucc(\msucc(0))}
	{ y\mEQ y' \lor \msucc(y)\mNE\msucc(y') & 0 \mNE \msucc(x)}
}
}
	\end{gather*}
\end{example}

We can deduce or observe disadvantages in resolution. 

\begin{enumerate}
	\item If clauses contain more than two literals the resolution inference rule yields clauses with more literals than the sources.
	\item We have to check all pairings 
	of all positive literals with all negative literals for clashing.
	$n_{\mcC\lor\mcD} = n_{(A\lor\mcC)} -1 + n_{(\lnot B\lor\mcD)}-1$
\end{enumerate}

\begin{definition}[Ordered Resolution] Let $A, B$ be atoms and $\mcC,\mcD$ be clauses.
	\begin{gather*}
	\infer
	[\text{Ordered}\atop\text{Resolution}] 
	{(\mcC\lor\mcD)\sigma}
	{A\lor\mcC&\lnot B\lor\mcD}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$, 
		$A\sigma$ is strictly maximal in $\mcC\sigma$, 
		$B\sigma$ is maximal in $\mcD\sigma$.
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{example}
	With an ordering such that $\mE(\msucc(y),\msucc(y')) \succ \mE(y,y')$ on atoms and ${\lnot A} \succ A$
	the satisfiable set $S_{\ref{ex:sat:nezsx}}$ saturates with ordered resolution,
	because the (strictly) maximal literals 
	$\lnot \mE(\msucc(y),\msucc(y') \colG\not\preccurlyeq \mE(y,y') $
	and $\lnot\mE(\mzero,\msucc(x))$
	in the two clauses do not clash.
\end{example}

\section{InstGen}

Gilmore's prover blindly constructs new ground instances. 

\begin{definition}[\InstGen] Let $A, B$ be atoms and $\mcC,\mcD$ be clauses.
	\begin{gather*}
	\infer
	[{\InstGen}] 
	{(A\lor\mathcal C)\sigma\qquad (\lnot B\lor\mathcal D)\sigma}
	{A\lor\mathcal C\quad&\quad \lnot B\lor\mathcal D}
	\end{gather*}
	\begin{center}$\sigma=\mgu(A,B)$
%		, $\sigma$ is proper
	\end{center}
	%	The rule looks very similar to the resolution rule in Definition \ref{def:res}.
	%	But there is an important difference. 
	%	Instead of combining two clauses to one single clause,
	%	the most general unifier $\sigma$ is used to derive two instances.
	%	At least one is different from its origin, because the substitution must be proper.
	%	In contrast to the recombination of clauses  the maximal size of clauses, i.e.~the number of literals in a clause, 
	%	obviously does not increase in any case.
	%The maximal number of literals in any clause of $S$ does no grow.
	%{\small This rule looks very similar to resolution. But instead of combining two clauses to one single new clause,
	%the most general unifier $\sigma$ is used to derive two new clauses.}
\end{definition}

\begin{example}
	With \InstGen we immediately can derive a helpful clause from set
$S_{(\ref{ex:unsat:nexsx})} =
\{\,
{ \lnot\mE(x, \msucc(x)))},\, 
{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
\,\}$ 
 introduced in Example \ref{ex:unsat:nexsx}. 
\begin{gather*}
\infer[\{x\mapsto\msucc^k(y)\}]{
	{ \lnot\mE(\msucc^k(y), \msucc(\msucc^k(y))))} \qquad
	{\colG \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
}{
	{ \lnot\mE(x, \msucc(x)))} &
	{ \mE(\msucc^k(y), \msucc(\msucc^k(y)))}
}
\end{gather*}
and we conclude unsatisfiability because of propositional unsatisfiability of 
\begin{gather*}
\{\,
	\mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot))), \lnot\mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot)))) 
\,\}
\end{gather*}
	
\end{example}

\begin{example}
	With \InstGen we cannot derive any new clause from set 
	$S_{(\ref{ex:sat:exy})  } = \{\,\mE(\mzero,y)\,\}$ 
	introduced in Example \ref{ex:sat:exy} and we conclude satisfiability
	of the \InstGen-saturated set $S_{(\ref{ex:sat:exy})  }$ 
	because of the propositional satisfiability of $S_{(\ref{ex:sat:exy})  }\subsbot$.
\end{example}

\begin{lemma}
	The set of clauses 
	$S_0 = S \cup
	\{ 
		 A\lor\mathcal C, \lnot B\lor\mathcal D
	\}$ 
	is satisfiable if and only if
	the derived set of clauses 
	$S_1 = S_0 \cup \{ (A\lor\mathcal C)\sigma, (\lnot B\lor\mathcal D)\sigma\}$
	with $\sigma = \mgu(A,B)$ is satisfiable.
\end{lemma}

\begin{proof}
	If $S_1$ is satisfiable then there exists an interpretation that satisfies all clauses in $S_1$. 
	The same interpretation models all clauses in $S_0$ because $S_0\subseteq S_1$.
	In reverse $S_1$ cannot be satisfiable if $S_0$ is not.
	
	
\end{proof}

\begin{procedure}[Inst-Gen-Loop]\label{proc:inst:gen:loop}
	As in Gilmore's prover (Procedure \ref{proc:gilmore's:prover}) 
	we translate the negation of our formula $F$ into an equisatisfiable set of clauses 
	$S_0$. Then we introduce a distinct constant symbol 
	$\consbot\not\in\mcF(S_0)$ even when there are constant symbols in the signature. 
	We start our first iteration with $k=0$.
	
	\begin{enumerate}
		\item\label{step:igl:skbot}
		We construct a set $S_{k}\,\subsbot$ of ground instances from $S_k$
		where instantiator $\subsbot := \{ x\mapsto \consbot \mid x\in\var(S_k) \} $ 
		substitutes all occurring variables with constant symbol $\consbot$.
%		
		\item\label{step:igl:sksat} We check the decidable satisfiability of $S_k\,\subsbot$ 
		with a modern \SAT or \SMT-solver.
		
		If $S_k\,\subsbot$ is unsatisfiable then we exit the procedure and report {\myem usatisfiability} of $S$, i.e~the original formula $F$ is valid.
		
		\item\label{step:igl:model} The set $S_k\,\subsbot$ is satisfiable, hence we can retrieve a model $\mcM_k \models S_k\subsbot$.
		We select one literal $L_i = \sel(\mcC_i)$ per clause $\mcC_i \in S_k$ 
		such that the each grounded selected literal holds in model
		$\mcM_k\models L_i\subsbot$ for all $i\leq | S_k |$.
		
		\item\label{step:igl:clashes} We search for pairs of selected literals $(A, \lnot B) = (L_i, L_j^c)$
		such that the most general unifier $\tau = \mgu(A,B)$ exists.
		
		\item We set $S_{k+1} ::= S_k$ and for each pair of clashing literals $(L_i, L^c_j)$ 
		we apply \InstGen to the originating clauses 
		$\{\, \mcC_{i}, \mcC_{j}\, \} = \{\,L_i\lor\mcC, L_j\lor\mcD\,\}$
%		where $\sel(\mcC_{i_1}) = L_i$ and $\sel(\mcC_{i_2})=\lnot L_j$
		to add new (not necessarily ground) instances to $S_{k+1}$.
		
		If no new clauses were added, i.e.~$S_{k+1} = S_k$ after all pairs were processed we exit the procedure and report {\myem satisfiability} of $S$, i.e.~the original formula $F$ is not valid.
		
		\item We increase $k$ by $1$ and continue with step \ref{step:igl:skbot}. 
		
	\end{enumerate}
	

\begin{figure}[hbt]
	\begin{center}
		\begin{tikzpicture}[scale=0.95, transform shape]
		\node[rectangle] (start) at (0,-4em) {};
		\node (nc) [myrect] at (0,0) {new\\clauses};
		\node (pc) [myrect] at (0,8em) {passive clauses};
		\node (ab) [myrect] at (-8em,3.5em) {instantiation};
		\node (gs) [myrect] at (-8em,8em) { \SMT};
		\node (un) [mycircle] at (-15em,8em) {un\-satis\-fiable};
		\node (se) [myrect] at (-8em,12.5em) {selection};
		\node (gc) [myrect] at (0em,16em) {given clause};
		\node (ac) [myrect,dashed] at (-13em,16.5em) {active clauses};
		
		\node (sl) [myrect, thick] at (8.5em,12.5em) {selected literal};
		\node (us) [myrect,very thick, 
%		minimum width=8em, minimum height=3.5em, text width=7em
		] at (8.5em,8em) { \InstGen};
		\node (sa) [mycircle] at (16em,8em) {satis\-fiable};
		\node (su) [myrect] at (8.5em,3.5em) {substitution};
		
		\draw[myarrow] (start) to (nc);
		\draw[myarrow] (nc) to (pc);
		\draw[myarrow] (nc.west)  to [bend left=10] (ab);
		\draw[myarrow] (ab) to (gs);
		\draw[myarrow] (gs) to (un);
		\draw[myarrow] (gs) to (se);
		\draw[myarrow] (pc) to (gc);
		\draw[myarrow] (se.north) to [bend left=10] (gc.west);
		\draw[myarrow] (us) to (sa);
		\draw[myarrow] (us) to (su);
		\draw[myarrow] (su) to [bend left=10] (nc.east);
		\draw[myarrow] (sl) to (us);
		\draw[myarrow] (gc.east) to [bend left=10] (sl.north);
		\draw[myarrow,dashed] (gc.north) to [bend right=15](ac);
		\end{tikzpicture}
		\caption{Proving loop with \SMT and \InstGen}
		\label{fig:inst-gen-maxcomp}
	\end{center}
\end{figure}
\end{procedure}

\begin{example} The selected literals of the first and the second clause change between iterations.
%	1. p(a) | q(a)
%	2. p(a) | ~q(X)
%	3. ~p(X)
\begin{align*}
S_0 &= \{\,
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x) 
\,\}
\\
S_0\subsbot &=\{\, 
	{\colHi\mP(\ma)}\lor\mQ(\ma),
	{\colHi\mP(\ma)}\lor\lnot\mQ(\consbot),
	{\colHi\lnot\mP(\consbot)} 
\,\}
\tag{satisfiable}
\\
&\qquad\infer[
	x\mapsto\ma
	]{
		{\colG \mP(\ma)\lor\mQ(\ast)}\quad\lnot\mP(\ma)
	}{
		\mP(\ma)\lor\mQ(\ast) & \lnot\mP(x)
	} 
\tag*{$\ast\in\{\ma,y\}$}
\\
S_1 &=\{\, 
	\mP(\ma)\lor\mQ(\ma),
	\mP(\ma)\lor\lnot\mQ(y),
	\lnot\mP(x),
	\lnot\mP(\ma) 
\,\}
\\
S_1\subsbot &=\{\,
	{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
	{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
	{\colHi\lnot\mP(\consbot)},
	{\colHi\lnot\mP(\ma)} 
\,\}
\tag{satisfiable}
\\
&\qquad\infer[
y\mapsto\ma
]{
	{\colG \mP(\ma)\lor\mQ(\ma)}\quad\mP(\ma)\lor\lnot\mQ(\ma)
}{
	\mP(\ma)\lor\mQ(\ma) & \mP(\ma)\lor\lnot\mQ(y)
} 
\\
S_2 &=\{\, 
\mP(\ma)\lor\mQ(\ma),
\mP(\ma)\lor\lnot\mQ(y),
\lnot\mP(x),
\lnot\mP(\ma),
\mP(\ma)\lor\lnot\mQ(\ma) 
\,\}
\\
S_2\subsbot &=\{\,
{\colG\mP(\ma)}\lor{\colHi\mQ(\ma)},
{\colG\mP(\ma)}\lor{\colHi\lnot\mQ(\consbot)},
{\colHi\lnot\mP(\consbot)},
{\colHi\lnot\mP(\ma)},
{\colLo\mP(\ma)}\lor{\colLo\lnot\mQ(\ma)} 
\,\}
\tag{unsatisfiable}
\end{align*}
\end{example}

\begin{lemma}
	The $\tau = \mgu(A,B)$ in Procedure \ref{proc:inst:gen:loop}, 
	step \ref{step:igl:clashes} is a proper instantiator, 
	i.e.~it is not a variable renaming.
\end{lemma}
\begin{proof}
	Assume $\tau$ in Procedure \ref{proc:inst:gen:loop}
	is a renaming, then we have 
	$A\tau\subsbot = A\subsbot$,
	$B\tau\subsbot = B\subsbot$,
	and by definition of the most general unifier $A\tau = B\tau$. 
	Hence $A\subsbot = B\subsbot$ which contradicts that 
	$M_k\models A\subsbot, \lnot B\subsbot$ 
	by definition of step \ref{step:igl:model}. 
	Hence the assumption is false and $\tau$ must be a proper instantiator.
\end{proof}





\begin{example}\label{ex:unsat2}
Let $S_0 = S_{(\ref{ex:unsat:nexsx})}$ be the set of unsatisfiable clauses from Example \ref{ex:unsat:nexsx}. 
Then the initial set of ground instances 
$S_0\subsbot =\
\{\,
{ \lnot\mE(\consbot, \msucc(\consbot)))}, 
{ \mE(\msucc^k(\consbot), \msucc(\msucc^k(\consbot)))}
\,\}$
is satisfiable with domain $A = \{ \consbot, \msucc(\consbot), \msucc^k(\consbot), \msucc(\msucc^k(\consbot)) \}$
and predicate interpretation 
$\mE^\mcI = \{ (\msucc^k(\consbot), \msucc(\msucc^k(\consbot))
 \} \subseteq A^2$. 
% 
 With just two unit clauses we easily find the only pair of clashing literals and compute the unifier
 $\tau = \{ x\mapsto \msucc(s^k(y)) \}$. 
 By application of \InstGen we construct our next set of clauses
$
S_1 =\
S_0 \disjointunion
 \{\,
% { \lnot\mE(x, \ms(x)))},\  
% { \mE(\ms^k(y), \ms(\ms^k(y)))},\
 { \lnot\mE(\msucc^k(y), \msucc(\msucc^k(y)))}
 \,\}
 $ 
 and get an unsatisfiable set of ground instances $S_1\subsbot$.
\end{example}




\section{Equality}

So far we have treated the equaltiy symbol like a binary predicate symbol, 
which can yield models where $\ma\mNE\ma$ holds. 
Understandably, we are only interested in normal models or 
at least in models that implies the existence of a normal model.

\begin{theorem}\cite{Harrison:2009:HPL:1540610}
	Any set of clauses (a formula) has a \emph{normal} model 
	if and only if it has a model that satisfies the 
	{\myem equality axioms}, i.e.~reflexivity, symmetry, transitivity, 
	and congruence for all function symbols $\mf\in\mcFf$
	and all predicate symbols $\mP\in\mcFP$.
\end{theorem}

\begin{remark}
	The only decidable fragment of first order logic where we can state the equality axioms is the Sch√∂nfinkel-Bernays-Ramsey class.
\end{remark}

\begin{example} The ordered resolution inference rule yields one tautology from congruence and injectivity,
	which we will ignore.
	\begin{align*}
	\colN x \mEQ x
	\tag*{$\mEQ$-reflexivity}\\
	x \mEQ y \lor {\colN y \mNE x}
	\tag*{$\mEQ$-symmetry}\\
	x \mEQ z \lor {\colN x \mNE y} \lor {\colN y\mNE z}
	\tag*{$\mEQ$-transitivity}\\
	{\colN \msucc(x) \mEQ \msucc(y)} \lor x\mNE y
	\tag*{$\msucc$-congruence}\\[0.5em]
	x \mEQ y \lor {\colN \msucc(x) \mNE \msucc(y)}
	\tag*{$\msucc$-injectivity}\\
	{\colN 0 \mNE \msucc(x)}
	\tag*{$0\not\in\img(\msucc)$}
	\end{align*}
	\begin{align*}
	\infer[]
	{\colHi x\mNE y\lor x\mEQ y}
	{
		{\colN \msucc(x) \mEQ \msucc(y)} \lor x\mNE y 
		&
		x \mEQ y \lor {\colN \msucc(x) \mNE \msucc(y)}
	}
	\end{align*}
\end{example}

\begin{example} When we look at the grounding we notice that selection process is unfortunate,
	because the selected literals of any clause but congruence clashes with $0\mNE\msucc(x)$.
	\begin{align*}
	\colHi \consbot \mEQ \consbot
	\tag*{reflexivity}\\
	{ \consbot \mEQ \consbot} \lor {\colLo \consbot \mNE \consbot}
	\tag*{symmetry}\\
	{ \consbot \mEQ \consbot} 
	\lor {\colLo \consbot \mNE \consbot} 
	\lor {\colLo \consbot\mNE \consbot}
	\tag*{transitivity}\\
	{\colHi \msucc(\consbot) \mEQ \msucc(\consbot)} \lor {\colLo \consbot \mNE \consbot}
	\tag*{congruence}\\[0.5em]
	{ \consbot \mEQ \consbot} \lor {\colLo \msucc(\consbot) \mNE \msucc(\consbot)}
	\tag*{injectivity}\\
	{\colHi \msucc(x) \mNE 0}
	\end{align*}
	\begin{align*}
	\infer[x\mapsto 0, y\mapsto \msucc(x') ]
	{ 0\mEQ\msucc(x')\lor \msucc(x')\mEQ 0}
	{
		0 \mNE\msucc(x')
		&
		x\mEQ y\lor y\mNE x
	}
\\
%
\infer[x\mapsto 0, y\mapsto \msucc(x') ]
{ 0\mEQ\msucc(x')\lor \msucc(x')\mEQ 0}
{
	0 \mNE \msucc(x')
	&
	x \mEQ y \lor \msucc(x)\mNE \msucc(y)	
}
	\end{align*}
\end{example}



\begin{example} With Superposition no derivation rule is applicable.
	\begin{align*}
	x \mEQ y \lor {\colN \msucc(x) \mNE \msucc(y)}
	\tag*{injectivity}\\
	{\colN 0 \mNE \msucc(x)}
	\end{align*}
\end{example}

\begin{example} We extend our set with clause $\msucc(0) \mEQ \msucc(\msucc(x))$ 
	that clashes with injectivity of $\msucc$.
	\begin{gather*}
	\infer[\{\,x'\mapsto x\,\}]
	{\square}
	{0\mNE s(x') &
	\infer[
	\{\, x'\mapsto 0, y'\mapsto\msucc(x) \,\}
	]{
		0 \mEQ \msucc(x)	
	}{
		x' \mEQ y' \lor {\colN \msucc(x')) \mNE \msucc(y')} 
		& {\msucc(0) \mEQ \msucc(\msucc(x))}
	}
}
	\end{gather*}
\end{example}


	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we don't find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

%\begin{align*}
%	 x \mEQ x & \tag*{reflexivity} \\
%	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
%	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
%	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
%	\tag*{f-congruence}
%	\\
%	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
%	\tag*{P-congruence}
%	\\[0.7em]
%	x_1\mNE y_1\lor x_2\mNE y_2
%	\lor x_1\mNE x_2
%	\lor y_1\mEQ y_2
%	\tag*{$\mEQ$-congruence}
%\end{align*}

%\begin{align*}
%	x \mEQ x & \tag*{reflexivity} 
%	\\
%	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
%	\\
%	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
%	\\
%	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
%	\tag*{f-congruence}
%	\\
%	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
%	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
%	\tag*{P-congruence}
%	\\[0.7em]
%	(x_1\mEQ y_1
%	\land x_2\mEQ y_2
%	\land x_1\mEQ x_2)
%	\limp y_1\mEQ y_2
%	& \quad P\in\mcFPn[2]
%		\tag*{$\mEQ$-congruence}
%\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.

\section{Examples}

\begin{example}
	\begin{align*}
	\ack(\mzero,y) &\mEQ \msucc(y) \\
	\ack(\msucc(x),\mzero) &\mEQ \ack(x, \msucc(\mzero)) \\
	\ack(\msucc(x),\msucc(y)) &\mEQ \ack(x, \ack(\msucc(x),y)) \\
	\\
%	x &\mNE \msucc(x)\\
	x &\mNE y \lor \msucc(x) \mEQ \msucc(y)\\
	\mzero &\mNE \msucc(x)\\
	\end{align*}
\end{example}

\section{Unit Superposition}

\begin{example}
	Let $S = \{\, \msucc(x') \mNE \msucc (y') \lor x' \mEQ y', \, \msucc(x)\mNE x \, \}$.
	
	\begin{gather*}
	\infer[\{x'\mapsto \msucc (x), y'\mapsto x\}]{
		\boxed{\msucc (\msucc (x)) \mNE \msucc (x)} \lor\colLo \msucc (x)\mEQ x
	}{
		\msucc (x') \mNE \msucc (y') \lor x'\mEQ y' & \colHi\msucc (x) \mNE x
	}
	\end{gather*}
	\begin{gather*}
	\infer[\{x'\mapsto \msucc^{i+2} (x), y'\mapsto \msucc^{i+1} (x)\}]{
		\msucc (\msucc^{i+2} (x)) \mNE \msucc (\msucc^{i+1} (x)) \lor \msucc^{i+2} (x)\mEQ\msucc^{i+1} (x)
	}{
		\msucc (x') \mNE \msucc (y') \lor x'\mEQ y' & \boxed{\msucc^{i+2} (x) \mNE \msucc^{i+1} (x)}\colG \lor \msucc^{i+1} (x)\mEQ\msucc^{i}(x)
	}
	\end{gather*}
	for $i\geq 0$.
\end{example}


\begin{align*}
	S_0 &= \{\, \boxed{\msucc(x') \mNE \msucc (y') \lor x' \mEQ y'}, \, \msucc(x)\mNE x \, \} 
	\\
	S_{0\!_\bot} &= \{\, \msucc(\consbot) \mNE \msucc (\consbot) \lor{\colHi\consbot \mEQ \consbot}, \, {\colHi \msucc(\consbot)\mNE \consbot} \, \}
	\\
	&\infer[x'\mapsto \msucc(x)
	]{ 
		\infer[y'\mapsto x]{\emptyclause}{ y'\mNE x }
	}
	{x' \mEQ y' & \msucc(x)\mNE x}
	\\
	S_1 &= S_0\disjointunion \{\,
	\boxed{\msucc(\msucc(x)) \mNE \msucc(x) \lor \msucc(x) \mEQ x} \,
	\} 
	\\
	S_{i+1} &= S_i\disjointunion \{\,
		\msucc^{i+2}(x)) \mNE \msucc^{i+1} (x) \lor \msucc^{i+1}(x) \mEQ \msucc^i(x) \,
	\} 
	\\
	S_{(i+1)\!_\bot} &= S_i\disjointunion \{\,
	{\colHi \msucc^{i+2}(\consbot)) \mNE \msucc^{i+1} (\consbot)} \lor {\colG\msucc^{i+1}(\consbot) \mEQ \msucc^i(\consbot)} \,
	\} 
	\\
	&\infer[x'\mapsto \msucc^{i+2}(x)
	]{ 
		\infer[y'\mapsto \msucc^{i+1}(x)]{\emptyclause}{ y'\mNE \msucc^{i+1}(x) }
	}
	{x' \mEQ y' & \msucc^{i+2}(x)\mNE \msucc^{i+1}(x)}
	\\
	S_{i+2} &= S_{i+1}\disjointunion \{\,
	\boxed{\msucc^{i+3}(x) \mNE \msucc^{i+2}(x) \lor \msucc^{i+2}(x) \mEQ \msucc^{i+1}(x)} \,
	\} 
\end{align*}

\begin{definition}
	\begin{align*}
	\infer[\sigma]{(s[r]\mEQ t)\sigma}{\ell\mEQ r & s[\ell'] \mEQ t} & &
	\infer[\sigma]{(s[r]\mNE t)\sigma}{\ell\mEQ r & s[\ell'] \mNE t}\tag*{unit superposition}\\
	& \infer[\sigma]{\emptyclause}{\ell \mNE r}\tag*{equality resolution} \\
	\end{align*}
	where $\sigma = \mgu(\ell,\ell')$, 
	$\ell'$ is not a variable, 
	$\ell\sigma\tau >_{gr} r\sigma\tau$,
	$s[\ell']\sigma\tau >_{gr} t\sigma\tau$,
	$\var({\ell, r}) \cup \var(\{ s[l'],t \}) ) = \emptyset$
\end{definition}


\begin{align*}
S_0 &= \{\, \boxed{\msucc(x') \mNE \msucc (y') \lor x' \mEQ y'}, \, \msucc(x)\mNE 0 \, \} 
\\
S_{0\!_\bot} &= \{\, \msucc(\consbot) \mNE \msucc (\consbot) \lor{\colHi\consbot \mEQ \consbot}, \, {\colHi \msucc(\consbot)\mNE 0} \, \}
\\
&\infer[x'\mapsto \msucc(x)
]{ 
	\infer[y'\mapsto 0]{\emptyclause}{ y'\mNE x }
}
{x' \mEQ y' & \msucc(x)\mNE x}
\\
S_1 &= S_0\disjointunion \{\,
\boxed{\msucc(\msucc(x)) \mNE \msucc(0) \lor \msucc(x) \mEQ 0} \,
\} 
\\
S_{i+1} &= S_i\disjointunion \{\,
\msucc^{i+2}(x)) \mNE \msucc^{i+1} (0) \lor \msucc^{i+1}(x) \mEQ \msucc^i(0) \,
\} 
\\
S_{(i+1)\!_\bot} &= S_i\disjointunion \{\,
{\colHi \msucc^{i+2}(\consbot)) \mNE \msucc^{i+1} (0)} \lor {\colG\msucc^{i+1}(\consbot) \mEQ \msucc^i(0)} \,
\} 
\\
&\infer[x'\mapsto \msucc^{i+2}(x)
]{ 
	\infer[y'\mapsto \msucc^{i+1}(0)]{\emptyclause}{ y'\mNE \msucc^{i+1}(0) }
}
{x' \mEQ y' & \left[\msucc^{i+2}(x)\right]\mNE \msucc^{i+1}(0)}
\\
S_{i+2} &= S_{i+1}\disjointunion \{\,
\boxed{\msucc^{i+3}(x) \mNE \msucc^{i+2}(0) \lor \msucc^{i+2}(x) \mEQ \msucc^{i+1}(0)} \,
\} 
\end{align*}




