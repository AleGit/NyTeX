% !TeX root = ../mthesis.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\chapter{Automated Theorem Proving}

\input{epigraphs/syllogism}

We demonstrate the implications of undecidability for proving procedures like Gilmore's or InstGen.
An we judge the procedures by there theoretical performance on decidable fragments. 

We know by Herbrand's theorem (\ref{the:herbrand}, p.~\pageref{the:herbrand})
that each satisfiable set of clauses $S$
and each finite set of ground instances of $S$
has a Hebrand model. 
And we know by compactness (\ref{the:compactness}, p.~\pageref{the:compactness})
that if every finite subset of a set of clauses $S$ is satisfiable then $S$ is satisfiable.
The satisfiability of ground instances is decidable as we have seen in the previous chapter.
So the central idea of instantiation-based first order theorem proving is the
translation of an undecidable problem into a possible infinite sequence of decidable problems.
First we make use of the fact that a first-order formula is valid if and only if its negation is unsatisfiable.
Second we utilize existing efficient transformation algorithms -- e.g. Tsetin -- from arbitrary formulas to equisatisfiable sets of clauses. 
To prove that a given set of clauses is unsatisfiable we create a sequence of finite subsets of all ground instances of this set
until we've created an unsatisfiable one. 






\section{Gilmore's Prover}

Paul Gilmore presented the first implementation \cite{5392528} of an automated first order theorem prover in 1960.
%
The prover's procedure 
creates a sequence of finite sets of ground instances $S_k$ 
for a set of clauses $S\approx\lnot F$ to prove the validity of a formula $F$.
Each set $S_k$ contains all possible ground instances of $S$ 
where all variables are substituted by elements of $H_k$
from definition \ref{def:hk} of the Hebrand universe.
Each $S_k$ is then transformed into a disjunctive normal form where satisfiability is obvious.
The procedure is aborted when an unsatisfiable $S_k$ is encountered.

Following Gilmore's prover we can easily prove the syllogism from above.

\begin{example}\label{ex:syllo}
	First we translate the syllogism into a formula $F$ in first order logic.
	\begin{align*}
		F &= A \limp (B \limp C) \equiv \lnot(A\land B) \lor C 
		\tag*{formula}
		\\[0.5em]
		A &= \forall x\, ( \human(x) \limp \mortal(x) 
		\tag*{theory}
		\\
		B &= \human(\fosca) 
		\tag*{fact}
		\\
		C &= \mortal(\fosca)
		\tag*{conjecture}
	\end{align*}
 
%We easily find a satisfying interpretation $\mcI$ with domain $\{ \fosca \}$ with 
%$\fosca^\mcI = \fosca$,
%$\human^\mcI = \{ (\fosca) \}$,
%$\mortal^\mcI = \{ (\fosca) \}$.


	Then we negate the formula $\lnot F \equiv A\land B \land\lnot C$.
	Since there is exactly one constant we get
	$H_0 = \{ \fosca \}$ and 
	$S_0 = 
	\{
	(\lnot\human(\fosca)\lor\mortal(\fosca))\land\human(\fosca)\land\lnot\mortal(\fosca)
	\}$ in our first iteration. 
	At last we transform the single formula in 
	the set of ground instances $S_0$ for easy satisfiability checking.
%
\begin{gather*}
(\lnot\human(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\\ 
\lor
\\ 
(\mortal(\fosca)\land\human(\fosca)\land\lnot\mortal(\fosca))
\end{gather*}
Since both conjunctions contain complementary literals we conclude the negated formula is unsatisfiable
 and the given syllogism holds.
 
\end{example}

Gilmore's procedure will always terminate for an unsatisfiable set of clauses.
It enumerates all possible sets of ground instances iteratively
and one of them must be unsatisfiable for an unsatisfiable set of clauses. 
However the number of iterations has no general upper bound. 
Otherwise it would be a decision procedure for satisfiability in first order logic
which cannot exist.

It is easy to see for a set of clauses without non-constant function symbols that we can stop the procedure after one iteration because $H_i = H_0$ and $S_i = S_0$ for all $i\geq0$.
%
But the procedure will never terminate even for very simple satisfiable sets where the Herbrand universe is infinite, i.e.~there is at least on non-constant function symbol.

\begin{example}
	Consider the formula 
	$F = \forall x\exists y\,\lnot\mE(x,y)$
	which is a member of the Ackermann class $\forall^*\exists\forall^*$ 
	where satisfiability is decidable.
	The set of clauses 
	$S = \{ \lnot\mE(x,\msucc(x)) \}$ is equisatisfiable to $F$.
	The procedure yields the following sequences of distinct and satisfiable sets $S_{k\geq0}$:
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \lnot\mE(\mzero,\msucc(\mzero))
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion 
	\{
	\lnot\mE(\msucc^i(\mzero),\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
\end{example}


\begin{example}\label{ex:simplesat}
	Consider the unsatisfiable set of clauses $S=\{ \mN(\msucc^{k+2}(\mzero)), \lnot\mN(\msucc(x))  \}$
	\begin{align*}
	H_{0} :=&\  \{ \mzero \} 
	&
	S_{0} :=&\ \{ \mN(\msucc^{k+2}(\mzero)), \lnot\mN(\msucc(\mzero))
	\}
	\tag*{satisfiable}
	\\
	H_{i+1} :=&\ H_i \disjointunion \{ \msucc(\msucc^{i}(\mzero)) \} 
	&
	S_{i+1} :=&\ S_i \disjointunion \{ \lnot\mN(\msucc(\msucc^i(\mzero)))
	\}
	\tag*{satisfiable}
	\end{align*}
\end{example}

 

\begin{example}\label{ex:succ}
	Consider the satisfiable set of clauses 
	$S_{\ref{ex:succ}} = \{ 
	\lnot\mE(\msucc(x), \mzero), 
	\lnot \mE(\msucc(x), \msucc(y)) \lor \mE(x,y)
	\}$ with binary predicate symbol $\mE$, unary function symbol $\msucc$, and constant symbol $\mzero$.
	\begin{align*}
	H_0 :=&\quad \{ \mzero \} & \mcC_0' &= \{  
	\lnot\mE(\msucc(\mzero), \mzero), 
	\lnot \mE(\msucc(\mzero), \msucc(\mzero)) \lor \mE(\mzero,\mzero)
	\}
	\\
	H_1 :=&\quad \{ \msucc(\mzero) \} & \mcC_1' &= \{ 
		\lnot\mE(\msucc(\msucc(\mzero), \mzero),
		\lnot \mE(\msucc(\msucc(\mzero)), \msucc(\msucc(\mzero))) \lor \mE(\msucc(\mzero),\msucc(\mzero))
	 \}
	 \\\ldots
	 \\
	 H_i :=&\quad \{ 
	 \msucc(\msucc^i(\mzero)) \} & \mcC_i' &= \{  
	 \lnot\mE(\msucc(\msucc^i(\mzero)), \mzero), 
	 \lnot \mE(\msucc(\msucc^i(\mzero)), \msucc(\msucc^i(\mzero)) \lor \mE(\msucc^i(\mzero),\msucc^i(\mzero))
	 \}
	\end{align*} 
	It is easy to see that each $\mcC_i'$ is satisfiable and Gilmore's prover will proceed for ever.
	\begin{align*}
	A := &\ \{ \mzero \} \\
	s := &\ \mzero\mapsto\mzero \\
	\mE := &\ \{\ \} \subseteq A\times A
	\end{align*}
\end{example}



Gilmore's prover has two main disadvantages:
\begin{enumerate}
	\item The generation of all instances up to a certain term depth.
	\item The transformation to a disjunctive normal form to check unsatisfiability.
\end{enumerate}

The second was already addressed by Davis and Putnam in 1960
which lead to the development of effective SAT Solvers.

\begin{example}\label{ex:unsatE2}
	Consider the unsatisfiable set of clauses 
	\[ 
	S_{\ref{ex:unsatE2}} = 
	\{
	\lnot\mE(\ms(x),x), \mE(\ms(\ms^i(y), \ms^i(y)) 
	\} 
	\]
	Now we would have to construct $C'_{1233}$ to get instance $\lnot\mE(\ms(\ms^i(y), \ms^i(y))$
\end{example}

\section{InstGen}

\begin{example}\label{ex:unsat2}
Consider the unsatifiable set of instances
$ 
\{
\lnot\mE(\ms(\ms^i(\mzero), \ms^i(\mc)), \mE(\ms(\ms^i(\mc), \ms^i(\mc)) 
\} 
$
that is clearly an unsatisfiable subset of all ground instances of $S_{\ref{ex:unsatE2}}$.

\end{example}




\section{Equality}



	An equational interpretation must satisfy the formulas for reflexivity, symmetry, transitivity, 
	function congruence for every function symbol $f\in\mcFf$, 
	and predicate congruence for every predicate symbol $P\in\mcFP$.
%	\[

%		\begin{array}[t]{c}
%		x\mEQ x 
%\qquad
%		x\mNE y\lor y\mEQ x
%\qquad		
%		x\mNE y\lor y\mNE z\lor x\mEQ z \\[0.7em]
%%		
%x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) \\[0.7em]
%%
%x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n)
%
%		\end{array}
%	\]

\begin{example}
	Consider the set of clauses $\{ \mc \mEQ \mb \}$. Here we cannot find a Hebrand model where the equality symbol is interpreted as equality on its domain.
\end{example}

\begin{align*}
	 x \mEQ x & \tag*{reflexivity} \\
	x \mNE y \lor y \mEQ x & \tag*{symmetry}\\
	x\mNE y\lor y\mNE z\lor x\mEQ z & \tag*{transitivity} \\
	x_1 \mNE y_1\lor\ldots\lor x_n \mNE y_n\lor f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mNE y_1\lor\ldots\lor x_n\mNE y_n\lor\lnot P_i(x_1,\ldots,x_n)\lor P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	x_1\mNE y_1\lor x_2\mNE y_2
	\lor x_1\mNE x_2
	\lor y_1\mEQ y_2
	\tag*{$\mEQ$-congruence}
\end{align*}

\begin{align*}
	x \mEQ x & \tag*{reflexivity} 
	\\
	x \mEQ y \limp y \mEQ x & \tag*{symmetry}
	\\
	(x\mEQ y\land y\mEQ z)\limp x\mEQ z & \tag*{transitivity} 
	\\
	(x_1 \mEQ y_1\land\ldots\land x_n \mEQ y_n)\limp f(x_1,\ldots,x_n)\mEQ f(y_1,\ldots,y_n) &\quad f\in\mcFfn
	\tag*{f-congruence}
	\\
	x_1\mEQ y_1\land\ldots\land x_n\mNE y_n\land P_i(x_1,\ldots,x_n)
	\limp P(y_i,\ldots,y_n) &\quad P\in\mcFPn
	\tag*{P-congruence}
	\\[0.7em]
	(x_1\mEQ y_1
	\land x_2\mEQ y_2
	\land x_1\mEQ x_2)
	\limp y_1\mEQ y_2
	& \quad P\in\mcFPn[2]
		\tag*{$\mEQ$-congruence}
\end{align*}
	
	



\section{Inst-Gen}

\section{Equality predicate}

Consider the satisfiable set of clauses $S = \{a \relation b, b \relation c, \mP(\ma), \lnot \mP(\mc) \}$

When we use the equality symbol as a predicate symbol 
then at least we expect a congruence relation.



